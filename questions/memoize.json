{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "JavaScript",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "assessmentSummary": null,
        "category": "JavaScript",
        "changelog": [],
        "customInputVars": [],
        "difficulty": 0,
        "hints": [
            "<p>\n  JavaScript objects cannot have keys other than strings and symbols, so you will need to use\n  <span>Map</span> instead.\n</p>\n",
            "\n<p>\n  The <span>Map</span> object has methods for <span>clear</span>, <span>delete</span>, and\n  <span>has</span>, which can all be useful here for the required methods with the same names.\n</p>"
        ],
        "isLongOutput": false,
        "isSlowExecution": false,
        "jsonTests": [],
        "languagesSupported": [
            "javascript"
        ],
        "name": "Memoize",
        "notes": "",
        "prompt": "<div class=\"html\">\n  <p>\n    Write a <span>memoize</span> function that takes in a required <span>callback</span> function\n    and an optional <span>resolver</span> function. The <span>memoize</span> function returns a\n    memoized version of the <span>callback</span> function, which is defined as follows:\n  </p>\n\n  <ul>\n    <li>\n      All of the return values of the memoized function are cached. If the memoized callback is\n      called with an existing cache key (defined below), then that cached value is returned without\n      invoking the <span>callback</span> again.\n    </li>\n    <li>\n      The cache key is defined based on the optional <span>resolver</span> function. If a\n      <span>resolver</span> function is not provided, then the cache key is the result of passing\n      the memoized function arguments to <span>JSON.stringify</span> as an array. If a custom\n      <span>resolver</span> function is provided, then the arguments should be individually passed to that\n      function instead, and its return value will be the cache key (note that this can be of any\n      type).\n    </li>\n    <li>\n      The memoized function should also have three methods:\n      <ul>\n        <li><span>clear()</span>: Clears out the cache.</li>\n        <li>\n          <span>delete(...args)</span>: Deletes the cache entry corresponding to the passed\n          arguments if one exists.\n        </li>\n        <li>\n          <span>has(...args)</span>: Returns a boolean of true if the cache has an entry\n          corresponding to the passed arguments, otherwise false.\n        </li>\n      </ul>\n    </li>\n  </ul>\n  <p>\n    For simplicity, you don't need to worry about binding a\n    <span>this</span> context (i.e., you can assume that the <span>callback</span> doesn't reference\n    <span>this</span>).\n  </p>\n\n  <h3>Sample Usage</h3>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -10px\">\n  <pre class=\"line-numbers\"><code class=\"language-javascript\">const callback = (...args) => args;\nconst memoized = memoize(callback);\nmemoized(123); // calls callback, returns 123\nmemoized(123); // returns 123\nmemoized(123, 'abc'); // calls callback, returns [123, 'abc']\n\nconst memoized2 = memoize(callback, args => args[0]);\nmemoized2(123); // calls callback, returns 123\nmemoized2(123); // returns 123\nmemoized2(123, 'abc'); // returns 123\nmemoized2('abc', 123); // calls callback, returns ['abc', 123]\nmemoized2('abc'); // returns ['abc', 123]</code></pre>\n</div>",
        "releaseDate": "2022-08-03T00:00:00Z",
        "resources": {
            "javascript": {
                "language": "javascript",
                "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\nconst chai = require('chai');\nconst spies = require('chai-spies');\nconst {expect} = chai;\n\nchai.use(spies);\nconst spy = () => chai.spy(() => {});\n\nconst {memoize} = require('./program.js');\n\ndescribe('memoize', () => {\n  it('callback without parameters is never called twice', () => {\n    const callback = chai.spy(() => {});\n    const memoized = memoize(callback);\n    expect(callback).to.have.been.called.exactly(0);\n    memoized();\n    expect(callback).to.have.been.called.exactly(1);\n    memoized();\n    expect(callback).to.have.been.called.exactly(1);\n    memoized();\n    memoized();\n    expect(callback).to.have.been.called.exactly(1);\n  });\n\n  it('callback with a single parameter is handled properly', () => {\n    const callback = chai.spy(val => val * 2);\n    const memoized = memoize(callback);\n    expect(callback).to.have.been.called.exactly(0);\n    const val1 = memoized(1);\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val1).to.equal(2);\n\n    const val2 = memoized(1);\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val2).to.equal(2);\n\n    const val3 = memoized(2);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val3).to.equal(4);\n\n    const val4 = memoized(2);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val4).to.equal(4);\n\n    const val5 = memoized(1);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val5).to.equal(2);\n  });\n\n  it('has function works as expected', () => {\n    const callback = chai.spy((...args) => args);\n    const memoized = memoize(callback);\n\n    expect(memoized.has()).to.be.false;\n    expect(memoized.has(123)).to.be.false;\n    expect(memoized.has(123, 'abc')).to.be.false;\n\n    memoized();\n    expect(memoized.has()).to.be.true;\n\n    memoized(123);\n    expect(memoized.has(123)).to.be.true;\n\n    memoized(123, 'abc');\n    expect(memoized.has(123, 'abc')).to.be.true;\n\n    expect(callback).to.have.been.called.exactly(3);\n  });\n});\n",
                "solutions": [
                    "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nfunction memoize(callback, resolver) {\n  const cache = new Map();\n\n  function getCacheKey(args) {\n    return resolver != null ? resolver(...args) : JSON.stringify(args);\n  }\n\n  const memoized = function (...args) {\n    const cacheKey = getCacheKey(args);\n\n    if (cache.has(cacheKey)) {\n      return cache.get(cacheKey);\n    }\n\n    const output = callback(...args);\n    cache.set(cacheKey, output);\n    return output;\n  };\n\n  memoized.clear = function () {\n    cache.clear();\n  };\n\n  memoized.delete = function (...args) {\n    const cacheKey = getCacheKey(args);\n    cache.delete(cacheKey);\n  };\n\n  memoized.has = function (...args) {\n    const cacheKey = getCacheKey(args);\n    return cache.has(cacheKey);\n  };\n\n  return memoized;\n}\n\n// Do not edit the line below.\nexports.memoize = memoize;\n"
                ],
                "solutionsDisabled": false,
                "startingCode": "function memoize(callback, resolver) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.memoize = memoize;\n",
                "unitTests": "const chai = require('chai');\nconst spies = require('chai-spies');\nconst {expect} = chai;\n\nchai.use(spies);\nconst spy = () => chai.spy(() => {});\n\nconst {memoize} = require('./program.js');\n\ndescribe('memoize', () => {\n  it('callback without parameters is never called twice', () => {\n    const callback = chai.spy(() => {});\n    const memoized = memoize(callback);\n    expect(callback).to.have.been.called.exactly(0);\n    memoized();\n    expect(callback).to.have.been.called.exactly(1);\n    memoized();\n    expect(callback).to.have.been.called.exactly(1);\n    memoized();\n    memoized();\n    expect(callback).to.have.been.called.exactly(1);\n  });\n\n  it('return value is correct with no parameters', () => {\n    const callback = chai.spy(() => 123);\n    const memoized = memoize(callback);\n    let returnVal = memoized();\n    expect(returnVal).to.equal(123);\n    returnVal = memoized();\n    expect(returnVal).to.equal(123);\n  });\n\n  it('callback with a single parameter is handled properly', () => {\n    const callback = chai.spy(val => val * 2);\n    const memoized = memoize(callback);\n    expect(callback).to.have.been.called.exactly(0);\n    const val1 = memoized(1);\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val1).to.equal(2);\n\n    const val2 = memoized(1);\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val2).to.equal(2);\n\n    const val3 = memoized(2);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val3).to.equal(4);\n\n    const val4 = memoized(2);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val4).to.equal(4);\n\n    const val5 = memoized(1);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val5).to.equal(2);\n  });\n\n  it('callback with multiple parameters is handled properly', () => {\n    const callback = chai.spy((x, y) => x + y);\n    const memoized = memoize(callback);\n    expect(callback).to.have.been.called.exactly(0);\n\n    const val1 = memoized(1, 2);\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val1).to.equal(3);\n\n    const val2 = memoized(1, 2);\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val2).to.equal(3);\n\n    const val3 = memoized(2, 1);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val3).to.equal(3);\n\n    const val4 = memoized(1, 3);\n    expect(callback).to.have.been.called.exactly(3);\n    expect(val4).to.equal(4);\n\n    const val5 = memoized(1, 3);\n    expect(callback).to.have.been.called.exactly(3);\n    expect(val5).to.equal(4);\n  });\n\n  it('callback with a variable number of parameters is handled properly', () => {\n    const callback = chai.spy((...args) => args.reduce((acc, curr) => acc + curr, 0));\n    const memoized = memoize(callback);\n    expect(callback).to.have.been.called.exactly(0);\n\n    const val1 = memoized(1, 2);\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val1).to.equal(3);\n\n    const val2 = memoized(1, 2, 3);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val2).to.equal(6);\n\n    const val3 = memoized(1);\n    expect(callback).to.have.been.called.exactly(3);\n    expect(val3).to.equal(1);\n\n    const val4 = memoized(1, 3);\n    expect(callback).to.have.been.called.exactly(4);\n    expect(val4).to.equal(4);\n\n    const val5 = memoized(1, 2, 3);\n    expect(callback).to.have.been.called.exactly(4);\n    expect(val5).to.equal(6);\n\n    const val6 = memoized(1, 2);\n    expect(callback).to.have.been.called.exactly(4);\n    expect(val6).to.equal(3);\n\n    const val7 = memoized();\n    expect(callback).to.have.been.called.exactly(5);\n    expect(val7).to.equal(0);\n\n    const val8 = memoized();\n    expect(callback).to.have.been.called.exactly(5);\n    expect(val7).to.equal(0);\n  });\n\n  it('parameters can be of different types', () => {\n    const callback = chai.spy((...args) => args);\n    const memoized = memoize(callback);\n    expect(callback).to.have.been.called.exactly(0);\n\n    const val1 = memoized('0');\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val1).to.deep.equal(['0']);\n\n    const val2 = memoized(0);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val2).to.deep.equal([0]);\n\n    const val3 = memoized('0');\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val3).to.deep.equal(['0']);\n\n    const val4 = memoized(0);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val4).to.deep.equal([0]);\n\n    const args = [() => {}, {}, [1, 2, 3], true, 'abc', 123, Symbol(), undefined, null];\n    const val5 = memoized(...args);\n    expect(callback).to.have.been.called.exactly(3);\n    expect(val5).to.deep.equal(args);\n\n    const val6 = memoized(...args);\n    expect(callback).to.have.been.called.exactly(3);\n    expect(val6).to.deep.equal(args);\n\n    args.pop();\n    const val7 = memoized(...args);\n    expect(callback).to.have.been.called.exactly(4);\n    expect(val7).to.deep.equal(args);\n\n    args.push(null);\n    const val8 = memoized(...args);\n    expect(callback).to.have.been.called.exactly(4);\n    expect(val8).to.deep.equal(args);\n  });\n\n  it('custom cache key resolver can be passed', () => {\n    const callback = chai.spy((...args) => args);\n    const memoized = memoize(callback, () => 'key');\n\n    const val1 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val1).to.deep.equal([123, 'abc']);\n\n    const val2 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val2).to.deep.equal([123, 'abc']);\n\n    const val3 = memoized(1234, 'abcd');\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val3).to.deep.equal([123, 'abc']);\n\n    const val4 = memoized(() => {}, {}, [1, 2, 3], true, 'abc', 123, Symbol(), undefined, null);\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val4).to.deep.equal([123, 'abc']);\n\n    const callback2 = chai.spy((...args) => args);\n    const memoized2 = memoize(callback2, (...args) => args.reduce((acc, curr) => acc + curr, 0));\n\n    const val5 = memoized2(1, 2, 3);\n    expect(callback2).to.have.been.called.exactly(1);\n    expect(val5).to.deep.equal([1, 2, 3]);\n\n    const val6 = memoized2(3, 2, 1);\n    expect(callback2).to.have.been.called.exactly(1);\n    expect(val6).to.deep.equal([1, 2, 3]);\n\n    const val7 = memoized2(1, 2);\n    expect(callback2).to.have.been.called.exactly(2);\n    expect(val7).to.deep.equal([1, 2]);\n\n    const val8 = memoized2(3);\n    expect(callback2).to.have.been.called.exactly(2);\n    expect(val8).to.deep.equal([1, 2]);\n  });\n\n  it('callback can be memoized multiple times', () => {\n    const callback = chai.spy((...args) => args);\n    const memoized = memoize(callback, () => 'key');\n    const memoized2 = memoize(callback, (...args) => args.reduce((acc, curr) => acc + curr, 0));\n\n    const val1 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val1).to.deep.equal([123, 'abc']);\n\n    const val2 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val2).to.deep.equal([123, 'abc']);\n\n    const val3 = memoized2(1, 2, 3);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val3).to.deep.equal([1, 2, 3]);\n\n    const val4 = memoized2(3, 2, 1);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val4).to.deep.equal([1, 2, 3]);\n\n    const val5 = memoized2(3, 2);\n    expect(callback).to.have.been.called.exactly(3);\n    expect(val5).to.deep.equal([3, 2]);\n  });\n\n  it('clear function works as expected', () => {\n    const callback = chai.spy((...args) => args);\n    const memoized = memoize(callback);\n\n    const val1 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val1).to.deep.equal([123, 'abc']);\n\n    const val2 = memoized(123);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val2).to.deep.equal([123]);\n\n    const val3 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val3).to.deep.equal([123, 'abc']);\n\n    memoized.clear();\n\n    const val4 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(3);\n    expect(val4).to.deep.equal([123, 'abc']);\n\n    const val5 = memoized(123);\n    expect(callback).to.have.been.called.exactly(4);\n    expect(val5).to.deep.equal([123]);\n\n    const val6 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(4);\n    expect(val6).to.deep.equal([123, 'abc']);\n\n    memoized.clear();\n\n    const val7 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(5);\n    expect(val7).to.deep.equal([123, 'abc']);\n\n    const val8 = memoized(123);\n    expect(callback).to.have.been.called.exactly(6);\n    expect(val8).to.deep.equal([123]);\n\n    const val9 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(6);\n    expect(val9).to.deep.equal([123, 'abc']);\n  });\n\n  it('delete function works as expected', () => {\n    const callback = chai.spy((...args) => args);\n    const memoized = memoize(callback);\n\n    const val1 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(1);\n    expect(val1).to.deep.equal([123, 'abc']);\n\n    const val2 = memoized(123);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val2).to.deep.equal([123]);\n\n    const val3 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(2);\n    expect(val3).to.deep.equal([123, 'abc']);\n\n    memoized.delete(123, 'abc');\n\n    const val4 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(3);\n    expect(val4).to.deep.equal([123, 'abc']);\n\n    const val5 = memoized(123);\n    expect(callback).to.have.been.called.exactly(3);\n    expect(val5).to.deep.equal([123]);\n\n    memoized.delete(123, 'abc');\n\n    const val6 = memoized(123, 'abc');\n    expect(callback).to.have.been.called.exactly(4);\n    expect(val6).to.deep.equal([123, 'abc']);\n\n    memoized.delete(123);\n    const val7 = memoized(123);\n    expect(callback).to.have.been.called.exactly(5);\n    expect(val7).to.deep.equal([123]);\n  });\n\n  it('has function works as expected', () => {\n    const callback = chai.spy((...args) => args);\n    const memoized = memoize(callback);\n\n    expect(memoized.has()).to.be.false;\n    expect(memoized.has(123)).to.be.false;\n    expect(memoized.has(123, 'abc')).to.be.false;\n\n    memoized();\n    expect(memoized.has()).to.be.true;\n\n    memoized(123);\n    expect(memoized.has(123)).to.be.true;\n\n    memoized(123, 'abc');\n    expect(memoized.has(123, 'abc')).to.be.true;\n\n    expect(callback).to.have.been.called.exactly(3);\n  });\n\n  it('clear, delete and has functions can be called together', () => {\n    const callback = chai.spy((...args) => args);\n    const memoized = memoize(callback);\n\n    memoized(123);\n    expect(memoized.has(123)).to.be.true;\n    memoized.delete(123);\n    expect(memoized.has(123)).to.be.false;\n    memoized(123);\n    expect(memoized.has(123)).to.be.true;\n    memoized.clear();\n    expect(memoized.has(123)).to.be.false;\n    memoized(123);\n    expect(memoized.has(123)).to.be.true;\n    expect(memoized.has(123, 'abc')).to.be.false;\n    memoized(123, 'abc');\n    expect(memoized.has(123)).to.be.true;\n    expect(memoized.has(123, 'abc')).to.be.true;\n    memoized.clear();\n    expect(memoized.has(123)).to.be.false;\n    expect(memoized.has(123, 'abc')).to.be.false;\n  });\n});\n"
            }
        },
        "spaceTime": "",
        "submissionStatistics": {
            "correctCount": 1069,
            "failureCount": 239
        },
        "testStrategy": "SANDBOX_ONLY",
        "tests": [],
        "uid": "memoize",
        "version": 0,
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 0,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "732835796"
        },
        "visualization": {
            "inputType": null,
            "outputType": null
        }
    },
    "difficulty": 0,
    "instructor": "Conner Ardman",
    "name": "Memoize",
    "releaseDate": "2022-08-03T00:00:00Z",
    "type": "CODING_STANDARD",
    "uid": "memoize"
}