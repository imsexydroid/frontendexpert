{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "React Components",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "category": "React Components",
        "hints": [
            "<p>\n  It can be helpful to keep a few state variables for this problem. A good\n  approach is to have one to keep track of where the tiles are, another to\n  keep track of which tiles are selected and a third to keep track of which\n  ones have already been matched.\n</p>"
        ],
        "languageToWrite": "jsx",
        "name": "Memory",
        "notes": "<div class=\"html\">\n  <p>\n    There's a small edge case missed in the solution given in the video\n    explanation. If the user attempts to select a tile that is already in\n    <span>matchedTiles</span>, that tile should not be selectable. This is\n    addressed in the solution by checking if this condition is true in the\n    <span>selectTile</span> function:\n    <span>matchedTiles.includes(index)</span>. If it is true, that function\n    simply returns without selecting any tiles.\n  </p>\n</div>",
        "prompt": "<div class=\"html\">\n  <p>\n    You're given a CSS file for a memory game, and you need\n    to implement the component using React.\n  </p>\n\n  <p>\n    When the component first mounts, it should render an <span>h1</span>\n    with the text content of <span>Memory</span> followed by a <span>div</span>\n    with the CSS class of <span>board</span>.\n  </p>\n\n  <p>\n    The board should contain 2 tile divs for each element in the given\n    <span>TILE_COLORS</span> array ('red', 'green', 'blue', and 'yellow').\n    These tiles should be in a random order, based on a single call to the\n    given <span>shuffle</span> function.\n  </p>\n\n  <p>\n    Each tile div should have the tile class. When a tile is clicked on, it\n    should be considered selected, and it should also be given its class from\n    the <span>TILE_COLORS</span> array. Clicking on a tile that is already\n    selected should have no effect.\n  </p>\n\n  <p>\n    When two tiles are selected, they should be compared to check for a match.\n    If there is a match, the tiles should keep their color class. If there is\n    no match, then after 1 second both tiles should have their color classes\n    removed. During this 1 second waiting period, no other tiles should be\n    selectable.\n  </p>\n\n  <p>\n    Once all of the matches have been found (i.e. every tile has its color\n    class), The <span>h1</span> text content should change to\n    <span>You Win!</span>. Additionally, a button should appear below the\n    board div with the text content of <span>Restart</span>. When this button\n    is clicked on, the tiles should all be flipped over (the color classes\n    removed), and they should be shuffled into new random locations to restart\n    the game. The <span>h1</span> text content should also return to the\n    initial text content of <span>Memory</span>, and the restart button should\n    be removed from the page.\n  </p>\n\n  <p>\n    The complete HTML output of the memory component might look something like\n    this initially:\n  </p>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -15px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-markup\">&lt;h1&gt;Memory&lt;/h1&gt;\n&lt;div class=\"board\"&gt;\n  &lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n</div>\n\n<div class=\"html\">\n  <p>\n    After the game completes, that HTML might change to this:\n  </p>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -15px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-markup\">&lt;h1&gt;You Win!&lt;/h1&gt;\n&lt;div class=\"board\"&gt;\n  &lt;div class=\"tile red\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile blue\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile red\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile yellow\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile blue\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile yellow\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile green\"&gt;&lt;/div&gt;\n  &lt;div class=\"tile green\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;button&gt;Restart&lt;/button&gt;</code></pre>\n</div>\n\n<div class=\"html\">\n  <p>\n    Your component has already been rendered to the DOM inside of a\n    <span>#root</span> div directly in the body with the CSS imported.\n  </p>\n</div>",
        "promptCode": {
            "css": "#root {\n  background-color: lightgrey;\n  text-align: center;\n}\n\nh1 {\n  margin-bottom: 0;\n}\n\nbutton, input[type=\"button\"] {\n  display: block;\n  margin: 0 10px 10px auto;\n  cursor: pointer;\n  padding: 12px;\n  font-size: 16px;\n  border-radius: 8px;\n  background-color: #02203c;\n  color: white;\n}\n\n.board {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n  gap: 10px;\n  padding: 10px;\n}\n\n.tile {\n  flex-basis: 40%;\n  border: 1px solid black;\n  width: 20px;\n  height: 20px;\n  background-color: white;\n}\n\n.red {\n  background-color: red;\n}\n\n.green {\n  background-color: green;\n}\n\n.blue {\n  background-color: blue;\n}\n\n.yellow {\n  background-color: yellow;\n}"
        },
        "reactConfig": {
            "componentName": "Memory"
        },
        "solutions": {
            "jsx": [
                "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nimport React, {useState, useEffect} from 'react';\n\nconst TILE_COLORS = ['red', 'green', 'blue', 'yellow'];\n\nexport default function Memory() {\n  const [board, setBoard] = useState(() => shuffle([...TILE_COLORS, ...TILE_COLORS]));\n  const [selectedTiles, setSelectedTiles] = useState([]);\n  const [matchedTiles, setMatchedTiles] = useState([]);\n\n  useEffect(() => {\n    if (selectedTiles.length < 2) return;\n\n    if (board[selectedTiles[0]] === board[selectedTiles[1]]) {\n      setMatchedTiles([...matchedTiles, ...selectedTiles]);\n      setSelectedTiles([]);\n    } else {\n      const timeoutId = setTimeout(() => setSelectedTiles([]), 1000);\n      return () => clearTimeout(timeoutId);\n    }\n  }, [selectedTiles]);\n\n  const selectTile = index => {\n    if (\n      selectedTiles.length >= 2 ||\n      selectedTiles.includes(index) ||\n      matchedTiles.includes(index)\n    ) return;\n    setSelectedTiles([...selectedTiles, index]);\n  };\n\n  const restartGame = () => {\n    setBoard(shuffle([...TILE_COLORS, ...TILE_COLORS]));\n    setSelectedTiles([]);\n    setMatchedTiles([]);\n  };\n\n  const didPlayerWin = matchedTiles.length === board.length;\n\n  return (\n    <>\n      <h1>{didPlayerWin ? 'You Win!' : 'Memory'}</h1>\n      <div className=\"board\">\n        {board.map((tileColor, i) => {\n          const isTurnedOver = selectedTiles.includes(i) || matchedTiles.includes(i);\n          const className = isTurnedOver ? `tile ${tileColor}` : 'tile';\n          return <div key={i} className={className} onClick={() => selectTile(i)} />;\n        })}\n      </div>\n      {didPlayerWin && <button onClick={restartGame}>Restart</button>}\n    </>\n  );\n}\n\n/**\n * Returns the array shuffled into a random order.\n * Do not edit this function.\n */\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const randomIndex = Math.floor(Math.random() * (i + 1));\n\n    // Swap the elements at i and randomIndex\n    [array[i], array[randomIndex]] = [array[randomIndex], array[i]];\n  }\n  return array;\n}"
            ]
        },
        "startingCode": {
            "jsx": "import React from 'react';\n\nconst TILE_COLORS = ['red', 'green', 'blue', 'yellow'];\n\nexport default function Memory() {\n  // Write your code here.\n\n  return (\n    <>\n      {/* Write your code here. */}\n    </>\n  );\n}\n\n/**\n * Returns the array shuffled into a random order.\n * Do not edit this function.\n */\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const randomIndex = Math.floor(Math.random() * (i + 1));\n\n    // Swap the elements at i and randomIndex\n    [array[i], array[randomIndex]] = [array[randomIndex], array[i]];\n  }\n  return array;\n}"
        },
        "submissionStatistics": {
            "correctCount": 933,
            "failureCount": 447
        },
        "testHarness": {
            "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Memory from './program';\nimport {act, Simulate} from 'react-dom/test-utils';\nconst {JSDOM} = require('jsdom');\nconst chai = require('chai');\nconst {expect} = chai;\nconst FakeTimers = require('@sinonjs/fake-timers');\n\nlet rootContainer;\n\nconst clock = FakeTimers.install({\n  now: Date.now(),\n});\n\nconst resetDom = () => {\n  const dom = new JSDOM({\n    url: 'http://localhost:3000',\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n\n  for (const [key, value] of Object.entries(React)) {\n    global[key] = value;\n  }\n\n  rootContainer = document.createElement('div');\n  rootContainer.id = 'root';\n  document.body.appendChild(rootContainer);\n\n  act(() => {\n    ReactDOM.render(<Memory />, rootContainer);\n  });\n};\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\nfunction beatGame() {\n  const tiles = document.querySelectorAll('.tile');\n  const locations = {red: [], green: [], blue: [], yellow: []};\n\n  tiles.forEach((tile, i) => {\n    act(() => tile.click());\n    locations[tile.className.replace('tile', '').replace(' ', '')].push(i);\n    clock.tick(1000);\n  });\n\n  for (const locationsArr of Object.values(locations)) {\n    const tile1 = tiles[locationsArr[0]];\n    const tile2 = tiles[locationsArr[1]];\n    if (tile1.classList.length <= 1 && tile2.classList.length <= 1) {\n      act(() => tile1.click());\n      act(() => tile2.click());\n    }\n  }\n  return locations;\n}\n\ndescribe('Memory', () => {\n  beforeEach(() => {\n    resetDom();\n  });\n\n  afterEach(() => {\n    ReactDOM.unmountComponentAtNode(rootContainer);\n    rootContainer.remove();\n    rootContainer = null;\n  });\n\n  it('has correct initial heading', () => {\n    expect(document.querySelector('h1').textContent).to.equal('Memory');\n  });\n\n  it('creates 2 tiles for each color with tile class', () => {\n    expect(document.querySelectorAll('.tile').length).to.equal(8);\n  });\n\n  it('beating game updates the heading', () => {\n    beatGame();\n    expect(document.querySelector('h1').textContent).to.equal('You Win!');\n  });\n});\n",
            "unitTests": "/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Memory from './program';\nimport {act, Simulate} from 'react-dom/test-utils';\nconst {JSDOM} = require('jsdom');\nconst chai = require('chai');\nconst {expect} = chai;\nconst FakeTimers = require('@sinonjs/fake-timers');\n\nlet rootContainer;\n\nconst clock = FakeTimers.install({\n  now: Date.now(),\n});\n\nconst resetDom = () => {\n  const dom = new JSDOM({\n    url: 'http://localhost:3000',\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n\n  for (const [key, value] of Object.entries(React)) {\n    global[key] = value;\n  }\n\n  rootContainer = document.createElement('div');\n  rootContainer.id = 'root';\n  document.body.appendChild(rootContainer);\n\n  act(() => {\n    ReactDOM.render(<Memory />, rootContainer);\n  });\n};\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\nfunction beatGame() {\n  const tiles = document.querySelectorAll('.tile');\n  const locations = {red: [], green: [], blue: [], yellow: []};\n\n  tiles.forEach((tile, i) => {\n    act(() => tile.click());\n    locations[tile.className.replace('tile', '').replace(' ', '')].push(i);\n    clock.tick(1000);\n  });\n\n  for (const locationsArr of Object.values(locations)) {\n    const tile1 = tiles[locationsArr[0]];\n    const tile2 = tiles[locationsArr[1]];\n    if (tile1.classList.length <= 1 && tile2.classList.length <= 1) {\n      act(() => tile1.click());\n      act(() => tile2.click());\n    }\n  }\n  return locations;\n}\n\ndescribe('Memory', () => {\n  beforeEach(() => {\n    resetDom();\n  });\n\n  afterEach(() => {\n    ReactDOM.unmountComponentAtNode(rootContainer);\n    rootContainer.remove();\n    rootContainer = null;\n  });\n\n  it('has correct initial heading', () => {\n    expect(document.querySelector('h1').textContent).to.equal('Memory');\n  });\n\n  it('creates 2 tiles for each color with tile class', () => {\n    expect(document.querySelectorAll('.tile').length).to.equal(8);\n  });\n\n  it('tiles do not initially have color classes', () => {\n    document.querySelectorAll('.tile').forEach(tile => {\n      expect(tile.className).to.equal('tile');\n    });\n  });\n\n  it('each color appears twice', () => {\n    const tiles = document.querySelectorAll('.tile');\n\n    const counts = {red: 0, green: 0, blue: 0, yellow: 0};\n    tiles.forEach(tile => {\n      clock.tick(1000);\n      act(() => tile.click());\n      counts[tile.className.replace('tile', '').replace(' ', '')]++;\n    });\n\n    for (const count of Object.values(counts)) {\n      expect(count).to.equal(2);\n    }\n  });\n\n  it('tiles are initially shuffled', () => {\n    const tiles = document.querySelectorAll('.tile');\n\n    const STARTING_ORDER_1 = ['red', 'green', 'blue', 'yellow', 'red', 'green', 'blue', 'yellow'];\n    const STARTING_ORDER_2 = ['red', 'red', 'green', 'green', 'blue', 'blue', 'yellow', 'yellow'];\n    const colorOrder = [];\n    tiles.forEach(tile => {\n      clock.tick(1000);\n      act(() => tile.click());\n      colorOrder.push(tile.className.replace('tile', '').replace(' ', ''));\n    });\n\n    expect(colorOrder).to.not.deep.equal(STARTING_ORDER_1);\n    expect(colorOrder).to.not.deep.equal(STARTING_ORDER_2);\n  });\n\n  it('clicking the same tile twice always yields the same color', () => {\n    const tiles = document.querySelectorAll('.tile');\n\n    tiles.forEach(tile => {\n      clock.tick(1000);\n      act(() => tile.click());\n      const color = tile.className.replace('tile', '').replace(' ', '');\n\n      clock.tick(1000);\n      act(() => tile.click());\n      expect(tile.className.replace('tile', '').replace(' ', '')).to.equal(color);\n    });\n  });\n\n  it('beating game leaves all tiles with colors', () => {\n    beatGame();\n\n    const tiles = document.querySelectorAll('.tile');\n\n    const counts = {red: 0, green: 0, blue: 0, yellow: 0};\n    tiles.forEach(tile => {\n      counts[tile.className.replace('tile', '').replace(' ', '')]++;\n    });\n\n    for (const count of Object.values(counts)) {\n      expect(count).to.equal(2);\n    }\n  });\n\n  it('beating game updates the heading', () => {\n    beatGame();\n    expect(document.querySelector('h1').textContent).to.equal('You Win!');\n  });\n\n  it('restart button is not initially shown', () => {\n    const button = document.querySelector('button, input[type=\"button\"]');\n\n    if (button != null) {\n      expect(button.style.display).to.equal('none');\n    }\n  });\n\n  it('beating game shows restart button', () => {\n    beatGame();\n    const button = document.querySelector('button, input[type=\"button\"]');\n    expect(button.nodeName === 'BUTTON' ? button.textContent : button.value).to.equal('Restart');\n  });\n\n  it('tiles are shuffled after restart', () => {\n    const locations = beatGame();\n    const button = document.querySelector('button, input[type=\"button\"]');\n    act(() => button.click());\n    const locations2 = beatGame();\n\n    // It is possible to randomly get the same order twice, so give it 2 chances\n    if (JSON.stringify(locations) === locations2) {\n      const locations3 = beatGame();\n      const button = document.querySelector('button, input[type=\"button\"]');\n      act(() => button.click());\n      const locations4 = beatGame();\n      expect(locations3).to.not.deep.equal(locations4);\n    }\n  });\n\n  it('restart button removes color classes', () => {\n    beatGame();\n    let button = document.querySelector('button, input[type=\"button\"]');\n    act(() => button.click());\n\n    const tiles = document.querySelectorAll('.tile');\n    tiles.forEach(tile => {\n      expect(tile.className).to.equal('tile');\n    });\n  });\n\n  it('colors are evenly distributed after restart', () => {\n    beatGame();\n    let button = document.querySelector('button, input[type=\"button\"]');\n    act(() => button.click());\n\n    const counts = {red: 0, green: 0, blue: 0, yellow: 0};\n    const tiles = document.querySelectorAll('.tile');\n    tiles.forEach(tile => {\n      act(() => tile.click());\n      counts[tile.className.replace('tile', '').replace(' ', '')]++;\n      clock.tick(1000);\n    });\n\n    for (const count of Object.values(counts)) {\n      expect(count).to.equal(2);\n    }\n  });\n\n  it('restart button creates a new game that can be beaten', () => {\n    beatGame();\n    let button = document.querySelector('button, input[type=\"button\"]');\n    act(() => button.click());\n\n    button = document.querySelector('button, input[type=\"button\"]');\n    if (button != null) {\n      expect(button.style.display).to.equal('none');\n    }\n\n    expect(document.querySelector('h1').textContent).to.equal('Memory');\n\n    beatGame();\n    expect(document.querySelector('h1').textContent).to.equal('You Win!');\n  });\n});\n"
        },
        "testStrategy": "REACT_MOCHA",
        "uid": "memory",
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 0,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "711822409"
        }
    },
    "difficulty": null,
    "instructor": "Conner Ardman",
    "name": "Memory",
    "releaseDate": "2022-05-24T00:00:00Z",
    "type": "CODING_FRONTEND",
    "uid": "memory"
}