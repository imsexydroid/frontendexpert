{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "JavaScript",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "assessmentSummary": null,
        "category": "JavaScript",
        "changelog": [],
        "customInputVars": [],
        "difficulty": 0,
        "hints": [
            "<p>Since these functions are on the <span>Array.prototype</span>, the array can be accessed using the <span>this</span> keyword.</p>"
        ],
        "isLongOutput": false,
        "isSlowExecution": false,
        "jsonTests": [],
        "languagesSupported": [
            "javascript"
        ],
        "name": "Array Methods",
        "notes": "",
        "prompt": "<div class=\"html\">\n  <p>\n    Without calling <span>Array.prototype.map()</span>,\n    <span>Array.prototype.filter()</span>,\n    <span>Array.prototype.reduce()</span>, or\n    <span>Array.prototype.forEach()</span>, implement the following three\n    similar functions on the <span>Array</span> prototype:\n  </p>\n  <ol>\n    <li>\n      <p><span>myMap(callback)</span></p>\n      <p>\n        Without mutating the original array, this function should call the\n        passed <span>callback</span> function on every element of the array and\n        return a new array containing the results of all these calls, in the\n        corresponding order.\n      </p>\n      <p style=\"margin: 0 0 10px 0\">\n        The callback function can take in up to three parameters:\n      </p>\n      <ol>\n        <li>The current value in the array.</li>\n        <li>The current index in the array.</li>\n        <li>The array itself.</li>\n      </ol>\n    </li>\n    <li>\n      <p><span>myFilter(callback)</span></p>\n      <p>\n        Without mutating the original array, this function should call the\n        passed <span>callback</span> function on every element of the array and\n        return a new array containing the values of the original array that,\n        when passed to the callback function, returned <span>true</span>. These\n        values should maintain their original order.\n      </p>\n      <p style=\"margin: 0 0 10px 0\">\n        The callback function takes in the same arguments as the ones that the\n        callback function in <span>myMap</span> takes in.\n      </p>\n    </li>\n    <li>\n      <p><span>myReduce(callback, initialValue)</span></p>\n      <p>\n        Without mutating the original array, this function should call the\n        passed <span>callback</span> function on every element of the array and\n        return the result of the last call to the callback.\n      </p>\n      <p style=\"margin: 0 0 10px 0\">\n        The callback function can take in up to four parameters:\n      </p>\n      <ol>\n        <li>\n          The accumulator, which is the return value of the previous call to the\n          callback. On the first call to the callback, the accumulator should be\n          set to the <span>initialValue</span>. If the\n          <span>initialValue</span> is <span>undefined</span>, then it should be\n          set to the first value of the array, and the callback should skip the\n          first element in the array and be called directly on the second\n          element.\n        </li>\n        <li>The current value in the array.</li>\n        <li>The current index in the array.</li>\n        <li>The array itself.</li>\n      </ol>\n      <p style=\"margin: 0 0 10px 0\">\n        If the array contains no elements, the <span>initialValue</span> should\n        be returned. Note that this differs slightly from the\n        <span>Array.prototype.reduce</span> function.\n      </p>\n    </li>\n  </ol>\n  <p></p>\n  <h3>Sample Usage</h3>\n</div>\n<div class=\"code-wrapper prism\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">const array = [1, 2, 3];\n\nconst mappedArray = array.myMap((value, i, arr) => {\n  return value + i + arr[1];\n});\n\nconst filteredArray = array.myFilter((value, i, arr) => {\n  return (value + i + arr[1]) > 5;\n});\n\nconst reducedValue = array.myReduce((accumulator, value, i, arr) => {\n  return accumulator + value + i + arr[1];\n}, 3);\n\nconsole.log(mappedArray);\nconsole.log(filteredArray);\nconsole.log(reducedValue);</code></pre>\n</div>\n<div class=\"html\">\n  <h3>Sample Output</h3>\n  <pre>\n<span class=\"CodeEditor-promptComment\">// Console logs:</span>\n[3, 5, 7] <span class=\"CodeEditor-promptComment\">// From myMap.</span>\n[3] <span class=\"CodeEditor-promptComment\">// From myFilter.</span>\n18 <span class=\"CodeEditor-promptComment\">// From myReduce.</span>\n</pre>\n</div>",
        "releaseDate": "2021-05-24T00:00:00Z",
        "resources": {
            "javascript": {
                "language": "javascript",
                "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\nconst chai = require('chai');\nconst spies = require('chai-spies');\n\nchai.use(spies);\nconst spy = func => chai.spy(func ? func : () => {});\nconst {expect} = chai;\n\nrequire('./program.js');\n\ndescribe('array methods', () => {\n  describe('myMap', () => {\n    describe('on a non-empty array', () => {\n      it('calls the passed callback for every element with the correct arguments', () => {\n        const array = ['foo', 'bar', 'baz'];\n        const callback = spy();\n        array.myMap(callback);\n\n        expect(callback).to.have.been.called.exactly(3);\n        expect(callback).on.nth(1).to.be.called.with('foo', 0, array);\n        expect(callback).on.nth(2).to.be.called.with('bar', 1, array);\n        expect(callback).on.nth(3).to.be.called.with('baz', 2, array);\n      });\n\n      it('returns a new array with the results of the passed callback being called on every element', () => {\n        const array = [0, 1, 2];\n        const callback = num => num * 2;\n        const output = array.myMap(callback);\n\n        expect(output).to.be.deep.equal([0, 2, 4]);\n      });\n    });\n  });\n\n  describe('myFilter', () => {\n    describe('on a non-empty array', () => {\n      it('calls the passed callback for every element with the correct arguments', () => {\n        const array = ['foo', 'bar', 'baz'];\n        const callback = spy();\n        array.myFilter(callback);\n\n        expect(callback).to.have.been.called.exactly(3);\n        expect(callback).on.nth(1).to.be.called.with('foo', 0, array);\n        expect(callback).on.nth(2).to.be.called.with('bar', 1, array);\n        expect(callback).on.nth(3).to.be.called.with('baz', 2, array);\n      });\n\n      it('returns a new array containing only the elements that the passed callback returns true for', () => {\n        const array = [0, 1, 2, 3, 4, 5];\n        const callback = (_, i) => {\n          if (i === 0) return 'truthy value';\n          if (i === 1) return true;\n          if (i === 2) return false;\n          if (i === 3) return 1;\n          if (i === 4) return 0;\n          if (i === 5) return true;\n        };\n        const output = array.myFilter(callback);\n\n        expect(output).to.be.deep.equal([1, 5]);\n      });\n    });\n  });\n\n  describe('myReduce', () => {\n    describe('on a non-empty array', () => {\n      describe('when the initialValue is undefined', () => {\n        it('calls the passed callback for every element except the first one with the correct arguments', () => {\n          const array = [0, 1, 2];\n          const callback = spy((sum, currentValue) => sum + currentValue);\n          array.myReduce(callback);\n\n          expect(callback).to.have.been.called.exactly(2);\n          expect(callback).on.nth(1).to.be.called.with(0, 1, 1, array);\n          expect(callback).on.nth(2).to.be.called.with(1, 2, 2, array);\n        });\n      });\n\n      describe('when the initialValue is defined', () => {\n        it('calls the passed callback for every element with the correct arguments', () => {\n          const array = [0, 1, 2];\n          const callback = spy((sum, currentValue) => sum + currentValue);\n          array.myReduce(callback, 0);\n\n          expect(callback).to.have.been.called.exactly(3);\n          expect(callback).on.nth(1).to.be.called.with(0, 0, 0, array);\n          expect(callback).on.nth(2).to.be.called.with(0, 1, 1, array);\n          expect(callback).on.nth(3).to.be.called.with(1, 2, 2, array);\n        });\n      });\n\n      it('returns the accumulated value generated by the passed callback', () => {\n        const array = [0, 1, 2, 3, 4, 5];\n        const callback = (sum, currentValue) => sum + currentValue;\n        const output = array.myReduce(callback);\n\n        expect(output).to.be.be.equal(15);\n      });\n    });\n  });\n});\n",
                "solutions": [
                    "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nArray.prototype.myMap = function (callback) {\n  // In this function, `this` is the original array.\n  const output = [];\n  for (let i = 0; i < this.length; i++) {\n    output.push(callback(this[i], i, this));\n  }\n  return output;\n};\n\nArray.prototype.myFilter = function (callback) {\n  // In this function, `this` is the original array.\n  const output = [];\n  for (let i = 0; i < this.length; i++) {\n    if (callback(this[i], i, this) === true) {\n      output.push(this[i]);\n    }\n  }\n  return output;\n};\n\nArray.prototype.myReduce = function (callback, initialValue) {\n  // In this function, `this` is the original array.\n  let accumulator = initialValue;\n  for (let i = 0; i < this.length; i++) {\n    if (i === 0 && initialValue === undefined) {\n      accumulator = this[i];\n    } else {\n      accumulator = callback(accumulator, this[i], i, this);\n    }\n  }\n  return accumulator;\n};\n"
                ],
                "solutionsDisabled": false,
                "startingCode": "Array.prototype.myMap = function (callback) {\n  // Write your code here.\n};\n\nArray.prototype.myFilter = function (callback) {\n  // Write your code here.\n};\n\nArray.prototype.myReduce = function (callback, initialValue) {\n  // Write your code here.\n};\n",
                "unitTests": "const chai = require('chai');\nconst spies = require('chai-spies');\n\nchai.use(spies);\nconst spy = func => chai.spy(func ? func : () => {});\nconst {expect} = chai;\n\nrequire('./program.js');\n\ndescribe('array methods', () => {\n  describe('myMap', () => {\n    describe('on an empty array', () => {\n      it(`doesn't call the passed callback`, () => {\n        const array = [];\n        const callback = spy();\n        array.myMap(callback);\n\n        expect(callback).to.have.been.called.exactly(0);\n      });\n\n      it(`doesn't mutate the array`, () => {\n        const array = [];\n        const callback = spy();\n        array.myMap(callback);\n\n        expect(array).to.be.deep.equal([]);\n      });\n\n      it('returns a new empty array', () => {\n        const array = [];\n        const callback = spy();\n        const output = array.myMap(callback);\n\n        expect(output).to.be.deep.equal([]);\n        expect(output).not.to.be.equal(array);\n      });\n\n      it(`doesn't call the array's native map or forEach methods`, () => {\n        const array = [];\n        chai.spy.on(array, 'map');\n        chai.spy.on(array, 'forEach');\n        const callback = spy();\n        array.myMap(callback);\n\n        expect(array.map).to.have.been.called.exactly(0);\n        expect(array.forEach).to.have.been.called.exactly(0);\n        chai.spy.restore();\n      });\n    });\n\n    describe('on a non-empty array', () => {\n      it('calls the passed callback for every element with the correct arguments', () => {\n        const array = ['foo', 'bar', 'baz'];\n        const callback = spy();\n        array.myMap(callback);\n\n        expect(callback).to.have.been.called.exactly(3);\n        expect(callback).on.nth(1).to.be.called.with('foo', 0, array);\n        expect(callback).on.nth(2).to.be.called.with('bar', 1, array);\n        expect(callback).on.nth(3).to.be.called.with('baz', 2, array);\n      });\n\n      it(`doesn't mutate the array`, () => {\n        const array = ['foo', 'bar', 'baz'];\n        const callback = spy();\n        array.myMap(callback);\n\n        expect(array).to.be.deep.equal(['foo', 'bar', 'baz']);\n      });\n\n      it('returns a new array with the results of the passed callback being called on every element', () => {\n        const array = [0, 1, 2];\n        const callback = num => num * 2;\n        const output = array.myMap(callback);\n\n        expect(output).to.be.deep.equal([0, 2, 4]);\n      });\n\n      it(`doesn't call the array's native map or forEach methods`, () => {\n        const array = ['foo', 'bar', 'baz'];\n        chai.spy.on(array, 'map');\n        chai.spy.on(array, 'forEach');\n        const callback = spy();\n        array.myMap(callback);\n\n        expect(array.map).to.have.been.called.exactly(0);\n        expect(array.forEach).to.have.been.called.exactly(0);\n        chai.spy.restore();\n      });\n    });\n  });\n\n  describe('myFilter', () => {\n    describe('on an empty array', () => {\n      it(`doesn't call the passed callback`, () => {\n        const array = [];\n        const callback = spy();\n        array.myFilter(callback);\n\n        expect(callback).to.have.been.called.exactly(0);\n      });\n\n      it(`doesn't mutate the array`, () => {\n        const array = [];\n        const callback = spy();\n        array.myFilter(callback);\n\n        expect(array).to.be.deep.equal([]);\n      });\n\n      it('returns a new empty array', () => {\n        const array = [];\n        const callback = spy();\n        const output = array.myFilter(callback);\n\n        expect(output).to.be.deep.equal([]);\n        expect(output).not.to.be.equal(array);\n      });\n\n      it(`doesn't call the array's native filter or forEach methods`, () => {\n        const array = [];\n        chai.spy.on(array, 'filter');\n        chai.spy.on(array, 'forEach');\n        const callback = spy();\n        array.myFilter(callback);\n\n        expect(array.filter).to.have.been.called.exactly(0);\n        expect(array.forEach).to.have.been.called.exactly(0);\n        chai.spy.restore();\n      });\n    });\n\n    describe('on a non-empty array', () => {\n      it('calls the passed callback for every element with the correct arguments', () => {\n        const array = ['foo', 'bar', 'baz'];\n        const callback = spy();\n        array.myFilter(callback);\n\n        expect(callback).to.have.been.called.exactly(3);\n        expect(callback).on.nth(1).to.be.called.with('foo', 0, array);\n        expect(callback).on.nth(2).to.be.called.with('bar', 1, array);\n        expect(callback).on.nth(3).to.be.called.with('baz', 2, array);\n      });\n\n      it(`doesn't mutate the array`, () => {\n        const array = ['foo', 'bar', 'baz'];\n        const callback = spy();\n        array.myFilter(callback);\n\n        expect(array).to.be.deep.equal(['foo', 'bar', 'baz']);\n      });\n\n      it('returns a new array containing only the elements that the passed callback returns true for', () => {\n        const array = [0, 1, 2, 3, 4, 5];\n        const callback = (_, i) => {\n          if (i === 0) return 'truthy value';\n          if (i === 1) return true;\n          if (i === 2) return false;\n          if (i === 3) return 1;\n          if (i === 4) return 0;\n          if (i === 5) return true;\n        };\n        const output = array.myFilter(callback);\n\n        expect(output).to.be.deep.equal([1, 5]);\n      });\n\n      it(`doesn't call the array's native filter or forEach methods`, () => {\n        const array = ['foo', 'bar', 'baz'];\n        chai.spy.on(array, 'filter');\n        chai.spy.on(array, 'forEach');\n        const callback = spy();\n        array.myFilter(callback);\n\n        expect(array.filter).to.have.been.called.exactly(0);\n        expect(array.forEach).to.have.been.called.exactly(0);\n        chai.spy.restore();\n      });\n    });\n  });\n\n  describe('myReduce', () => {\n    describe('on an empty array', () => {\n      it(`doesn't call the passed callback`, () => {\n        const array = [];\n        const callback = spy();\n        array.myReduce(callback);\n\n        expect(callback).to.have.been.called.exactly(0);\n      });\n\n      it(`doesn't mutate the array`, () => {\n        const array = [];\n        const callback = spy();\n        array.myReduce(callback);\n\n        expect(array).to.be.deep.equal([]);\n      });\n\n      describe('when the initialValue is undefined', () => {\n        it('returns undefined', () => {\n          const array = [];\n          const callback = spy();\n          const output = array.myReduce(callback);\n\n          expect(output).to.be.be.equal(undefined);\n        });\n      });\n\n      describe('when the initialValue is defined', () => {\n        it('returns the initialValue', () => {\n          const array = [];\n          const callback = spy();\n          const output = array.myReduce(callback, 'foo');\n\n          expect(output).to.be.be.equal('foo');\n        });\n      });\n\n      it(`doesn't call the array's native reduce or forEach methods`, () => {\n        const array = [];\n        chai.spy.on(array, 'reduce');\n        chai.spy.on(array, 'forEach');\n        const callback = spy();\n        array.myReduce(callback);\n\n        expect(array.reduce).to.have.been.called.exactly(0);\n        expect(array.forEach).to.have.been.called.exactly(0);\n        chai.spy.restore();\n      });\n    });\n\n    describe('on a non-empty array', () => {\n      describe('when the initialValue is undefined', () => {\n        it('calls the passed callback for every element except the first one with the correct arguments', () => {\n          const array = [0, 1, 2];\n          const callback = spy((sum, currentValue) => sum + currentValue);\n          array.myReduce(callback);\n\n          expect(callback).to.have.been.called.exactly(2);\n          expect(callback).on.nth(1).to.be.called.with(0, 1, 1, array);\n          expect(callback).on.nth(2).to.be.called.with(1, 2, 2, array);\n        });\n      });\n\n      describe('when the initialValue is defined', () => {\n        it('calls the passed callback for every element with the correct arguments', () => {\n          const array = [0, 1, 2];\n          const callback = spy((sum, currentValue) => sum + currentValue);\n          array.myReduce(callback, 0);\n\n          expect(callback).to.have.been.called.exactly(3);\n          expect(callback).on.nth(1).to.be.called.with(0, 0, 0, array);\n          expect(callback).on.nth(2).to.be.called.with(0, 1, 1, array);\n          expect(callback).on.nth(3).to.be.called.with(1, 2, 2, array);\n        });\n      });\n\n      it(`doesn't mutate the array`, () => {\n        const array = ['foo', 'bar', 'baz'];\n        const callback = spy();\n        array.myReduce(callback);\n\n        expect(array).to.be.deep.equal(['foo', 'bar', 'baz']);\n      });\n\n      it('returns the accumulated value generated by the passed callback', () => {\n        const array = [0, 1, 2, 3, 4, 5];\n        const callback = (sum, currentValue) => sum + currentValue;\n        const output = array.myReduce(callback);\n\n        expect(output).to.be.be.equal(15);\n      });\n\n      it(`doesn't call the array's native reduce or forEach methods`, () => {\n        const array = ['foo', 'bar', 'baz'];\n        chai.spy.on(array, 'reduce');\n        chai.spy.on(array, 'forEach');\n        const callback = spy();\n        array.myReduce(callback);\n\n        expect(array.reduce).to.have.been.called.exactly(0);\n        expect(array.forEach).to.have.been.called.exactly(0);\n        chai.spy.restore();\n      });\n    });\n  });\n});\n"
            }
        },
        "spaceTime": "",
        "submissionStatistics": {
            "correctCount": 3611,
            "failureCount": 2183
        },
        "testStrategy": "SANDBOX_ONLY",
        "tests": [],
        "uid": "array-methods",
        "version": 0,
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 10,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "647962246"
        },
        "visualization": {
            "inputType": null,
            "outputType": null
        }
    },
    "difficulty": 0,
    "instructor": "Conner Ardman",
    "name": "Array Methods",
    "releaseDate": "2021-05-24T00:00:00Z",
    "type": "CODING_STANDARD",
    "uid": "array-methods"
}