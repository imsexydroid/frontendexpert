{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "DOM Manipulation",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "category": "DOM Manipulation",
        "hints": [
            "<p>\n  There are a few different events you can listen to on the text input, but the\n  <span>input</span> event is usually the best option for typeaheads. This will\n  fire every time the user types into the input.\n</p>",
            "<p>\n  <span>setTimeout</span> can be used to delay execution of a function.\n  For example, <span>setTimeout(callback, 1000)</span> would call the <span>callback</span>\n  after one second.\n</p>",
            "<p>\n  <span>setTimeout</span> returns an ID that can be passed to the <span>clearTimeout</span>\n  function to stop the callback from running. This can be combined with another call to\n  <span>setTimeout</span> to reset a timeout. Can you use this to check if\n  500ms have passed since the last time the user typed into the input?\n</p>",
            "<p>\n  While there are a lot of ways to remove elements from the DOM, the easiest way\n  to remove all of an element's children is to simply set the <span>innerHTML</span>\n  property to <span>''</span>.\n</p>"
        ],
        "languageToWrite": "javascript",
        "name": "Typeahead",
        "notes": "",
        "prompt": "<div class=\"html\">\n  <p>\n    You're given an API endpoint that returns a list of FrontendExpert glossary\n    terms that start with a given string, and you have to use this API to\n    implement a search typeahead.\n  </p>\n  <p>\n    For this question, the search typeahead is a special input field (with\n    <span>typeahead</span> as its id) that issues API requests with the text\n    that a user types into it. More specifically, it issues an API request after\n    the user has stopped typing for some time\u2014not while the user is typing\u2014and\n    it displays the results of the API request as suggestions for the user.\n  </p>\n  <p>The provided API expects GET requests at this URL:</p>\n  <pre><span class=\"CodeEditor-promptString CodeEditor-selectable\">https://api.frontendexpert.io/api/fe/glossary-suggestions</span></pre>\n  <p>\n    Each API request should include a <span>text</span> query parameter. For\n    example, this would be a valid URL to request:\n  </p>\n  <pre><span class=\"CodeEditor-promptString CodeEditor-selectable\">https://api.frontendexpert.io/api/fe/glossary-suggestions?text=acc</span></pre>\n  <p>\n    The API responds with a JSON array of strings, each of which is a\n    glossary-term name that starts with the passed <span>text</span>.\n  </p>\n  <p>For example, the URL above might respond with:</p>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -15px\">\n  <pre class=\"line-numbers\"><code class=\"language-json\">[\n  \"Accessibility\",\n  \"Accessibility Tree\"\n]</code></pre>\n</div>\n<div class=\"html\">\n  <p>\n    When the user stops typing into the typeahead for 500ms, a request should be\n    made to the API to get suggestions for the text that's currently typed into\n    the typeahead input field.\n  </p>\n  <p>\n    Once an API request resolves, the suggestions returned by the API should be\n    displayed on the page, replacing any previously displayed suggestions. Each\n    suggestion should be an HTML list item appended to the provided\n    <span>#suggestions-list</span> <span>ul</span>, and each suggestion should\n    have the relevant API-responded glossary-term name as its text content.\n  </p>\n  <p>\n    For example, if the API request above were to resolve, the suggestions HTML\n    would look like this:\n  </p>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -15px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-markup\">&lt;ul id=\"suggestions-list\"&gt;\n  &lt;li&gt;Accessibility&lt;/li&gt;\n  &lt;li&gt;Accessibility Tree&lt;/li&gt;\n&lt;/ul&gt;</code></pre>\n</div>\n<div class=\"html\">\n  <p>\n    If the user clicks on one of the suggestions, its value should be filled\n    into the typeahead, and the displayed suggestions should be cleared.\n  </p>\n  <p>\n    If the user clears the typeahead (e.g., backspaces all of the typed text),\n    the displayed suggestions should be cleared, and no API request should be\n    made.\n  </p>\n  <p>\n    You should use the global <span>fetch()</span> method to make requests to\n    the API (call <span>fetch()</span> directly; don't call\n    <span>window.fetch()</span>).\n  </p>\n  <p>\n    Your JavaScript code has already been linked to the pre-written HTML code\n    via a deferred script tag.\n  </p>\n</div>",
        "promptCode": {
            "css": "* {\n  box-sizing: border-box;\n}\n\n#wrapper {\n  width: 400px;\n  margin: 24px auto;\n}\n\n#typeahead {\n  width: 100%;\n  padding: 10px;\n  border-radius: 8px;\n  border: 2px solid #828080;\n  font-size: 18px;\n  outline: none;\n}\n\n#suggestions-list {\n  width: 100%;\n  padding: 0;\n  border-radius: 8px;\n  margin-top: 8px;\n  box-shadow: 0 5px 10px #4a494933;\n  list-style-type: none;\n  max-height: 200px;\n  overflow: auto;\n}\n\nli {\n  padding: 12px;\n  font-size: 18px;\n  cursor: pointer;\n}\n\nli:first-child {\n  border-top-left-radius: 8px;\n  border-top-right-radius: 8px;\n}\n\nli:last-child {\n  border-bottom-left-radius: 8px;\n  border-bottom-right-radius: 8px;\n}\n\nli:not(.selected, :hover):nth-child(even) {\n  background-color: #e7e7e7;\n}\n\nli:not(.selected, :hover):nth-child(odd) {\n  background-color: white;\n}\n\nli:hover, .selected {\n  background-color: #7ba5f6;\n}\n",
            "html": "<div id=\"wrapper\">\n  <input\n    id=\"typeahead\"\n    type=\"text\"\n    placeholder=\"Search for a glossary term...\"\n    autocomplete=\"off\" />\n  <ul id=\"suggestions-list\"></ul>\n</div>"
        },
        "reactConfig": null,
        "solutions": {
            "javascript": [
                "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nconst BASE_URL = 'https://api.frontendexpert.io/api/fe/glossary-suggestions';\n\nlet timeoutID;\n\nconst input = document.getElementById('typeahead');\nconst suggestionsList = document.getElementById('suggestions-list');\ninput.addEventListener('input', onType);\n\nfunction onType() {\n  if (input.value.length === 0) {\n    clearSuggestions();\n    return;\n  }\n\n  clearTimeout(timeoutID);\n  timeoutID = setTimeout(fetchAndAppendSuggestions, 500);\n}\n\nfunction fetchAndAppendSuggestions() {\n  const url = new URL(BASE_URL);\n  url.searchParams.set('text', input.value);\n  fetch(url)\n    .then(res => res.json())\n    .then(suggestions => {\n      const fragment = document.createDocumentFragment();\n      suggestions.forEach(suggestion => {\n        fragment.appendChild(createSuggestionElement(suggestion));\n      });\n      suggestionsList.replaceChildren(fragment);\n    });\n}\n\nfunction createSuggestionElement(suggestion) {\n  const suggestionElement = document.createElement('li');\n  suggestionElement.textContent = suggestion;\n  suggestionElement.addEventListener('click', () => {\n    input.value = suggestion;\n    clearSuggestions();\n  });\n  return suggestionElement;\n}\n\nfunction clearSuggestions() {\n  clearTimeout(timeoutID);\n  suggestionsList.innerHTML = '';\n}",
                "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nconst BASE_URL = 'https://api.frontendexpert.io/api/fe/glossary-suggestions';\n\nlet timeoutID;\n\nconst input = document.getElementById('typeahead');\nconst suggestionsList = document.getElementById('suggestions-list');\ninput.addEventListener('input', onType);\n\nfunction onType() {\n  if (input.value.length === 0) {\n    clearSuggestions();\n    return;\n  }\n\n  clearTimeout(timeoutID);\n  timeoutID = setTimeout(fetchAndAppendSuggestions, 500);\n}\n\nasync function fetchAndAppendSuggestions() {\n  const url = new URL(BASE_URL);\n  url.searchParams.set('text', input.value);\n  const response = await fetch(url);\n  const suggestions = await response.json();\n\n  const fragment = document.createDocumentFragment();\n  suggestions.forEach(suggestion => {\n    fragment.appendChild(createSuggestionElement(suggestion));\n  });\n  suggestionsList.replaceChildren(fragment);\n}\n\nfunction createSuggestionElement(suggestion) {\n  const suggestionElement = document.createElement('li');\n  suggestionElement.textContent = suggestion;\n  suggestionElement.addEventListener('click', () => {\n    input.value = suggestion;\n    clearSuggestions();\n  });\n  return suggestionElement;\n}\n\nfunction clearSuggestions() {\n  clearTimeout(timeoutID);\n  suggestionsList.innerHTML = '';\n}"
            ]
        },
        "startingCode": {
            "javascript": "const BASE_URL = 'https://api.frontendexpert.io/api/fe/glossary-suggestions';\n\n// Write your code here.\n"
        },
        "submissionStatistics": {
            "correctCount": 1141,
            "failureCount": 495
        },
        "testHarness": {
            "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nconst {JSDOM} = require('jsdom');\nconst {readFileSync} = require('fs');\nconst chai = require('chai');\nconst spies = require('chai-spies');\nchai.use(spies);\nconst {expect, spy} = chai;\nconst FakeTimers = require('@sinonjs/fake-timers');\nconst {getSuggestions} = require('./data/api');\n\nconst clock = FakeTimers.install({\n  now: Date.now(),\n});\nconst html = readFileSync('data/index.html');\n\nlet input;\nlet suggestionsList;\nconst resetSpies = () => {\n  spy.restore();\n  spy.on(global, 'fetch');\n};\n\nconst resetDom = () => {\n  const dom = new JSDOM(html, {\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  const convertStringToUrlObj = url => {\n    const [base, params] = url.split('?');\n    const paramPairs = params?.split('&');\n    const urlObj = new URL(base);\n    paramPairs?.forEach(paramStr => {\n      const [key, value] = paramStr.split('=');\n      urlObj.searchParams.set(key, value);\n    });\n    return urlObj;\n  };\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n\n  Object.defineProperty(window.HTMLElement.prototype, 'innerText', {\n    configurable: true,\n    get() {\n      return this.textContent;\n    },\n    set(val) {\n      this.textContent = val;\n    },\n  });\n\n  global.fetch = url => {\n    const urlObj = typeof url === 'object' ? url : convertStringToUrlObj(url);\n    const acceptedUrls = [\n      'https://www.algoexpert.io/api/fe/glossary-suggestions', // old API endpoint\n      'https://api.frontendexpert.io/api/fe/glossary-suggestions',\n    ];\n    if (!acceptedUrls.includes(urlObj.origin + urlObj.pathname)) {\n      const response = {\n        status: 404,\n        ok: false,\n        statusText: 'Not Found',\n        type: 'cors',\n        url: urlObj.toString(),\n        redirected: false,\n      };\n      return Promise.resolve(response);\n    }\n    const text = urlObj.searchParams.get('text');\n    const suggestions = getSuggestions(text);\n\n    const response = {\n      status: 200,\n      ok: true,\n      statusText: 'OK',\n      type: 'cors',\n      url: urlObj.toString(),\n      redirected: false,\n      json: async () => suggestions,\n      text: async () => JSON.stringify(suggestions),\n    };\n    return Promise.resolve(response);\n  };\n\n  // Reset spies before importing the JS.\n  resetSpies();\n\n  delete require.cache[require.resolve('./program.js')];\n  require('./program.js');\n\n  input = document.getElementById('typeahead');\n  suggestionsList = document.getElementById('suggestions-list');\n};\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\nconst triggerTypeEvents = (char = null) => {\n  input.dispatchEvent(\n    new window.InputEvent('input', {\n      inputType: char != null ? 'insertText' : 'deleteContentBackward',\n      data: char,\n    }),\n  );\n  input.dispatchEvent(new window.Event('change'));\n\n  if (char != null) {\n    const options = {\n      key: char,\n      charCode: 0, // Only set on keypress\n\n      // keycode and which are set to uppercase for keydown/keyup events\n      keyCode: char.toUpperCase().charCodeAt(0),\n      which: char.toUpperCase().charCodeAt(0),\n      code: `Key${char.toUpperCase()}`,\n    };\n\n    input.dispatchEvent(new window.KeyboardEvent('keydown', options));\n    input.dispatchEvent(\n      new window.KeyboardEvent('keypress', {\n        ...options,\n        charCode: char.charCodeAt(0),\n        keyCode: char.charCodeAt(0),\n        which: char.charCodeAt(0),\n      }),\n    );\n    input.dispatchEvent(new window.KeyboardEvent('keyup', options));\n  }\n};\n\nconst typeCharacter = char => {\n  input.value += char;\n  triggerTypeEvents(char);\n};\n\nconst clearInput = () => {\n  input.value = '';\n  triggerTypeEvents();\n};\n\nconst triggerAsyncBehavior = async () => {\n  clock.runAllAsync();\n\n  // Flush async browser behavior.\n  await new Promise(setImmediate);\n};\n\nconst expectSuggestions = expected => {\n  const actual = Array.from(suggestionsList.children).map(li => li.textContent);\n  expect(actual).to.deep.equal(expected);\n};\n\ndescribe('typeahead', () => {\n  beforeEach(() => {\n    resetDom();\n    clock.reset();\n  });\n\n  describe('without typing in input', () => {\n    it('suggestions list is empty', () => {\n      expect(suggestionsList.children.length).to.equal(0);\n    });\n  });\n\n  describe('typing in input', () => {\n    it('does not make an API request before stopping for 500ms', async () => {\n      typeCharacter('a');\n      await triggerAsyncBehavior();\n      expect(global.fetch).to.have.been.called.exactly(0);\n\n      clock.tick(500);\n      await triggerAsyncBehavior();\n      expect(global.fetch).to.have.been.called.exactly(1);\n    });\n\n    it('populates suggestions list on first type after 500ms', async () => {\n      typeCharacter('a');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n\n      expectSuggestions([\n        'Absolute Unit',\n        'Accessibility',\n        'Accessibility Tree',\n        'Animations',\n        'Array',\n        'Arrow Function',\n        'async function',\n        'Atomic CSS',\n        'Attribute',\n        'await',\n      ]);\n    });\n  });\n\n  describe('suggestions', () => {\n    it('use correct elements', async () => {\n      typeCharacter('a');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n\n      Array.from(suggestionsList).forEach(suggestion => {\n        expect(suggestion.tagName).to.equal('LI');\n        expect(suggestion.children.length).to.equal(0);\n      });\n    });\n  });\n\n  describe('clearing input', () => {\n    it('clears suggestions list immediately', async () => {\n      typeCharacter('a');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n      clearInput();\n      expectSuggestions([]);\n    });\n  });\n});\n",
            "unitTests": "/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nconst {JSDOM} = require('jsdom');\nconst {readFileSync} = require('fs');\nconst chai = require('chai');\nconst spies = require('chai-spies');\nchai.use(spies);\nconst {expect, spy} = chai;\nconst FakeTimers = require('@sinonjs/fake-timers');\nconst {getSuggestions} = require('./data/api');\n\nconst clock = FakeTimers.install({\n  now: Date.now(),\n});\nconst html = readFileSync('data/index.html');\n\nlet input;\nlet suggestionsList;\nconst resetSpies = () => {\n  spy.restore();\n  spy.on(global, 'fetch');\n};\n\nconst resetDom = () => {\n  const dom = new JSDOM(html, {\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  const convertStringToUrlObj = url => {\n    const [base, params] = url.split('?');\n    const paramPairs = params?.split('&');\n    const urlObj = new URL(base);\n    paramPairs?.forEach(paramStr => {\n      const [key, value] = paramStr.split('=');\n      urlObj.searchParams.set(key, value);\n    });\n    return urlObj;\n  };\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n\n  Object.defineProperty(window.HTMLElement.prototype, 'innerText', {\n    configurable: true,\n    get() {\n      return this.textContent;\n    },\n    set(val) {\n      this.textContent = val;\n    },\n  });\n\n  global.fetch = url => {\n    const urlObj = typeof url === 'object' ? url : convertStringToUrlObj(url);\n    const acceptedUrls = [\n      'https://www.algoexpert.io/api/fe/glossary-suggestions', // old API endpoint\n      'https://api.frontendexpert.io/api/fe/glossary-suggestions',\n    ];\n    if (!acceptedUrls.includes(urlObj.origin + urlObj.pathname)) {\n      const response = {\n        status: 404,\n        ok: false,\n        statusText: 'Not Found',\n        type: 'cors',\n        url: urlObj.toString(),\n        redirected: false,\n      };\n      return Promise.resolve(response);\n    }\n    const text = urlObj.searchParams.get('text');\n    const suggestions = getSuggestions(text);\n\n    const response = {\n      status: 200,\n      ok: true,\n      statusText: 'OK',\n      type: 'cors',\n      url: urlObj.toString(),\n      redirected: false,\n      json: async () => suggestions,\n      text: async () => JSON.stringify(suggestions),\n    };\n    return Promise.resolve(response);\n  };\n\n  // Reset spies before importing the JS.\n  resetSpies();\n\n  delete require.cache[require.resolve('./program.js')];\n  require('./program.js');\n\n  input = document.getElementById('typeahead');\n  suggestionsList = document.getElementById('suggestions-list');\n};\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\nconst triggerTypeEvents = (char = null) => {\n  input.dispatchEvent(\n    new window.InputEvent('input', {\n      inputType: char != null ? 'insertText' : 'deleteContentBackward',\n      data: char,\n    }),\n  );\n  input.dispatchEvent(new window.Event('change'));\n\n  if (char != null) {\n    const options = {\n      key: char,\n      charCode: 0, // Only set on keypress\n\n      // keycode and which are set to uppercase for keydown/keyup events\n      keyCode: char.toUpperCase().charCodeAt(0),\n      which: char.toUpperCase().charCodeAt(0),\n      code: `Key${char.toUpperCase()}`,\n    };\n\n    input.dispatchEvent(new window.KeyboardEvent('keydown', options));\n    input.dispatchEvent(\n      new window.KeyboardEvent('keypress', {\n        ...options,\n        charCode: char.charCodeAt(0),\n        keyCode: char.charCodeAt(0),\n        which: char.charCodeAt(0),\n      }),\n    );\n    input.dispatchEvent(new window.KeyboardEvent('keyup', options));\n  }\n};\n\nconst typeCharacter = char => {\n  input.value += char;\n  triggerTypeEvents();\n};\n\nconst clearInput = () => {\n  input.value = '';\n  triggerTypeEvents();\n};\n\nconst triggerAsyncBehavior = async () => {\n  clock.runAllAsync();\n\n  // Flush async browser behavior.\n  await new Promise(setImmediate);\n};\n\nconst expectSuggestions = expected => {\n  const actual = Array.from(suggestionsList.children).map(li => li.textContent);\n  expect(actual).to.deep.equal(expected);\n};\n\ndescribe('typeahead', () => {\n  beforeEach(() => {\n    resetDom();\n    clock.reset();\n  });\n\n  describe('without typing in input', () => {\n    it('suggestions list is empty', () => {\n      expect(suggestionsList.children.length).to.equal(0);\n    });\n  });\n\n  describe('typing in input', () => {\n    it('does not make an API request before stopping for 500ms', async () => {\n      typeCharacter('a');\n      await triggerAsyncBehavior();\n      expect(global.fetch).to.have.been.called.exactly(0);\n\n      clock.tick(500);\n      await triggerAsyncBehavior();\n      expect(global.fetch).to.have.been.called.exactly(1);\n    });\n\n    it('does not populate suggestions list initially', async () => {\n      typeCharacter('a');\n      await triggerAsyncBehavior();\n      expectSuggestions([]);\n    });\n\n    it('populates suggestions list on first type after 500ms', async () => {\n      typeCharacter('a');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n\n      expectSuggestions([\n        'Absolute Unit',\n        'Accessibility',\n        'Accessibility Tree',\n        'Animations',\n        'Array',\n        'Arrow Function',\n        'async function',\n        'Atomic CSS',\n        'Attribute',\n        'await',\n      ]);\n    });\n\n    it('populates suggestions list using last typed input after 500ms', async () => {\n      typeCharacter('l');\n      clock.tick(499);\n      await triggerAsyncBehavior();\n      expectSuggestions([]);\n\n      typeCharacter('e');\n      clock.tick(499);\n      await triggerAsyncBehavior();\n      expectSuggestions([]);\n\n      typeCharacter('x');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n      expectSuggestions(['Lexical Environment', 'Lexical Scoping']);\n    });\n\n    it('updates suggestions list on subsequent 500ms pauses', async () => {\n      expect(global.fetch).to.have.been.called.exactly(0);\n\n      typeCharacter('a');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n      expect(global.fetch).to.have.been.called.exactly(1);\n\n      typeCharacter('r');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n      expectSuggestions(['Array', 'Arrow Function']);\n      expect(global.fetch).to.have.been.called.exactly(2);\n\n      typeCharacter('r');\n      clock.tick(499);\n      await triggerAsyncBehavior();\n      expectSuggestions(['Array', 'Arrow Function']);\n      expect(global.fetch).to.have.been.called.exactly(2);\n\n      typeCharacter('a');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n      expectSuggestions(['Array']);\n      expect(global.fetch).to.have.been.called.exactly(3);\n    });\n\n    it('does not make an API request if continuously typing', async () => {\n      typeCharacter('a');\n      clock.tick(499);\n      await triggerAsyncBehavior();\n      typeCharacter('b');\n      clock.tick(499);\n      await triggerAsyncBehavior();\n      typeCharacter('c');\n      clock.tick(499);\n      await triggerAsyncBehavior();\n      expectSuggestions([]);\n      expect(global.fetch).to.have.been.called.exactly(0);\n    });\n  });\n\n  describe('suggestions', () => {\n    it('use correct elements', async () => {\n      typeCharacter('a');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n\n      Array.from(suggestionsList).forEach(suggestion => {\n        expect(suggestion.tagName).to.equal('LI');\n        expect(suggestion.children.length).to.equal(0);\n      });\n    });\n\n    it('fill in input on click', async () => {\n      typeCharacter('a');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n\n      const suggestion = suggestionsList.children[0];\n      suggestion.click();\n      expect(input.value).to.equal('Absolute Unit');\n    });\n\n    it('clear suggestions list on click', async () => {\n      typeCharacter('a');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n\n      const suggestion = suggestionsList.children[0];\n      suggestion.click();\n      expect(suggestionsList.children.length).to.equal(0);\n    });\n  });\n\n  describe('clearing input', () => {\n    it('clears suggestions list immediately', async () => {\n      typeCharacter('a');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n      clearInput();\n      expectSuggestions([]);\n    });\n\n    it('does not make an API request', async () => {\n      typeCharacter('a');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n      clearInput();\n      expect(global.fetch).to.have.been.called.exactly(1);\n    });\n\n    it('does not prevent future requests', async () => {\n      typeCharacter('a');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n      clearInput();\n\n      typeCharacter('b');\n      clock.tick(500);\n      await triggerAsyncBehavior();\n      expectSuggestions([\n        'BEM',\n        'Block Element',\n        'Block Scope',\n        'border',\n        'Box Model',\n        'box-sizing',\n      ]);\n    });\n  });\n});\n"
        },
        "testStrategy": "MOCHA",
        "uid": "typeahead",
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 0,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "657675532"
        }
    },
    "difficulty": null,
    "instructor": "Conner Ardman",
    "name": "Typeahead",
    "releaseDate": "2021-12-18T00:00:00Z",
    "type": "CODING_FRONTEND",
    "uid": "typeahead"
}