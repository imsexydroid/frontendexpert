{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "JavaScript",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "assessmentSummary": null,
        "category": "JavaScript",
        "changelog": [],
        "customInputVars": [],
        "difficulty": 0,
        "hints": [
            "<p>It can be helpful to define the return value of <span>expect</span> using a class, with the actual value as an argument to the constructor.</p>\n",
            "\n<p>The <span>typeof</span> operator can be used to get the type of a value. For example, <span>typeof 10</span> would return the string <span>number</span>.</p>\n",
            "\n<p>A <span>try/catch</span> statement can be used to catch errors and instead print out their messages.</p>"
        ],
        "isLongOutput": false,
        "isSlowExecution": false,
        "jsonTests": [],
        "languagesSupported": [
            "javascript"
        ],
        "name": "Testing Framework",
        "notes": "",
        "prompt": "<div class=\"html\">\n  <p>\n    Implement the following three functions of a basic JavaScript testing\n    framework:\n  </p>\n  <ol>\n    <li>\n      <p>\n        <span>describe</span>\n      </p>\n      <p style=\"margin: 0 0 10px 0\">\n        This function defines a test suite of related test cases. It takes in a\n        string <span>testSuiteName</span> and a callback <span>func</span>,\n        which makes one or more calls to <span>it</span>.\n      </p>\n    </li>\n    <li>\n      <p>\n        <span>it</span>\n      </p>\n      <p style=\"margin: 0 0 10px 0\">\n        This function defines a single test case in a test suite and is called\n        within a <span>describe</span>'s callback <span>func</span>. It takes in\n        a string <span>testCaseName</span> and its own callback\n        <span>func</span>, which makes one or more calls to <span>expect</span>.\n      </p>\n    </li>\n    <li>\n      <p>\n        <span>expect</span>\n      </p>\n      <p style=\"margin: 0 0 10px 0\">\n        This function defines a single check in a test case and is called within\n        an <span>it</span>'s callback <span>func</span>. It takes in an\n        arbitrary parameter <span>actual</span> and returns an object with the\n        following three functions that are used to compare\n        <span>actual</span> to other values:\n      </p>\n      <ol>\n        <li>\n          <p>\n            <span>expect(actual).toExist()</span>\n          </p>\n          <p style=\"margin: 0 0 10px 0\">\n            This function checks that <span>actual</span> is neither\n            <span>null</span> nor <span>undefined</span>.\n          </p>\n        </li>\n        <li>\n          <p>\n            <span>expect(actual).toBe(expected)</span>\n          </p>\n          <p style=\"margin: 0 0 10px 0\">\n            This function checks that <span>actual</span> is\n            <b><i>strictly</i></b> equal to <span>expected</span>.\n          </p>\n        </li>\n        <li>\n          <p>\n            <span>expect(actual).toBeType(type)</span>\n          </p>\n          <p style=\"margin: 0 0 10px 0\">\n            This function checks that <span>actual</span> is of the type\n            <span>type</span>, which can be any string returned by the\n            <span>typeof</span> operator.\n          </p>\n        </li>\n      </ol>\n    </li>\n  </ol>\n  <p style=\"margin: 0 0 10px 0\">\n    As a test suite and its test cases are executed, they should print the\n    following strings:\n  </p>\n  <pre>\n<span class=\"CodeEditor-promptComment\">// When a test suite begins:</span>\n<span class=\"CodeEditor-promptString CodeEditor-selectable\">\"beginning test suite {testSuiteName}\"</span>\n\n<span class=\"CodeEditor-promptComment\">// When a test suite successfully completes:</span>\n<span class=\"CodeEditor-promptString CodeEditor-selectable\">\"successfully completed test suite {testSuiteName}\"</span>\n\n<span class=\"CodeEditor-promptComment\">// When a test case begins:</span>\n<span class=\"CodeEditor-promptString CodeEditor-selectable\">\"beginning test case {testCaseName}\"</span>\n\n<span class=\"CodeEditor-promptComment\">// When a test case successfully completes:</span>\n<span class=\"CodeEditor-promptString CodeEditor-selectable\">\"successfully completed test case {testCaseName}\"</span>\n\n<span class=\"CodeEditor-promptComment\">// When a test suite fails (because a check in one of its test cases fails):</span>\n<span class=\"CodeEditor-promptString CodeEditor-selectable\">\"failed running test suite {testSuiteName} on test case {testCaseName} with error message {errorMessage}\"</span>\n\n<span class=\"CodeEditor-promptComment\">// When `expect(actual).toExist()` fails, `errorMessage` should be:</span>\n<span class=\"CodeEditor-promptString CodeEditor-selectable\">\"expected value to exist but got {actual}\"</span>\n\n<span class=\"CodeEditor-promptComment\">// When `expect(actual).toBe(expected)` fails, `errorMessage` should be:</span>\n<span class=\"CodeEditor-promptString CodeEditor-selectable\">\"expected {actual} to be {expected}\"</span>\n\n<span class=\"CodeEditor-promptComment\">// When `expect(actual).toBeType(type)` fails, `errorMessage` should be:</span>\n<span class=\"CodeEditor-promptString CodeEditor-selectable\">\"expected {actual} to be of type {type} but got {typeOfActual}\"</span>\n</pre>\n  <p>When a check fails, the following things should happen:</p>\n  <ol>\n    <li>\n      The relevant <span>expect</span> function should throw the appropriate\n      <span>errorMessage</span>.\n    </li>\n    <li>\n      The relevant <span>it</span> function should throw an arbitrary error, and\n      its execution should stop.\n    </li>\n    <li>\n      The relevant <span>describe</span> function should print the failure\n      string with <span>console.error</span> (all other strings should be\n      printed with <span>console.log</span>), and its execution should stop.\n    </li>\n  </ol>\n  <p>For the sake of simplicity:</p>\n  <ul>\n    <li>\n      All output strings should be in lowercase letters, with no punctuation\n      whatsoever.\n    </li>\n    <li>\n      No modifications should be made to <span>testSuiteName</span> and\n      <span>testCaseName</span> values (they shouldn't be lowercased).\n    </li>\n    <li>\n      When <span>actual</span> and <span>expected</span> values are printed\n      within error messages, they should be stringified with\n      <span>JSON.stringify()</span>.\n    </li>\n  </ul>\n  <p>\n    Note that this question's tests naturally check that\n    <span>console.log</span> and <span>console.error</span> are correctly\n    called; this means that debugging your solution with\n    <span>console.log</span> will unavoidably make your solution fail some\n    tests.\n  </p>\n  <h3>Sample Usage #1</h3>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -10px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">describe('Passing Test Suite', () => {\n  it('Passing Test Case #1', () => {\n    expect('foo').toExist();\n    expect(1 + 1).toBe(2);\n  });\n  \n  it('Passing Test Case #2', () => {\n    expect({}).toBeType('object');\n  });\n});</code></pre>\n</div>\n<div class=\"html\">\n  <h3>Sample Output #1</h3>\n  <pre>\n<span class=\"CodeEditor-promptComment\">// Console logs:</span>\nbeginning test suite Passing Test Suite\nbeginning test case Passing Test Case #1\nsuccessfully completed test case Passing Test Case #1\nbeginning test case Passing Test Case #2\nsuccessfully completed test case Passing Test Case #2\nsuccessfully completed test suite Passing Test Suite\n</pre>\n  <h3>Sample Usage #2</h3>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -10px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">describe('Failing Test Suite', () => {\n  it('Passing Test Case', () => {\n    expect(0).toBe(0);\n  });\n\n  it('Failing Test Case', () => {\n    expect(true).toBe(true);\n    expect(true).toBe(false);\n  });\n\n  it('Unreachable Test Case', () => {\n    expect('foo').toBe('bar');\n  });\n});</code></pre>\n</div>\n<div class=\"html\">\n  <h3>Sample Output #2</h3>\n  <pre>\n<span class=\"CodeEditor-promptComment\">// Console logs:</span>\nbeginning test suite Failing Test Suite\nbeginning test case Passing Test Case\nsuccessfully completed test case Passing Test Case\nbeginning test case Failing Test Case\n<span class=\"CodeEditor-promptComment\">// Console errors:</span>\nfailed running test suite Failing Test Suite on test case Failing Test Case with error message expected true to be false\n</pre>\n</div>",
        "releaseDate": "2021-05-24T00:00:00Z",
        "resources": {
            "javascript": {
                "language": "javascript",
                "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\nconst chai = require('chai');\nconst spies = require('chai-spies');\n\nchai.use(spies);\nconst {expect, spy} = chai;\n\nconst {describe: programDescribe, it: programIt, expect: programExpect} = require('./program.js');\n\nconst resetSpies = () => {\n  spy.restore();\n  spy.on(console, 'log');\n  spy.on(console, 'error');\n};\n\ndescribe('testing framework', () => {\n  describe('expect', () => {\n    describe('toBe', () => {\n      it('non-equal values throw errors', () => {\n        expect(() => {\n          programExpect(1).toBe(2);\n        }).to.throw('expected 1 to be 2');\n      });\n    });\n  });\n\n  describe('it', () => {\n    beforeEach(() => {\n      resetSpies();\n    });\n\n    describe('passing test case', () => {\n      const runPassingTestCase = () => {\n        programIt('Passing Test Case', () => {\n          programExpect(1).toBe(1);\n        });\n      };\n\n      it('logs the correct success text', () => {\n        runPassingTestCase();\n\n        expect(console.log).to.have.been.called.exactly(2);\n        expect(console.log).on.nth(1).to.be.called.with('beginning test case Passing Test Case');\n        expect(console.log)\n          .on.nth(2)\n          .to.be.called.with('successfully completed test case Passing Test Case');\n      });\n    });\n  });\n});\n",
                "solutions": [
                    "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nfunction describe(testSuiteName, func) {\n  console.log(`beginning test suite ${testSuiteName}`);\n\n  try {\n    func();\n    console.log(`successfully completed test suite ${testSuiteName}`);\n  } catch (error) {\n    const {testCaseName, errorMessage} = error;\n    console.error(\n      `failed running test suite ${testSuiteName} on ` +\n        `test case ${testCaseName} with error message ${errorMessage}`,\n    );\n  }\n}\n\nfunction it(testCaseName, func) {\n  console.log(`beginning test case ${testCaseName}`);\n\n  try {\n    func();\n    console.log(`successfully completed test case ${testCaseName}`);\n  } catch (errorMessage) {\n    throw {testCaseName, errorMessage};\n  }\n}\n\nfunction expect(actual) {\n  return new ExpectFunctions(actual);\n}\n\nclass ExpectFunctions {\n  constructor(actual) {\n    this.actual = actual;\n    this.stringifiedActual = JSON.stringify(actual);\n  }\n\n  toExist() {\n    if (this.actual == null) {\n      throw `expected value to exist but got ${this.stringifiedActual}`;\n    }\n  }\n\n  toBe(expected) {\n    if (this.actual !== expected) {\n      throw `expected ${this.stringifiedActual} to be ${JSON.stringify(\n        expected,\n      )}`;\n    }\n  }\n\n  toBeType(type) {\n    if (typeof this.actual !== type) {\n      throw `expected ${\n        this.stringifiedActual\n      } to be of type ${type} but got ${typeof this.actual}`;\n    }\n  }\n}\n\nexports.describe = describe;\nexports.it = it;\nexports.expect = expect;\n"
                ],
                "solutionsDisabled": false,
                "startingCode": "function describe(testSuiteName, func) {\n  // Write your code here.\n}\n\nfunction it(testCaseName, func) {\n  // Write your code here.\n}\n\nfunction expect(actual) {\n  // Write your code here.\n}\n\n// Do not edit the lines below.\nexports.describe = describe;\nexports.it = it;\nexports.expect = expect;\n",
                "unitTests": "const chai = require('chai');\nconst spies = require('chai-spies');\n\nchai.use(spies);\nconst {expect, spy} = chai;\n\nconst {describe: programDescribe, it: programIt, expect: programExpect} = require('./program.js');\n\nconst resetSpies = () => {\n  spy.restore();\n  spy.on(console, 'log');\n  spy.on(console, 'error');\n};\n\ndescribe('testing framework', () => {\n  describe('expect', () => {\n    describe('toExist', () => {\n      it('null and undefined throw errors', () => {\n        expect(() => {\n          programExpect(null).toExist();\n        }).to.throw('expected value to exist but got null');\n        expect(() => {\n          programExpect(undefined).toExist();\n        }).to.throw('expected value to exist but got undefined');\n      });\n\n      it(`non-null and non-undefined values don't throw errors`, () => {\n        const values = [1, 'foo', false, [], {}, () => {}];\n\n        for (const value of values) {\n          expect(() => {\n            programExpect(value).toExist();\n          }).not.to.throw();\n        }\n      });\n    });\n\n    describe('toBe', () => {\n      it('non-equal values throw errors', () => {\n        expect(() => {\n          programExpect(1).toBe(2);\n        }).to.throw('expected 1 to be 2');\n        expect(() => {\n          programExpect('foo').toBe('bar');\n        }).to.throw('expected \"foo\" to be \"bar\"');\n        expect(() => {\n          programExpect(false).toBe(true);\n        }).to.throw('expected false to be true');\n        expect(() => {\n          programExpect('1').toBe(1);\n        }).to.throw('expected \"1\" to be 1');\n      });\n\n      it('non-deep-equal values throw errors', () => {\n        expect(() => {\n          programExpect([]).toBe([]);\n        }).to.throw('expected [] to be []');\n        expect(() => {\n          programExpect({}).toBe({});\n        }).to.throw('expected {} to be {}');\n      });\n\n      it(`equal values don't throw errors`, () => {\n        const values = [1, 'foo', false, [], {}, () => {}, null, undefined];\n\n        for (const value of values) {\n          expect(() => {\n            programExpect(value).toBe(value);\n          }).not.to.throw();\n        }\n      });\n    });\n\n    describe('toBeType', () => {\n      it('different-type values throw errors', () => {\n        expect(() => {\n          programExpect(1).toBeType('boolean');\n        }).to.throw('expected 1 to be of type boolean but got number');\n        expect(() => {\n          programExpect(false).toBeType('string');\n        }).to.throw('expected false to be of type string but got boolean');\n        expect(() => {\n          programExpect('foo').toBeType('number');\n        }).to.throw('expected \"foo\" to be of type number but got string');\n      });\n\n      it(`same-type values don't throw errors`, () => {\n        expect(() => {\n          programExpect(1).toBeType('number');\n        }).not.to.throw();\n        expect(() => {\n          programExpect('foo').toBeType('string');\n        }).not.to.throw();\n        expect(() => {\n          programExpect(false).toBeType('boolean');\n        }).not.to.throw();\n        expect(() => {\n          programExpect([]).toBeType('object');\n        }).not.to.throw();\n        expect(() => {\n          programExpect({}).toBeType('object');\n        }).not.to.throw();\n        expect(() => {\n          programExpect(() => {}).toBeType('function');\n        }).not.to.throw();\n        expect(() => {\n          programExpect(null).toBeType('object');\n        }).not.to.throw();\n        expect(() => {\n          programExpect(undefined).toBeType('undefined');\n        }).not.to.throw();\n      });\n    });\n  });\n\n  describe('it', () => {\n    beforeEach(() => {\n      resetSpies();\n    });\n\n    describe('passing test case', () => {\n      const runPassingTestCase = () => {\n        programIt('Passing Test Case', () => {\n          programExpect(1).toBe(1);\n        });\n      };\n\n      it('logs the correct success text', () => {\n        runPassingTestCase();\n\n        expect(console.log).to.have.been.called.exactly(2);\n        expect(console.log).on.nth(1).to.be.called.with('beginning test case Passing Test Case');\n        expect(console.log)\n          .on.nth(2)\n          .to.be.called.with('successfully completed test case Passing Test Case');\n      });\n\n      it(`doesn't throw an error`, () => {\n        expect(runPassingTestCase).not.to.throw();\n      });\n    });\n\n    describe('failing test case', () => {\n      const runFailingTestCase = () => {\n        programIt('Failing Test Case', () => {\n          programExpect(1).toBe(2);\n        });\n      };\n\n      it('logs the correct success text', () => {\n        try {\n          runFailingTestCase();\n        } catch {}\n\n        expect(console.log).to.have.been.called.exactly(1);\n        expect(console.log).on.nth(1).to.be.called.with('beginning test case Failing Test Case');\n      });\n\n      it('throws an error', () => {\n        expect(runFailingTestCase).to.throw();\n      });\n    });\n  });\n\n  describe('describe', () => {\n    beforeEach(() => {\n      resetSpies();\n    });\n\n    describe('passing test suite', () => {\n      beforeEach(() => {\n        programDescribe('Passing Test Suite', () => {\n          programIt('Passing Test Case #1', () => {\n            programExpect(1).toBe(1);\n          });\n\n          programIt('Passing Test Case #2', () => {\n            programExpect(true).toExist();\n          });\n\n          programIt('Passing Test Case #3', () => {\n            programExpect({}).toBeType('object');\n          });\n        });\n      });\n\n      it('logs the correct success text', () => {\n        expect(console.log).to.have.been.called.exactly(8);\n        expect(console.log).on.nth(1).to.be.called.with('beginning test suite Passing Test Suite');\n        expect(console.log).on.nth(2).to.be.called.with('beginning test case Passing Test Case #1');\n        expect(console.log)\n          .on.nth(3)\n          .to.be.called.with('successfully completed test case Passing Test Case #1');\n        expect(console.log).on.nth(4).to.be.called.with('beginning test case Passing Test Case #2');\n        expect(console.log)\n          .on.nth(5)\n          .to.be.called.with('successfully completed test case Passing Test Case #2');\n        expect(console.log).on.nth(6).to.be.called.with('beginning test case Passing Test Case #3');\n        expect(console.log)\n          .on.nth(7)\n          .to.be.called.with('successfully completed test case Passing Test Case #3');\n        expect(console.log)\n          .on.nth(8)\n          .to.be.called.with('successfully completed test suite Passing Test Suite');\n      });\n\n      it(`doesn't log any error text`, () => {\n        expect(console.error).to.not.have.been.called();\n      });\n    });\n\n    describe('failing test suite', () => {\n      beforeEach(() => {\n        programDescribe('Failing Test Suite', () => {\n          programIt('Passing Test Case', () => {\n            programExpect(1).toBe(1);\n          });\n\n          programIt('Failing Test Case', () => {\n            programExpect(null).toExist();\n          });\n\n          programIt('Unreachable Test Case', () => {\n            programExpect({}).toBeType('object');\n          });\n        });\n      });\n\n      it('logs the correct success text', () => {\n        expect(console.log).to.have.been.called.exactly(4);\n        expect(console.log).on.nth(1).to.be.called.with('beginning test suite Failing Test Suite');\n        expect(console.log).on.nth(2).to.be.called.with('beginning test case Passing Test Case');\n        expect(console.log)\n          .on.nth(3)\n          .to.be.called.with('successfully completed test case Passing Test Case');\n        expect(console.log).on.nth(4).to.be.called.with('beginning test case Failing Test Case');\n      });\n\n      it('logs the correct error text', () => {\n        expect(console.error).to.have.been.called.exactly(1);\n        expect(console.error)\n          .on.nth(1)\n          .to.be.called.with(\n            'failed running test suite Failing Test Suite ' +\n              'on test case Failing Test Case ' +\n              'with error message expected value to exist but got null',\n          );\n      });\n    });\n  });\n});\n"
            }
        },
        "spaceTime": "",
        "submissionStatistics": {
            "correctCount": 2228,
            "failureCount": 2948
        },
        "testStrategy": "SANDBOX_ONLY",
        "tests": [],
        "uid": "testing-framework",
        "version": 0,
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 14,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "644590869"
        },
        "visualization": {
            "inputType": null,
            "outputType": null
        }
    },
    "difficulty": 0,
    "instructor": "Conner Ardman",
    "name": "Testing Framework",
    "releaseDate": "2021-05-24T00:00:00Z",
    "type": "CODING_STANDARD",
    "uid": "testing-framework"
}