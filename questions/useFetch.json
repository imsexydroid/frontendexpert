{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "React Hooks",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "assessmentSummary": null,
        "category": "React Hooks",
        "changelog": [],
        "customInputVars": [],
        "difficulty": 0,
        "hints": [
            "<p>\n  A try/catch block can be used to catch errors caused by <span>fetch</span>\n  and to update the error state.\n</p>\n",
            "\n<p>\n  In order to avoid state updates on unmounted components, try using a boolean\n  flag along with <span>useEffect</span> to keep track of if the component is\n  still mounted.\n</p>\n",
            "\n<p>\n  The <span>useEffect</span> hook cannot take an async function as a parameter,\n  because this changes the return value from a function to a Promise, causing\n  the cleanup function to never run. If you need asynchronous behavior, the\n  async function will need to be defined inside of the <span>useEffect</span>\n  callback then immediately invoked.\n</p>"
        ],
        "isLongOutput": false,
        "isSlowExecution": false,
        "jsonTests": [],
        "languagesSupported": [
            "jsx"
        ],
        "name": "useFetch",
        "notes": "<div class=\"html\">\n  <p>\n    The video explanation states that the <span>shouldCancel</span> boolean\n    flag is necessary to avoid setting state on unmounted components. However,\n    <a\n      class=\"Link Link--fe\"\n      href=\"https://github.com/facebook/react/pull/22114\"\n      target=\"_blank\"\n      >this is no longer considered to be a major concern</a\n    >. That said, this boolean flag is still necessary to prevent race condtions\n    if the <span>url</span> changes before a previous fetch request had returned.\n  </p>\n</div>",
        "prompt": "<div class=\"html\">\n  <p>\n    Write a <span>useFetch</span> custom hook that takes in a required\n    <span>url</span> as a string or URL object. This parameter should be directly\n    passed to the native JavaScript\n    <a\n      class=\"Link Link--fe\"\n      href=\"https://developer.mozilla.org/en-US/docs/Web/API/fetch\"\n      target=\"_blank\"\n      >fetch</a\n    > function.\n  </p>\n  <p>\n    Calling <span>useFetch</span> in a component should make a fetch request\n    when an instance of the component is mounted. Additionally, a new request\n    should be issued on any render where the <span>url</span> has changed.\n  </p>\n\n  <p>\n    The <span>useFetch</span> function should return an object with three keys:\n  </p>\n  <ul>\n    <li>\n      <b>responseJSON</b>: The JSON response from the most recent call to\n      <span>fetch</span>. If no response has been received yet or the most\n      recent request resulted in an error, this should be null.\n    </li>\n    <li>\n      <b>isLoading</b>: When a fetch request is issued, this should be set to\n      <span>true</span>, and set to <span>false</span> when the response comes\n      back or an error is thrown.\n    </li>\n    <li>\n      <b>error</b>: If the most recent call to <span>fetch</span> threw an\n      error or retrieving the JSON from the most recent response threw an error,\n      the error should be saved in this value, otherwise it should be null.\n    </li>\n  </ul>\n\n  <p>\n    In the event that the <span>url</span> changes before the previous fetch\n    request returns, the response from that previous request should not be used\n    in order to prevent a race condition.\n  </p>\n  <h3>Sample Usage</h3>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -10px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">function Fetcher() {\n  const { responseJSON, isLoading, error } = useFetch(url);\n  const [url, setUrl] = useState('');\n  return (\n    &lt;&gt;\n      &lt;input value={url} onChange={(e) => setUrl(e.target.value)} /&gt;\n      {\n        error ? &lt;p&gt;Error: {error}&lt;/p&gt; :\n        isLoading ? &lt;p&gt;Loading...&lt;/p&gt; :\n        &lt;p&gt;Response: {responseJSON}&lt;/p&gt;\n      }\n    &lt;/&gt;\n  );\n}</code></pre>\n</div>",
        "releaseDate": "2022-05-24T00:00:00Z",
        "resources": {
            "jsx": {
                "language": "jsx",
                "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nimport React, {useState, StrictMode} from 'react';\nimport ReactDOM from 'react-dom';\nimport {act} from 'react-dom/test-utils';\nconst {JSDOM} = require('jsdom');\nimport {useFetch} from './program';\nconst chai = require('chai');\nconst spies = require('chai-spies');\nchai.use(spies);\nconst {expect, spy} = chai;\nconst FakeTimers = require('@sinonjs/fake-timers');\n\nlet rootContainer;\n\nconst resetSpies = () => {\n  spy.restore();\n  spy.on(global, 'fetch');\n  spy.on(console, 'error');\n};\n\nconst clock = FakeTimers.install({\n  now: Date.now(),\n});\n\nconst resetDom = () => {\n  const dom = new JSDOM({\n    url: 'http://localhost:3000',\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  const convertStringToUrlObj = url => {\n    const [base, params] = url.split('?');\n    const paramPairs = params?.split('&');\n    const urlObj = new URL(base);\n    paramPairs?.forEach(paramStr => {\n      const [key, value] = paramStr.split('=');\n      urlObj.searchParams.set(key, value);\n    });\n    return urlObj;\n  };\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n  global.fetch = async (url, options) => {\n    return new Promise((res, rej) => {\n      const signal = options != null ? options.signal : null;\n      if (url === 'badurl') {\n        rej('Example Error');\n      }\n\n      if (signal != null) {\n        signal.addEventListener('abort', e => {\n          rej(e.target.reason ?? 'AbortError');\n        });\n      }\n\n      const urlObj = typeof url === 'object' ? url : convertStringToUrlObj(url);\n      if (urlObj.origin + urlObj.pathname !== 'https://www.algoexpert.io/') {\n        const responseObj = {error: 'Not Found'};\n        const response = {\n          status: 404,\n          ok: false,\n          statusText: 'Not Found',\n          type: 'cors',\n          url: urlObj.toString(),\n          redirected: false,\n          json: async () => responseObj,\n          text: async () => JSON.stringify(responseObj),\n        };\n       setTimeout(() => res(response), 1000);\n      } else {\n        const responseObj = {message: 'hello world'};\n        const response = {\n          status: 200,\n          ok: true,\n          statusText: 'OK',\n          type: 'cors',\n          url: urlObj.toString(),\n          redirected: false,\n          json: async () => responseObj,\n          text: async () => JSON.stringify(responseObj),\n        };\n       setTimeout(() => res(response), 1000);\n      }\n    });\n  };\n\n  for (const [key, value] of Object.entries(React)) {\n    global[key] = value;\n  }\n\n  // Reset spies before importing the JS.\n  resetSpies();\n\n  delete require.cache[require.resolve('./program.js')];\n  require('./program.js');\n\n  rootContainer = document.createElement('div');\n  document.body.appendChild(rootContainer);\n};\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\nfunction TestComponent({url}) {\n  const {responseJSON, isLoading, error} = useFetch(url);\n  const [bool, setBool] = useState(false);\n  return (\n    <>\n      <button id=\"rerender\" onClick={() => setBool(!bool)}>\n        Re-Render\n      </button>\n      <p id=\"response\">{JSON.stringify(responseJSON)}</p>\n      <p id=\"isLoading\">{JSON.stringify(isLoading)}</p>\n      <p id=\"error\">{JSON.stringify(error)}</p>\n    </>\n  );\n}\n\nfunction waitForRender() {\n  clock.tick(1000);\n  clock.runAllAsync();\n  return new Promise(function (resolve) {\n    setImmediate(resolve);\n  });\n}\n\ndescribe('useFetch', () => {\n  beforeEach(() => {\n    resetDom();\n  });\n\n  it('calls fetch on mount', () => {\n    expect(global.fetch).to.have.been.called.exactly(0);\n    act(() => {\n      ReactDOM.render(<TestComponent url=\"https://www.algoexpert.io\" />, rootContainer);\n    });\n    expect(global.fetch).to.have.been.called.exactly(1);\n  });\n\n  it('does not call fetch on every render', async () => {\n    act(() => {\n      ReactDOM.render(<TestComponent url=\"https://www.algoexpert.io\" />, rootContainer);\n    });\n    act(() => {\n      document.getElementById('rerender').click();\n    });\n    expect(global.fetch).to.have.been.called.exactly(1);\n  });\n\n  it('returns correct responseJSON', async () => {\n    act(() => {\n      ReactDOM.render(<TestComponent url=\"https://www.algoexpert.io\" />, rootContainer);\n    });\n    await waitForRender();\n    expect(document.getElementById('response').textContent).to.equal('{\"message\":\"hello world\"}');\n  });\n});\n",
                "solutions": [
                    "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nimport {useState, useEffect} from 'react';\n\nfunction useFetch(url) {\n  const [responseJSON, setResponseJSON] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let shouldCancel = false;\n\n    const callFetch = async () => {\n      setIsLoading(true);\n\n      try {\n        const response = await fetch(url);\n        const newResponseJSON = await response.json();\n        if (shouldCancel) return;\n        setResponseJSON(newResponseJSON);\n        setError(null);\n      } catch (newError) {\n        if (shouldCancel) return;\n        setError(newError);\n        setResponseJSON(null);\n      }\n\n      setIsLoading(false);\n    };\n\n    callFetch();\n\n    return () => (shouldCancel = true);\n  }, [url]);\n\n  return {\n    responseJSON,\n    isLoading,\n    error,\n  };\n}\n\n// Do not edit the line below.\nexports.useFetch = useFetch;\n",
                    "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nimport {useState, useEffect, useReducer} from 'react';\n\nfunction reducer(state, {type, responseJSON, error}) {\n  switch (type) {\n    case 'loading':\n      return {...state, isLoading: true};\n    case 'success':\n      return {responseJSON, isLoading: false, error: null};\n    case 'error':\n      return {responseJSON: null, isLoading: false, error};\n    default:\n      throw new Error('Unknown action type');\n  }\n}\n\nfunction useFetch(url) {\n  const [state, dispatch] = useReducer(reducer, {\n    responseJSON: null,\n    isLoading: true,\n    error: null,\n  });\n\n  useEffect(() => {\n    let shouldCancel = false;\n\n    const callFetch = async () => {\n      dispatch({type: 'loading'});\n\n      try {\n        const response = await fetch(url);\n        const newResponseJSON = await response.json();\n        if (shouldCancel) return;\n        dispatch({type: 'success', responseJSON: newResponseJSON});\n      } catch (newError) {\n        if (shouldCancel) return;\n        dispatch({type: 'error', error: newError});\n      }\n    };\n\n    callFetch();\n\n    return () => (shouldCancel = true);\n  }, [url]);\n\n  return state;\n}\n\n// Do not edit the line below.\nexports.useFetch = useFetch;\n"
                ],
                "solutionsDisabled": false,
                "startingCode": "function useFetch(url) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.useFetch = useFetch;\n",
                "unitTests": "/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nimport React, {useState, StrictMode} from 'react';\nimport ReactDOM from 'react-dom';\nimport {act} from 'react-dom/test-utils';\nconst {JSDOM} = require('jsdom');\nimport {useFetch} from './program';\nconst chai = require('chai');\nconst spies = require('chai-spies');\nchai.use(spies);\nconst {expect, spy} = chai;\nconst FakeTimers = require('@sinonjs/fake-timers');\n\nlet rootContainer;\n\nconst resetSpies = () => {\n  spy.restore();\n  spy.on(global, 'fetch');\n};\n\nconst clock = FakeTimers.install({\n  now: Date.now(),\n});\n\nconst resetDom = () => {\n  const dom = new JSDOM({\n    url: 'http://localhost:3000',\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  const convertStringToUrlObj = url => {\n    const [base, params] = url.split('?');\n    const paramPairs = params?.split('&');\n    const urlObj = new URL(base);\n    paramPairs?.forEach(paramStr => {\n      const [key, value] = paramStr.split('=');\n      urlObj.searchParams.set(key, value);\n    });\n    return urlObj;\n  };\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n  global.fetch = async (url, options) => {\n    return new Promise((res, rej) => {\n      const signal = options != null ? options.signal : null;\n      if (url === 'badurl') {\n        rej('Example Error');\n      }\n\n      if (signal != null) {\n        signal.addEventListener('abort', e => {\n          rej(e.target.reason ?? 'AbortError');\n        });\n      }\n\n      const urlObj = typeof url === 'object' ? url : convertStringToUrlObj(url);\n      if (urlObj.origin + urlObj.pathname !== 'https://www.algoexpert.io/') {\n        const responseObj = {error: 'Not Found'};\n        const response = {\n          status: 404,\n          ok: false,\n          statusText: 'Not Found',\n          type: 'cors',\n          url: urlObj.toString(),\n          redirected: false,\n          json: async () => responseObj,\n          text: async () => JSON.stringify(responseObj),\n        };\n       setTimeout(() => res(response), 1000);\n      } else {\n        const responseObj = {message: 'hello world'};\n        const response = {\n          status: 200,\n          ok: true,\n          statusText: 'OK',\n          type: 'cors',\n          url: urlObj.toString(),\n          redirected: false,\n          json: async () => responseObj,\n          text: async () => JSON.stringify(responseObj),\n        };\n       setTimeout(() => res(response), 1000);\n      }\n    });\n  };\n\n  for (const [key, value] of Object.entries(React)) {\n    global[key] = value;\n  }\n\n  // Reset spies before importing the JS.\n  resetSpies();\n\n  delete require.cache[require.resolve('./program.js')];\n  require('./program.js');\n\n  rootContainer = document.createElement('div');\n  document.body.appendChild(rootContainer);\n};\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\nfunction TestComponent({url}) {\n  const {responseJSON, isLoading, error} = useFetch(url);\n  const [bool, setBool] = useState(false);\n  return (\n    <>\n      <button id=\"rerender\" onClick={() => setBool(!bool)}>\n        Re-Render\n      </button>\n      <p id=\"response\">{JSON.stringify(responseJSON)}</p>\n      <p id=\"isLoading\">{JSON.stringify(isLoading)}</p>\n      <p id=\"error\">{JSON.stringify(error)}</p>\n    </>\n  );\n}\n\nfunction waitForRender() {\n  clock.tick(1000);\n  clock.runAllAsync();\n  return new Promise(function (resolve) {\n    setImmediate(resolve);\n  });\n}\n\ndescribe('useFetch', () => {\n  beforeEach(() => {\n    resetDom();\n  });\n\n  it('calls fetch on mount', () => {\n    expect(global.fetch).to.have.been.called.exactly(0);\n    act(() => {\n      ReactDOM.render(<TestComponent url=\"https://www.algoexpert.io\" />, rootContainer);\n    });\n    expect(global.fetch).to.have.been.called.exactly(1);\n  });\n\n  it('does not call fetch on every render', async () => {\n    act(() => {\n      ReactDOM.render(<TestComponent url=\"https://www.algoexpert.io\" />, rootContainer);\n    });\n    act(() => {\n      document.getElementById('rerender').click();\n    });\n    expect(global.fetch).to.have.been.called.exactly(1);\n  });\n\n  it('returns correct responseJSON', async () => {\n    act(() => {\n      ReactDOM.render(<TestComponent url=\"https://www.algoexpert.io\" />, rootContainer);\n    });\n    await waitForRender();\n    expect(document.getElementById('response').textContent).to.equal('{\"message\":\"hello world\"}');\n  });\n\n  it('accepts fetch with url object', async () => {\n    const url = new URL('https://www.algoexpert.io');\n    act(() => {\n      ReactDOM.render(<TestComponent url={url} />, rootContainer);\n    });\n    expect(global.fetch).to.have.been.called.exactly(1);\n    await waitForRender();\n    expect(document.getElementById('response').textContent).to.equal('{\"message\":\"hello world\"}');\n  });\n\n  it('fetch url can be changed', async () => {\n    const WrapperComponent = () => {\n      const [url, setUrl] = useState('https://www.frontendexpert.io');\n\n      return (\n        <>\n          <button id=\"changeUrl\" onClick={() => setUrl('https://www.algoexpert.io')}>\n            Change URL\n          </button>\n          <TestComponent url={url} />\n        </>\n      );\n    };\n    act(() => {\n      ReactDOM.render(<WrapperComponent />, rootContainer);\n    });\n\n    expect(global.fetch).to.have.been.called.with('https://www.frontendexpert.io');\n    act(() => {\n      document.getElementById('changeUrl').click();\n    });\n    expect(global.fetch).to.have.been.called.with('https://www.algoexpert.io');\n  });\n\n  it('returns correct responseJSON on 404', async () => {\n    act(() => {\n      ReactDOM.render(<TestComponent url=\"https://www.frontendexpert.io\" />, rootContainer);\n    });\n    await waitForRender();\n    expect(document.getElementById('response').textContent).to.equal('{\"error\":\"Not Found\"}');\n  });\n\n  it('returns correct isLoading', async () => {\n    act(() => {\n      ReactDOM.render(<TestComponent url=\"https://www.algoexpert.io\" />, rootContainer);\n    });\n    expect(document.getElementById('isLoading').textContent).to.equal('true');\n    await waitForRender();\n    expect(document.getElementById('isLoading').textContent).to.equal('false');\n  });\n\n  it('returns correct isLoading after changing url', async () => {\n    const WrapperComponent = () => {\n      const [url, setUrl] = useState('https://www.frontendexpert.io');\n\n      return (\n        <>\n          <button id=\"changeUrl\" onClick={() => setUrl('https://www.algoexpert.io')}>\n            Change URL\n          </button>\n          <TestComponent url={url} />\n        </>\n      );\n    };\n    act(() => {\n      ReactDOM.render(<WrapperComponent />, rootContainer);\n    });\n\n    expect(document.getElementById('isLoading').textContent).to.equal('true');\n    await waitForRender();\n    expect(document.getElementById('isLoading').textContent).to.equal('false');\n\n    act(() => {\n      document.getElementById('changeUrl').click();\n    });\n\n    expect(document.getElementById('isLoading').textContent).to.equal('true');\n    await waitForRender();\n    expect(document.getElementById('isLoading').textContent).to.equal('false');\n  });\n\n  it('returns null error on success', async () => {\n    act(() => {\n      ReactDOM.render(<TestComponent url=\"https://www.algoexpert.io\" />, rootContainer);\n    });\n    expect(document.getElementById('error').textContent).to.equal('null');\n    await waitForRender();\n    expect(document.getElementById('error').textContent).to.equal('null');\n  });\n\n  it('returns correct error on error', async () => {\n    act(() => {\n      ReactDOM.render(<TestComponent url=\"badurl\" />, rootContainer);\n    });\n    await waitForRender();\n    expect(document.getElementById('error').textContent).to.equal('\"Example Error\"');\n  });\n\n  it('returns null error on 404', async () => {\n    act(() => {\n      ReactDOM.render(<TestComponent url=\"https://www.frontendexpert.io\" />, rootContainer);\n    });\n    await waitForRender();\n    expect(document.getElementById('error').textContent).to.equal('null');\n  });\n\n  it('Correctly handles race conditions if the url changes quickly', async () => {\n    const savedFetch = global.fetch;\n    global.fetch = async (...params) => {\n      await new Promise(res => setTimeout(res), 1000);\n      return savedFetch(...params);\n    };\n\n    const WrapperComponent = () => {\n      const [url, setURL] = useState('https://www.frontendexpert.io');\n\n      return (\n        <>\n          <button id=\"toggle\" onClick={() => setURL('https://www.algoexpert.io')}>\n            Change URL\n          </button>\n          <TestComponent url={url} />\n        </>\n      );\n    };\n\n    act(() => {\n      ReactDOM.render(<WrapperComponent />, rootContainer);\n    });\n\n    await waitForRender();\n    global.fetch = savedFetch;\n\n    act(() => {\n      document.getElementById('toggle').click();\n    });\n\n    await waitForRender();\n    expect(document.getElementById('response').textContent).to.equal('{\"message\":\"hello world\"}');\n  });\n});\n"
            }
        },
        "spaceTime": "",
        "submissionStatistics": {
            "correctCount": 1666,
            "failureCount": 844
        },
        "testStrategy": "SANDBOX_ONLY",
        "tests": [],
        "uid": "useFetch",
        "version": 0,
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 0,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "708466539"
        },
        "visualization": {
            "inputType": null,
            "outputType": null
        }
    },
    "difficulty": 0,
    "instructor": "Conner Ardman",
    "name": "useFetch",
    "releaseDate": "2022-05-24T00:00:00Z",
    "type": "CODING_STANDARD",
    "uid": "useFetch"
}