{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "JavaScript",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "assessmentSummary": null,
        "category": "JavaScript",
        "changelog": [],
        "customInputVars": [],
        "difficulty": 0,
        "hints": [
            "<p>\n  The <span>typeof</span> operator can be used to get the type of a value. For\n  example, <span>typeof 5</span> returns \"number\".\n</p>\n",
            "\n<p>\n  Since arrays are objects, <span>typeof []</span> is \"object\", but there is\n  an <span>Array.isArray</span> method to check if a value is an array.\n</p>\n",
            "\n<p>\n  The <span>typeof</span> operator can have some weird behavior. For example,\n  <span>typeof null</span> returns \"object\", and <span>typeof NaN</span>\n  returns number.\n</p>\n",
            "\n<p>\n  <span>NaN == NaN</span> returns <span>false</span>, so this will need to be\n  special cased. You can check if a value is <span>NaN</span> with the\n  <span>Number.isNaN</span> method.\n</p>"
        ],
        "isLongOutput": false,
        "isSlowExecution": false,
        "jsonTests": [],
        "languagesSupported": [
            "javascript"
        ],
        "name": "Deep Equals",
        "notes": "",
        "prompt": "<div class=\"html\">\n  <p>\n    Write a <span>deepEquals</span> function that takes in two required values\n    and returns if those two values are deeply equal to each other.\n  </p>\n  <p>For the purpose of this problem, deep equality is defined as follows:</p>\n  <ul>\n    <li>Values with different types are not equal.</li>\n    <li><span>NaN</span> is only equal to <span>NaN</span>.</li>\n    <li>\n      <span>null</span> is only equal to <span>null</span>, and\n      <span>undefined</span> is only equal to <span>undefined</span>. These\n      values are not equal to each other.\n    </li>\n    <li>\n      Arrays are only equal if their entries are deeply equal to each other.\n    </li>\n    <li>\n      Objects are equal only if their keys and values are deeply equal to each\n      other (note that the order of the keys doesn't matter).\n    </li>\n  </ul>\n  <p>You can make the following assumptions:</p>\n  <ul>\n    <li>\n      Functions will never be passed to <span>deepEquals</span> and will never\n      be contained in objects or arrays passed to <span>deepEquals</span>.\n    </li>\n    <li>\n      Objects will only have string keys, and their values won't be recursive\n      references to themselves.\n    </li>\n    <li>\n      The prototype chain doesn't need to be considered when determining if two\n      objects are deeply equal.\n    </li>\n  </ul>\n  <h3>Sample Usage</h3>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -10px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">deepEquals(1, 1); // true\ndeepEquals(1, '1'); // false\ndeepEquals(null, null); // true\ndeepEquals(null, undefined); // false\ndeepEquals([], []); // true\ndeepEquals({}, {}); // true\ndeepEquals([], {}); // false\ndeepEquals({a: 123, b: {c: [4, 5, 6]}}, {a: 123, b: {c: [4, 5, 6]}}); // true\ndeepEquals({a: 123, b: {c: [4, 5, 6]}}, {b: {c: [4, 5, 6]}}); // false\ndeepEquals({a: 123, b: {c: [4, 5, 6]}}, {a: 123, b: {c: [4, '5', 6]}}); // false\ndeepEquals([1, 2, [3, 4]], [1, 2, [3, 4]]); // true\ndeepEquals([1, 2, [3, 4, {a: 'abc'}]], [1, 2, [3, 4, {a: 'abc'}]]); // true</code></pre>\n</div>",
        "releaseDate": "2022-07-01T00:00:00Z",
        "resources": {
            "javascript": {
                "language": "javascript",
                "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\nconst chai = require('chai');\nconst {expect} = chai;\n\nconst {deepEquals} = require('./program.js');\n\ndescribe('deep equals', () => {\n  describe('values of the same primitive type', () => {\n    it('numbers', () => {\n      expect(deepEquals(1, 1)).to.be.true;\n      expect(deepEquals(15, 15)).to.be.true;\n      expect(deepEquals(0, 1)).to.be.false;\n      expect(deepEquals(1, 0)).to.be.false;\n      expect(deepEquals(1, 10)).to.be.false;\n      expect(deepEquals(10, 1)).to.be.false;\n    });\n\n    it('strings', () => {\n      expect(deepEquals('', '')).to.be.true;\n      expect(deepEquals('a', 'a')).to.be.true;\n      expect(deepEquals('abc', 'abc')).to.be.true;\n      expect(deepEquals('', 'a')).to.be.false;\n      expect(deepEquals('a', '')).to.be.false;\n      expect(deepEquals('a', 'b')).to.be.false;\n      expect(deepEquals('hello', 'world')).to.be.false;\n      expect(deepEquals('ab', 'abc')).to.be.false;\n      expect(deepEquals('abc', 'ab')).to.be.false;\n    });\n  });\n\n  describe('arrays', () => {\n    it('with no values are equal', () => {\n      expect(deepEquals([], [])).to.be.true;\n    });\n\n    it('with the same primitive values are equal', () => {\n      expect(deepEquals([1], [1])).to.be.true;\n      expect(deepEquals([0, 1, 2], [0, 1, 2])).to.be.true;\n      expect(deepEquals([0, 'abc', 2], [0, 'abc', 2])).to.be.true;\n      expect(deepEquals([null, undefined, true], [null, undefined, true])).to.be.true;\n    });\n  });\n\n  describe('objects', () => {\n    it('with no values are equal', () => {\n      expect(deepEquals({}, {})).to.be.true;\n    });\n\n    it('with the same primitive values are equal', () => {\n      expect(deepEquals({a: 123}, {a: 123})).to.be.true;\n      expect(deepEquals({a: '123'}, {a: '123'})).to.be.true;\n      expect(deepEquals({a: 123, b: 'abc'}, {a: 123, b: 'abc'})).to.be.true;\n      expect(deepEquals({a: 123, c: true, b: 'abc'}, {a: 123, b: 'abc', c: true})).to.be.true;\n    });\n  });\n\n  describe('nested objects and arrays', () => {\n    it('multi-dimensional arrays', () => {\n      expect(deepEquals([[1]], [[1]])).to.be.true;\n      expect(deepEquals([[1], [2]], [[1], [2]])).to.be.true;\n      expect(deepEquals([[1, true, 'abc'], [2]], [[1, true, 'abc'], [2]])).to.be.true;\n      expect(deepEquals([[1, [2, 3, [4, 5]]], [2]], [[1, [2, 3, [4, 5]]], [2]])).to.be.true;\n      expect(deepEquals([], [[]])).to.be.false;\n      expect(deepEquals([[]], [])).to.be.false;\n      expect(deepEquals([[1]], [[]])).to.be.false;\n      expect(deepEquals([[]], [[1]])).to.be.false;\n      expect(deepEquals([[1]], [[0]])).to.be.false;\n      expect(deepEquals([[0, []]], [[0]])).to.be.false;\n      expect(deepEquals([[0]], [[0, []]])).to.be.false;\n      expect(deepEquals([[0, [1, 2]]], [[0, [1]]])).to.be.false;\n      expect(deepEquals([[0, [1]]], [[0, [1, 2]]])).to.be.false;\n      expect(deepEquals([[1, true, 'abc'], [2]], [[1, true, 'abc']])).to.be.false;\n      expect(deepEquals([[1, [2, [4, 5]]], [2]], [[1, [2, 3, [4, 5]]], [2]])).to.be.false;\n      expect(deepEquals([[1, [2, '3', [4, 5]]], [2]], [[1, [2, 3, [4, 5]]], [2]])).to.be.false;\n    });\n  });\n});\n",
                "solutions": [
                    "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nfunction deepEquals(valueOne, valueTwo) {\n  if (typeof valueOne !== typeof valueTwo) return false;\n\n  if (typeof valueOne !== 'object') {\n    if (Number.isNaN(valueOne) && Number.isNaN(valueTwo)) return true;\n    return valueOne === valueTwo;\n  }\n\n  if (valueOne === null || valueTwo === null) return valueOne === valueTwo;\n\n  // This handles the case where both values point to the same object.\n  if (valueOne === valueTwo) return true;\n\n  if (Array.isArray(valueOne) && Array.isArray(valueTwo)) {\n    if (valueOne.length !== valueTwo.length) return false;\n    for (let i = 0; i < valueOne.length; i++) {\n      if (!deepEquals(valueOne[i], valueTwo[i])) return false;\n    }\n    return true;\n  }\n\n  if (Array.isArray(valueOne) || Array.isArray(valueTwo)) return false;\n\n  const valueOneKeys = Object.keys(valueOne);\n  const valueTwoKeys = Object.keys(valueTwo);\n  if (valueOneKeys.length !== valueTwoKeys.length) return false;\n  for (const key of valueOneKeys) {\n    if (!valueTwo.hasOwnProperty(key)) return false;\n    if (!deepEquals(valueOne[key], valueTwo[key])) return false;\n  }\n\n  return true;\n}\n\n// Do not edit the line below.\nexports.deepEquals = deepEquals;\n"
                ],
                "solutionsDisabled": false,
                "startingCode": "function deepEquals(valueOne, valueTwo) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.deepEquals = deepEquals;\n",
                "unitTests": "const chai = require('chai');\nconst {expect} = chai;\n\nconst {deepEquals} = require('./program.js');\n\ndescribe('deep equals', () => {\n  describe('values of the same primitive type', () => {\n    it('numbers', () => {\n      expect(deepEquals(1, 1)).to.be.true;\n      expect(deepEquals(15, 15)).to.be.true;\n      expect(deepEquals(0, 1)).to.be.false;\n      expect(deepEquals(1, 0)).to.be.false;\n      expect(deepEquals(1, 10)).to.be.false;\n      expect(deepEquals(10, 1)).to.be.false;\n    });\n\n    it('numbers, including NaN', () => {\n      expect(deepEquals(NaN, NaN)).to.be.true;\n      expect(deepEquals(NaN, 0)).to.be.false;\n      expect(deepEquals(0, NaN)).to.be.false;\n    });\n\n    it('strings', () => {\n      expect(deepEquals('', '')).to.be.true;\n      expect(deepEquals('a', 'a')).to.be.true;\n      expect(deepEquals('abc', 'abc')).to.be.true;\n      expect(deepEquals('', 'a')).to.be.false;\n      expect(deepEquals('a', '')).to.be.false;\n      expect(deepEquals('a', 'b')).to.be.false;\n      expect(deepEquals('hello', 'world')).to.be.false;\n      expect(deepEquals('ab', 'abc')).to.be.false;\n      expect(deepEquals('abc', 'ab')).to.be.false;\n    });\n\n    it('booleans', () => {\n      expect(deepEquals(true, true)).to.be.true;\n      expect(deepEquals(false, false)).to.be.true;\n      expect(deepEquals(true, false)).to.be.false;\n      expect(deepEquals(false, true)).to.be.false;\n    });\n\n    it('null', () => {\n      expect(deepEquals(null, null)).to.be.true;\n    });\n\n    it('undefined', () => {\n      expect(deepEquals(undefined, undefined)).to.be.true;\n    });\n\n    it('bigints', () => {\n      expect(deepEquals(1n, 1n)).to.be.true;\n      expect(deepEquals(15n, 15n)).to.be.true;\n      expect(deepEquals(9007199254740991n, 9007199254740991n)).to.be.true;\n      expect(deepEquals(1n, 15n)).to.be.false;\n      expect(deepEquals(15n, 1n)).to.be.false;\n      expect(deepEquals(9007199254740991n, 9007199254740992n)).to.be.false;\n    });\n\n    it('symbols', () => {\n      const symbol1 = Symbol('1');\n      const symbol2 = Symbol('2');\n      expect(deepEquals(symbol1, symbol1)).to.be.true;\n      expect(deepEquals(symbol2, symbol2)).to.be.true;\n      expect(deepEquals(symbol1, symbol2)).to.be.false;\n      expect(deepEquals(symbol2, symbol1)).to.be.false;\n    });\n  });\n\n  describe('values of different primitive types', () => {\n    it('always returns false', () => {\n      expect(deepEquals(1, '1')).to.be.false;\n      expect(deepEquals('1', 1)).to.be.false;\n      expect(deepEquals(1, 1n)).to.be.false;\n      expect(deepEquals(1n, 1)).to.be.false;\n      expect(deepEquals(1, true)).to.be.false;\n      expect(deepEquals(true, 1)).to.be.false;\n      expect(deepEquals(0, false)).to.be.false;\n      expect(deepEquals(false, 0)).to.be.false;\n      expect(deepEquals(0, '')).to.be.false;\n      expect(deepEquals('', 0)).to.be.false;\n      expect(deepEquals(false, '')).to.be.false;\n      expect(deepEquals('', false)).to.be.false;\n      expect(deepEquals(null, undefined)).to.be.false;\n      expect(deepEquals(undefined, null)).to.be.false;\n      expect(deepEquals(null, true)).to.be.false;\n      expect(deepEquals(true, null)).to.be.false;\n      expect(deepEquals(null, false)).to.be.false;\n      expect(deepEquals(false, null)).to.be.false;\n      expect(deepEquals(null, 0)).to.be.false;\n      expect(deepEquals(0, null)).to.be.false;\n      expect(deepEquals(NaN, 'NaN')).to.be.false;\n      expect(deepEquals('NaN', NaN)).to.be.false;\n      expect(deepEquals(NaN, 0)).to.be.false;\n      expect(deepEquals(0, NaN)).to.be.false;\n      expect(deepEquals(Symbol('0'), 0)).to.be.false;\n      expect(deepEquals(0, Symbol('0'))).to.be.false;\n      expect(deepEquals('0', Symbol('0'))).to.be.false;\n      expect(deepEquals(Symbol('0'), true)).to.be.false;\n      expect(deepEquals(true, Symbol('0'))).to.be.false;\n      expect(deepEquals(Symbol('0'), false)).to.be.false;\n      expect(deepEquals(false, Symbol('0'))).to.be.false;\n    });\n  });\n\n  describe('arrays', () => {\n    it('with no values are equal', () => {\n      expect(deepEquals([], [])).to.be.true;\n    });\n\n    it('with the same primitive values are equal', () => {\n      expect(deepEquals([1], [1])).to.be.true;\n      expect(deepEquals([0, 1, 2], [0, 1, 2])).to.be.true;\n      expect(deepEquals([0, 'abc', 2], [0, 'abc', 2])).to.be.true;\n      expect(deepEquals([null, undefined, true], [null, undefined, true])).to.be.true;\n    });\n\n    it('with different primitive values are not equal', () => {\n      expect(deepEquals([0], [1])).to.be.false;\n      expect(deepEquals([0, 1, 2], [4, 5, 6])).to.be.false;\n      expect(deepEquals([0, 'abc', 2], [0, 'abc', '2'])).to.be.false;\n      expect(deepEquals([0, 'abc', '2'], [0, 'abc', 2])).to.be.false;\n      expect(deepEquals([null, null, true], [null, undefined, true])).to.be.false;\n      expect(deepEquals([null, undefined, true], [null, null, true])).to.be.false;\n    });\n\n    it('with different lengths are not equal', () => {\n      expect(deepEquals([], [1])).to.be.false;\n      expect(deepEquals([1], [])).to.be.false;\n      expect(deepEquals([0, 1, 2], [0, 1])).to.be.false;\n      expect(deepEquals([0, 1], [0, 1, 2])).to.be.false;\n      expect(deepEquals([0, 'abc'], [0, 'abc', 2])).to.be.false;\n      expect(deepEquals([0, 'abc', 2], [0, 'abc'])).to.be.false;\n      expect(deepEquals([null, undefined], [null])).to.be.false;\n      expect(deepEquals([null], [null, undefined])).to.be.false;\n    });\n  });\n\n  describe('objects', () => {\n    it('with no values are equal', () => {\n      expect(deepEquals({}, {})).to.be.true;\n    });\n\n    it('with the same primitive values are equal', () => {\n      expect(deepEquals({a: 123}, {a: 123})).to.be.true;\n      expect(deepEquals({a: '123'}, {a: '123'})).to.be.true;\n      expect(deepEquals({a: 123, b: 'abc'}, {a: 123, b: 'abc'})).to.be.true;\n      expect(deepEquals({a: 123, c: true, b: 'abc'}, {a: 123, b: 'abc', c: true})).to.be.true;\n    });\n\n    it('with different primitive values are not equal', () => {\n      expect(deepEquals({a: 123}, {a: 1234})).to.be.false;\n      expect(deepEquals({a: 1234}, {a: 123})).to.be.false;\n      expect(deepEquals({a: 123}, {a: null})).to.be.false;\n      expect(deepEquals({a: null}, {a: 123})).to.be.false;\n      expect(deepEquals({a: '123'}, {a: 123})).to.be.false;\n      expect(deepEquals({a: 123}, {a: '123'})).to.be.false;\n      expect(deepEquals({a: 123, c: 'abc', b: true}, {a: 123, b: 'abc', c: true})).to.be.false;\n      expect(deepEquals({a: undefined}, {a: 123})).to.be.false;\n      expect(deepEquals({a: 123}, {a: undefined})).to.be.false;\n    });\n\n    it('with different keys are not equal', () => {\n      expect(deepEquals({a: 123}, {b: 123})).to.be.false;\n      expect(deepEquals({a: 123, b: 456}, {a: 123, c: 456})).to.be.false;\n      expect(deepEquals({a: undefined}, {b: 123})).to.be.false;\n      expect(deepEquals({a: 123}, {b: undefined})).to.be.false;\n    });\n\n    it('with different lengths of keys are not equal', () => {\n      expect(deepEquals({}, {a: 1234})).to.be.false;\n      expect(deepEquals({a: 1234}, {})).to.be.false;\n      expect(deepEquals({a: 123, b: true}, {a: 123})).to.be.false;\n      expect(deepEquals({a: 123}, {a: 123, b: true})).to.be.false;\n      expect(deepEquals({a: '123'}, {a: '123', b: true})).to.be.false;\n      expect(deepEquals({a: '123', b: true}, {a: '123'})).to.be.false;\n      expect(deepEquals({a: '123'}, {a: '123', b: undefined})).to.be.false;\n      expect(deepEquals({a: '123', b: undefined}, {a: '123'})).to.be.false;\n      expect(deepEquals({a: 123, b: 'abc'}, {a: 123, b: 'abc', c: true})).to.be.false;\n      expect(deepEquals({a: 123, b: 'abc', c: true}, {a: 123, b: 'abc'})).to.be.false;\n    });\n  });\n\n  describe('nested objects and arrays', () => {\n    it('multi-dimensional arrays', () => {\n      expect(deepEquals([[1]], [[1]])).to.be.true;\n      expect(deepEquals([[1], [2]], [[1], [2]])).to.be.true;\n      expect(deepEquals([[1, true, 'abc'], [2]], [[1, true, 'abc'], [2]])).to.be.true;\n      expect(deepEquals([[1, [2, 3, [4, 5]]], [2]], [[1, [2, 3, [4, 5]]], [2]])).to.be.true;\n      expect(deepEquals([], [[]])).to.be.false;\n      expect(deepEquals([[]], [])).to.be.false;\n      expect(deepEquals([[1]], [[]])).to.be.false;\n      expect(deepEquals([[]], [[1]])).to.be.false;\n      expect(deepEquals([[1]], [[0]])).to.be.false;\n      expect(deepEquals([[0, []]], [[0]])).to.be.false;\n      expect(deepEquals([[0]], [[0, []]])).to.be.false;\n      expect(deepEquals([[0, [1, 2]]], [[0, [1]]])).to.be.false;\n      expect(deepEquals([[0, [1]]], [[0, [1, 2]]])).to.be.false;\n      expect(deepEquals([[1, true, 'abc'], [2]], [[1, true, 'abc']])).to.be.false;\n      expect(deepEquals([[1, [2, [4, 5]]], [2]], [[1, [2, 3, [4, 5]]], [2]])).to.be.false;\n      expect(deepEquals([[1, [2, '3', [4, 5]]], [2]], [[1, [2, 3, [4, 5]]], [2]])).to.be.false;\n    });\n\n    it('nested objects', () => {\n      expect(deepEquals({a: {}}, {a: {}})).to.be.true;\n      expect(deepEquals({a: {b: 'b'}}, {a: {b: 'b'}})).to.be.true;\n      expect(deepEquals({a: {b: 'b', c: 'c'}}, {a: {b: 'b', c: 'c'}})).to.be.true;\n      expect(deepEquals({a: {b: 'b', c: 'c', d: {e: true}}}, {a: {b: 'b', c: 'c', d: {e: true}}}))\n        .to.be.true;\n      expect(deepEquals({a: {}}, {a: false})).to.be.false;\n      expect(deepEquals({a: false}, {a: {}})).to.be.false;\n      expect(deepEquals({a: {b: 'b'}}, {a: {}})).to.be.false;\n      expect(deepEquals({a: {}}, {a: {b: 'b'}})).to.be.false;\n      expect(deepEquals({a: {b: 'b', c: 'c'}}, {a: {b: 'b'}})).to.be.false;\n      expect(deepEquals({a: {b: 'b', c: 'c', d: {e: false}}}, {a: {b: 'b', c: 'c', d: {e: true}}}))\n        .to.be.false;\n      expect(deepEquals({a: {b: 'b', c: 'c', d: null}}, {a: {b: 'b', c: 'c', d: {e: true}}})).to.be\n        .false;\n    });\n\n    it('different types combined and nested', () => {\n      expect(deepEquals([{}], [{}])).to.be.true;\n      expect(deepEquals([{}, {}, []], [{}, {}, []])).to.be.true;\n      expect(\n        deepEquals(\n          [{a: true, b: {}}, {}, [1, 2, null, true, {c: 'abc'}, 0]],\n          [{a: true, b: {}}, {}, [1, 2, null, true, {c: 'abc'}, 0]],\n        ),\n      ).to.be.true;\n      expect(deepEquals({a: []}, {a: []})).to.be.true;\n      expect(\n        deepEquals(\n          {a: [], b: {c: [1, true, undefined, 2]}},\n          {a: [], b: {c: [1, true, undefined, 2]}},\n        ),\n      ).to.be.true;\n\n      expect(deepEquals({}, [])).to.be.false;\n      expect(deepEquals([], {})).to.be.false;\n      expect(deepEquals(null, {})).to.be.false;\n      expect(deepEquals({}, null)).to.be.false;\n      expect(deepEquals(undefined, {})).to.be.false;\n      expect(deepEquals({}, undefined)).to.be.false;\n      expect(deepEquals(null, [])).to.be.false;\n      expect(deepEquals([], null)).to.be.false;\n      expect(deepEquals(undefined, [])).to.be.false;\n      expect(deepEquals([], undefined)).to.be.false;\n      expect(deepEquals([{}], [{}, null])).to.be.false;\n      expect(deepEquals([{}, null], [{}])).to.be.false;\n      expect(deepEquals([{}, {}, []], [{}, {}])).to.be.false;\n      expect(deepEquals([{}, {}], [{}, {}, []])).to.be.false;\n      expect(deepEquals([[], [], []], [{}, {}, {}])).to.be.false;\n      expect(deepEquals([{}, {}, {}], [[], [], []])).to.be.false;\n      expect(\n        deepEquals(\n          [{a: true, b: {}}, {}, [1, '2', null, true, {c: 'abc'}, 0]],\n          [{a: true, b: {}}, {}, [1, 2, null, true, {c: 'abc'}, 0]],\n        ),\n      ).to.be.false;\n      expect(\n        deepEquals(\n          [{a: true, b: {}}, {}, [1, 2, null, true, {c: 'abc'}, 0]],\n          [{a: true, b: {}}, {}, [1, 2, undefined, true, {c: 'abc'}, 0]],\n        ),\n      ).to.be.false;\n      expect(deepEquals({a: []}, {a: {}})).to.be.false;\n      expect(deepEquals({a: []}, {b: {}})).to.be.false;\n      expect(\n        deepEquals(\n          {a: [], b: {c: [1, false, undefined, 2]}},\n          {a: [], b: {c: [1, true, undefined, 2]}},\n        ),\n      ).to.be.false;\n    });\n  });\n});\n"
            }
        },
        "spaceTime": "",
        "submissionStatistics": {
            "correctCount": 1187,
            "failureCount": 550
        },
        "testStrategy": "SANDBOX_ONLY",
        "tests": [],
        "uid": "deep-equals",
        "version": 0,
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 0,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "722690307"
        },
        "visualization": {
            "inputType": null,
            "outputType": null
        }
    },
    "difficulty": 0,
    "instructor": "Conner Ardman",
    "name": "Deep Equals",
    "releaseDate": "2022-07-01T00:00:00Z",
    "type": "CODING_STANDARD",
    "uid": "deep-equals"
}