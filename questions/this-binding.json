{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "JavaScript",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "assessmentSummary": null,
        "category": "JavaScript",
        "changelog": [],
        "customInputVars": [],
        "difficulty": 0,
        "hints": [
            "<p>\n  Think about how <span>this</span> binding works. How can a function be invoked\n  with an object as its <span>this</span> context?\n</p>\n",
            "\n<p>\n  A function can be invoked with an object as its <span>this</span> context if\n  that function is a value in the object.\n</p>\n",
            "\n<p>\n  A Symbol can be created with the <span>Symbol()</span> function and used as an\n  object key. These are unique and will not affect standard iteration.\n</p>\n",
            "\n<p>\n  The <span>delete</span> keyword can be used to remove a key from an object.\n</p>\n",
            "\n<p>\n  The <span>...spread</span> operator can be used to pass an array of values as\n  individual arguments to a function.\n</p>\n",
            "\n<p>\n  These three functions are very similar to each other. Can you implement the\n  last two by simply calling your first function?\n</p>"
        ],
        "isLongOutput": false,
        "isSlowExecution": false,
        "jsonTests": [],
        "languagesSupported": [
            "javascript"
        ],
        "name": "This Binding",
        "notes": "",
        "prompt": "<div class=\"html\">\n  <p>\n    Without calling <span>Function.prototype.call</span>,\n    <span>Function.prototype.apply</span> or\n    <span>Function.prototype.bind</span>, implement the following three similar\n    functions on the <span>Function</span> prototype:\n  </p>\n  <ol>\n    <li>\n      <p><span>myCall(thisContext, ...args)</span></p>\n      <p>\n        <span>myCall</span> should call the original function with\n        <span>thisContext</span> bound to the function's\n        <span>this</span> keyword, passing all of the remaining\n        <span>args</span> as individual arguments to the function.\n      </p>\n      <p style=\"margin: 0 0 10px 0\">\n        The return value of the original function should be returned by\n        <span>myCall</span>.\n      </p>\n    </li>\n    <li>\n      <p><span>myApply(thisContext, args)</span></p>\n      <p>\n        <span>myApply</span> should call the original function with\n        <span>thisContext</span> bound to the function's\n        <span>this</span> keyword, passing all of the values in the\n        <span>args</span> array as individual arguments to the function.\n      </p>\n      <p style=\"margin: 0 0 10px 0\">\n        The return value of the original function should be returned by\n        <span>myApply</span>.\n      </p>\n    </li>\n    <li>\n      <p><span>myBind(thisContext, ...args)</span></p>\n      <p>\n        <span>myBind</span> should return a new function that calls the original\n        function with <span>thisContext</span> bound to the function's\n        <span>this</span> keyword, passing all of the remaining\n        <span>args</span> as individual arguments to the function. The new\n        function should accept optional arguments, which should also be passed\n        to the original function, after the <span>args</span> originally passed\n        to <span>myBind</span>.\n      </p>\n      <p style=\"margin: 0 0 10px 0\">\n        The new function should return the return value of the original\n        function.\n      </p>\n    </li>\n  </ol>\n  <p>\n    You can assume that the <span>thisContext</span> argument passed to each\n    function will always be an object. When binding this object to the\n    <span>this</span> keyword, the original object should be bound, not a clone.\n    You can also assume that the original function will be declared using\n    standard function syntax (i.e., it won't be an arrow function).\n  </p>\n  <p>\n    You should minimize side-effects as much as possible, ensuring that\n    <span>thisContext</span> remains unchanged after calls to these functions\n    and ensuring that standard iteration through properties on\n    <span>thisContext</span> works normally.\n  </p>\n  <p></p>\n  <h3>Sample Usage</h3>\n</div>\n<div class=\"code-wrapper prism\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">const obj = {num: 0};\n\nfunction logNums(x, y) {\n  console.log(this.num, x, y);\n}\n\nlogNums.myCall(obj, 1, 2);\nlogNums.myApply(obj, [1, 2]);\n\nconst boundFunction = logNums.myBind(obj, 1);\nboundFunction(2);\n</code></pre>\n</div>\n<div class=\"html\">\n  <h3>Sample Output</h3>\n  <pre>\n<span class=\"CodeEditor-promptComment\">// Console logs:</span>\n0 1 2 <span class=\"CodeEditor-promptComment\">// From myCall.</span>\n0 1 2 <span class=\"CodeEditor-promptComment\">// From myApply.</span>\n0 1 2 <span class=\"CodeEditor-promptComment\">// From myBind.</span>\n</pre>\n</div>",
        "releaseDate": "2021-12-04T00:00:00Z",
        "resources": {
            "javascript": {
                "language": "javascript",
                "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\nconst chai = require('chai');\nconst spies = require('chai-spies');\n\nchai.use(spies);\nconst spy = () =>\n  chai.spy(function (returnValue) {\n    return returnValue ?? this;\n  });\nlet thisContext;\nconst {expect} = chai;\n\nrequire('./program.js');\n\ndescribe('this binding', () => {\n  beforeEach(() => {\n    thisContext = {test: '123'};\n  });\n\n  describe('myCall', () => {\n    it('calls the function', () => {\n      const callback = spy();\n      callback.myCall(thisContext);\n      expect(callback).to.have.been.called.exactly(1);\n    });\n\n    it('binds correct this value', () => {\n      const callback = spy();\n      const output = callback.myCall(thisContext);\n      expect(output).to.equal(thisContext);\n    });\n  });\n\n  describe('myApply', () => {\n    it('calls the function', () => {\n      const callback = spy();\n      callback.myApply(thisContext);\n      expect(callback).to.have.been.called.exactly(1);\n    });\n\n    it('binds correct this value', () => {\n      const callback = spy();\n      const output = callback.myApply(thisContext);\n      expect(output).to.equal(thisContext);\n    });\n  });\n\n  describe('myBind', () => {\n    it('does not immediately call the original function', () => {\n      const callback = spy();\n      callback.myBind(thisContext);\n      expect(callback).to.have.been.called.exactly(0);\n    });\n\n    it('calls the original function when the new function is called', () => {\n      const callback = spy();\n      const boundFunction = callback.myBind(thisContext);\n      expect(callback).to.have.been.called.exactly(0);\n      boundFunction();\n      expect(callback).to.have.been.called.exactly(1);\n    });\n\n    it('binds correct this value', () => {\n      const callback = spy();\n      const boundFunction = callback.myBind(thisContext);\n      const output = boundFunction();\n      expect(output).to.equal(thisContext);\n    });\n  });\n});\n",
                "solutions": [
                    "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nFunction.prototype.myCall = function (thisContext, ...args) {\n  // In this function, `this` is the original function.\n\n  // In order to have `thisContext` be the `this` context\n  // of the original function, we set the function (`this`)\n  // to be a value on `thisContext`, and we use a symbol to\n  // prevent any key collisions on `thisContext`.\n  const symbol = Symbol();\n  thisContext[symbol] = this;\n\n  const returnValue = thisContext[symbol](...args);\n  delete thisContext[symbol];\n\n  return returnValue;\n};\n\nFunction.prototype.myApply = function (thisContext, args = []) {\n  // In this function, `this` is the original function.\n  return this.myCall(thisContext, ...args);\n};\n\nFunction.prototype.myBind = function (thisContext, ...args) {\n  // In this function, `this` is the original function.\n  return (...newArgs) => this.myApply(thisContext, [...args, ...newArgs]);\n\n  // Below is an alternative solution using `myCall`.\n  // return (...newArgs) => this.myCall(thisContext, ...args, ...newArgs);\n};\n"
                ],
                "solutionsDisabled": false,
                "startingCode": "Function.prototype.myCall = function (thisContext, ...args) {\n  // Write your code here.\n};\n\nFunction.prototype.myApply = function (thisContext, args = []) {\n  // Write your code here.\n};\n\nFunction.prototype.myBind = function (thisContext, ...args) {\n  // Write your code here.\n};\n",
                "unitTests": "const chai = require('chai');\nconst spies = require('chai-spies');\n\nchai.use(spies);\nconst spy = () =>\n  chai.spy(function (returnValue) {\n    return returnValue ?? this;\n  });\nlet thisContext;\nconst {expect} = chai;\n\nrequire('./program.js');\n\ndescribe('this binding', () => {\n  beforeEach(() => {\n    thisContext = {test: '123'};\n  });\n\n  describe('myCall', () => {\n    it('calls the function', () => {\n      const callback = spy();\n      callback.myCall(thisContext);\n      expect(callback).to.have.been.called.exactly(1);\n    });\n\n    it('passes correct single argument', () => {\n      const callback = spy();\n      callback.myCall(thisContext, 'foo');\n      expect(callback).to.have.been.called.with('foo');\n    });\n\n    it('passes multiple arguments', () => {\n      const callback = spy();\n      callback.myCall(thisContext, 'foo', 'bar', 10);\n      expect(callback).to.have.been.called.with('foo', 'bar', 10);\n    });\n\n    it('returns original function return value', () => {\n      const callback = spy();\n      const output = callback.myCall(thisContext, 123);\n      expect(output).to.equal(123);\n\n      const output2 = callback.myCall(thisContext, 'test');\n      expect(output2).to.equal('test');\n    });\n\n    it('binds correct this value', () => {\n      const callback = spy();\n      const output = callback.myCall(thisContext);\n      expect(output).to.equal(thisContext);\n    });\n\n    it('leaves thisContext unchanged', () => {\n      const callback = spy();\n      const tmpContext = {...thisContext};\n      callback.myCall(thisContext);\n      expect(tmpContext).to.deep.equal(thisContext);\n\n      const originalProperties = [\n        ...Object.getOwnPropertyNames(tmpContext),\n        ...Object.getOwnPropertySymbols(tmpContext),\n      ];\n      const properties = [\n        ...Object.getOwnPropertyNames(thisContext),\n        ...Object.getOwnPropertySymbols(thisContext),\n      ];\n      expect(originalProperties).to.deep.equal(originalProperties);\n\n      // Ensures even symbols have been removed\n      expect(originalProperties.length).to.equal(properties.length);\n    });\n\n    it(`doesn't add enumerable properties to the object`, () => {\n      const callback = function () {\n        return Object.keys(this).length;\n      };\n      const output = callback.myCall(thisContext);\n      expect(output).equal(1);\n    });\n\n    it(`doesn't call the Functions's native call, apply, or methods`, () => {\n      const callback = spy();\n      chai.spy.on(callback, 'call');\n      chai.spy.on(callback, 'apply');\n      chai.spy.on(callback, 'bind');\n      callback.myCall(thisContext);\n\n      expect(callback.call).to.have.been.called.exactly(0);\n      expect(callback.apply).to.have.been.called.exactly(0);\n      expect(callback.bind).to.have.been.called.exactly(0);\n      chai.spy.restore();\n    });\n  });\n\n  describe('myApply', () => {\n    it('calls the function', () => {\n      const callback = spy();\n      callback.myApply(thisContext);\n      expect(callback).to.have.been.called.exactly(1);\n    });\n\n    it('passes correct single argument', () => {\n      const callback = spy();\n      callback.myApply(thisContext, ['foo']);\n      expect(callback).to.have.been.called.with('foo');\n    });\n\n    it('passes multiple arguments', () => {\n      const callback = spy();\n      callback.myApply(thisContext, ['foo', 'bar', 10]);\n      expect(callback).to.have.been.called.with('foo', 'bar', 10);\n    });\n\n    it('returns original function return value', () => {\n      const callback = spy();\n      const output = callback.myApply(thisContext, [123]);\n      expect(output).to.equal(123);\n\n      const output2 = callback.myApply(thisContext, ['test']);\n      expect(output2).to.equal('test');\n    });\n\n    it('binds correct this value', () => {\n      const callback = spy();\n      const output = callback.myApply(thisContext);\n      expect(output).to.equal(thisContext);\n    });\n\n    it('leaves thisContext unchanged', () => {\n      const callback = spy();\n      const tmpContext = {...thisContext};\n      callback.myApply(thisContext);\n      expect(tmpContext).to.deep.equal(thisContext);\n\n      const originalProperties = [\n        ...Object.getOwnPropertyNames(tmpContext),\n        ...Object.getOwnPropertySymbols(tmpContext),\n      ];\n      const properties = [\n        ...Object.getOwnPropertyNames(thisContext),\n        ...Object.getOwnPropertySymbols(thisContext),\n      ];\n      expect(originalProperties).to.deep.equal(originalProperties);\n\n      // Ensures even symbols have been removed\n      expect(originalProperties.length).to.equal(properties.length);\n    });\n\n    it(`doesn't add enumerable properties to the object`, () => {\n      const callback = function () {\n        return Object.keys(this).length;\n      };\n      const output = callback.myApply(thisContext);\n      expect(output).equal(1);\n    });\n\n    it(`doesn't call the Functions's native call, apply, or methods`, () => {\n      const callback = spy();\n      chai.spy.on(callback, 'call');\n      chai.spy.on(callback, 'apply');\n      chai.spy.on(callback, 'bind');\n      callback.myApply(thisContext);\n\n      expect(callback.call).to.have.been.called.exactly(0);\n      expect(callback.apply).to.have.been.called.exactly(0);\n      expect(callback.bind).to.have.been.called.exactly(0);\n      chai.spy.restore();\n    });\n  });\n\n  describe('myBind', () => {\n    it(`doesn't immediately call the original function`, () => {\n      const callback = spy();\n      callback.myBind(thisContext);\n      expect(callback).to.have.been.called.exactly(0);\n    });\n\n    it('calls the original function when the new function is called', () => {\n      const callback = spy();\n      const boundFunction = callback.myBind(thisContext);\n      expect(callback).to.have.been.called.exactly(0);\n      boundFunction();\n      expect(callback).to.have.been.called.exactly(1);\n    });\n\n    it('passes correct arguments in bind call', () => {\n      const callback = spy();\n      const boundFunction = callback.myBind(thisContext, 'foo', 'bar', 10);\n      boundFunction();\n      expect(callback).to.have.been.called.with('foo', 'bar', 10);\n    });\n\n    it('passes correct arguments in new function', () => {\n      const callback = spy();\n      const boundFunction = callback.myBind(thisContext);\n      boundFunction('foo', 'bar', 10);\n      expect(callback).to.have.been.called.with('foo', 'bar', 10);\n    });\n\n    it('passes arguments in the correct order', () => {\n      const callback = spy();\n      const boundFunction = callback.myBind(thisContext, 'foo');\n      boundFunction('bar', 10);\n      expect(callback).to.have.been.called.with('foo', 'bar', 10);\n    });\n\n    it('returns original function return value', () => {\n      const callback = spy();\n      const boundFunction = callback.myBind(thisContext);\n      const output = boundFunction(123);\n      expect(output).to.equal(123);\n\n      const output2 = boundFunction('test');\n      expect(output2).to.equal('test');\n    });\n\n    it('binds correct this value', () => {\n      const callback = spy();\n      const boundFunction = callback.myBind(thisContext);\n      const output = boundFunction();\n      expect(output).to.equal(thisContext);\n    });\n\n    it('leaves thisContext unchanged', () => {\n      const callback = spy();\n      const tmpContext = {...thisContext};\n      const boundFunction = callback.myBind(thisContext);\n      boundFunction();\n      expect(tmpContext).to.deep.equal(thisContext);\n\n      const originalProperties = [\n        ...Object.getOwnPropertyNames(tmpContext),\n        ...Object.getOwnPropertySymbols(tmpContext),\n      ];\n      const properties = [\n        ...Object.getOwnPropertyNames(thisContext),\n        ...Object.getOwnPropertySymbols(thisContext),\n      ];\n      expect(originalProperties).to.deep.equal(originalProperties);\n\n      // Ensures even symbols have been removed\n      expect(originalProperties.length).to.equal(properties.length);\n    });\n\n    it(`doesn't add enumerable properties to the object`, () => {\n      const callback = function () {\n        return Object.keys(this).length;\n      };\n      const boundFunction = callback.myBind(thisContext);\n      const output = boundFunction();\n      expect(output).equal(1);\n    });\n\n    it(`doesn't call the Functions's native call, apply, or methods`, () => {\n      const callback = spy();\n      chai.spy.on(callback, 'call');\n      chai.spy.on(callback, 'apply');\n      chai.spy.on(callback, 'bind');\n      const boundFunction = callback.myBind(thisContext);\n      boundFunction();\n\n      expect(callback.call).to.have.been.called.exactly(0);\n      expect(callback.apply).to.have.been.called.exactly(0);\n      expect(callback.bind).to.have.been.called.exactly(0);\n      chai.spy.restore();\n    });\n  });\n});\n"
            }
        },
        "spaceTime": "",
        "submissionStatistics": {
            "correctCount": 2045,
            "failureCount": 482
        },
        "testStrategy": "SANDBOX_ONLY",
        "tests": [],
        "uid": "this-binding",
        "version": 0,
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 0,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "653057527"
        },
        "visualization": {
            "inputType": null,
            "outputType": null
        }
    },
    "difficulty": 0,
    "instructor": "Conner Ardman",
    "name": "This Binding",
    "releaseDate": "2021-12-04T00:00:00Z",
    "type": "CODING_STANDARD",
    "uid": "this-binding"
}