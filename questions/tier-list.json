{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "DOM Manipulation",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "category": "DOM Manipulation",
        "hints": [
            "<p>\n  There are a variety of events associated with drag and drop. These ones might\n  be useful for solving this problem: <span>dragstart</span>, <span>dragover</span>,\n  and <span>drop</span>.\n</p>",
            "<p>\n  The default behavior of the <span>dragover</span> event is to not allow elements\n  to be dropped. Can you change this default behavior with JavaScript?\n</p>",
            "<p>\n  The default behavior of an event can be negated in an event listener callback\n  by using the <span>event.preventDefault()</span> function.\n</p>",
            "<p>\n  Drag events have a <span>dataTransfer</span> property that can be useful for\n  sharing information between the event listeners for a single drag and drop\n  operation. For example, <span>event.dataTransfer.setData('text/plain', 'hello')</span>\n  would save the hello string. Another event listener involved in the same\n  drag and drop operation could then read that string with\n  <span>event.dataTransfer.getData('text/plain')</span>.\n</p>",
            "<p>\n  The <span>dblclick</span> event can be used to listen to double clicks. This\n  works just like <span>click</span> but requires two mouse clicks.\n</p>"
        ],
        "languageToWrite": "javascript",
        "name": "Tier List",
        "notes": "",
        "prompt": "<div class=\"html\">\n  <p>\n    You're given HTML and CSS files for a simple tier list, and you need to make\n    the tier list functional using JavaScript.\n  </p>\n  <p>\n    A tier list is a system that allows you to rank items from best to worst.\n    The provided tier list has three tiers (A, B, and C) and three items\n    (colored squares), which start out in an unranked section.\n  </p>\n  <p>The tier list should have the following functionality:</p>\n  <ul>\n    <li>\n      Each element with the <span>item</span> class (each colored square)\n      should be draggable.\n    </li>\n    <li>\n      If a colored square is drag-and-dropped in an element with the\n      <span>drop-zone</span> class (one of the grey drop zones), the square\n      should be appended to that element. If the square was already in that\n      drop zone or if the square is dropped anywhere else on the page, nothing\n      should happen (the square should remain where it was).\n    </li>\n    <li>\n      If a colored square is <b>double</b>-clicked, it should be appended to the\n      element with the <span>unranked-drop-zone</span> id (the grey drop zone in the\n      unranked section). If the item was already in the unranked drop zone,\n      nothing should happen (the square should remain where it was).\n    </li>\n  </ul>\n  <p>Your solution should use the standard browser drag-and-drop API.</p>\n  <p>\n    Your JavaScript code has already been linked to the pre-written HTML code\n    via a deferred script tag.\n  </p>\n</div>",
        "promptCode": {
            "css": "h1 {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-basis: 150px;\n  padding: 12px;\n  border-right: 5px solid black;\n  margin: 0;\n  font-size: 24px;\n  user-select: none;\n  background-color: #082969;\n  color: white;\n}\n\n.tier-section {\n  display: flex;\n  border: 5px solid black;\n  min-height: 50px;\n}\n\n.tier-section:not(:first-of-type, :last-of-type) {\n  border-top: none;\n}\n\n.drop-zone {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  flex-basis: 100%;\n  background-color: lightgrey;\n}\n\n.item {\n  display: inline-block;\n  width: 40px;\n  height: 40px;\n  border: 2px solid black;\n  border-radius: 8px;\n  margin: 0 8px;\n  opacity: 0.999; /* prevents Chrome bug of white edges while dragging */\n}\n\n#unranked-section {\n  margin-top: 18px;\n}\n\n#blue {\n  background-color: blue;\n}\n\n#red {\n  background-color: red;\n}\n\n#green {\n  background-color: green;\n}",
            "html": "<div id=\"wrapper\">\n  <section class=\"tier-section\">\n    <h1>A Tier</h1>\n    <div class=\"drop-zone\"></div>\n  </section>\n  <section class=\"tier-section\">\n    <h1>B Tier</h1>\n    <div class=\"drop-zone\"></div>\n  </section>\n  <section class=\"tier-section\">\n    <h1>C Tier</h1>\n    <div class=\"drop-zone\"></div>\n  </section>\n\n  <section class=\"tier-section\" id=\"unranked-section\">\n    <h1>Unranked</h1>\n    <div class=\"drop-zone\" id=\"unranked-drop-zone\">\n      <div draggable=\"true\" id=\"blue\" class=\"item\"></div>\n      <div draggable=\"true\" id=\"red\" class=\"item\"></div>\n      <div draggable=\"true\" id=\"green\" class=\"item\"></div>\n    </div>\n  </section>\n</div>"
        },
        "reactConfig": null,
        "solutions": {
            "javascript": [
                "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nlet draggedItem;\n\ndocument.querySelectorAll('.item').forEach(setUpItem);\ndocument.querySelectorAll('.drop-zone').forEach(setUpDropZone);\n\nfunction setUpItem(item) {\n  item.addEventListener('dragstart', onDragItem);\n  item.addEventListener('dblclick', onDoubleClickItem);\n}\n\nfunction setUpDropZone(dropZone) {\n  dropZone.addEventListener('drop', onDropOverDropZone);\n  dropZone.addEventListener('dragover', onDragOverDropZone);\n}\n\nfunction onDragItem(event) {\n  draggedItem = event.target;\n}\n\nfunction onDoubleClickItem() {\n  const unrankedDropZone = document.getElementById('unranked-drop-zone');\n  if (unrankedDropZone !== this.parentNode) {\n    unrankedDropZone.appendChild(this);\n  }\n}\n\nfunction onDropOverDropZone() {\n  if (this !== draggedItem.parentNode) {\n    this.appendChild(draggedItem);\n  }\n}\n\nfunction onDragOverDropZone(event) {\n  // The default browser behavior doesn't allow\n  // drops, so we prevent that behavior.\n  event.preventDefault();\n}",
                "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\ndocument.querySelectorAll('.item').forEach(setUpItem);\ndocument.querySelectorAll('.drop-zone').forEach(setUpDropZone);\n\nfunction setUpItem(item) {\n  item.addEventListener('dragstart', onDragItem);\n  item.addEventListener('dblclick', onDoubleClickItem);\n}\n\nfunction setUpDropZone(dropZone) {\n  dropZone.addEventListener('drop', onDropOverDropZone);\n  dropZone.addEventListener('dragover', onDragOverDropZone);\n}\n\nfunction onDragItem(event) {\n  const draggedItemID = event.target.id;\n  event.dataTransfer.setData('text/plain', draggedItemID);\n}\n\nfunction onDoubleClickItem() {\n  const unrankedDropZone = document.getElementById('unranked-drop-zone');\n  if (unrankedDropZone !== this.parentNode) {\n    unrankedDropZone.appendChild(this);\n  }\n}\n\nfunction onDropOverDropZone(event) {\n  // In some browsers (like Firefox), the `dataTransfer` property\n  // is treated as a URL by default, so we prevent that behavior.\n  event.preventDefault();\n  const draggedItemID = event.dataTransfer.getData('text/plain');\n  const draggedItem = document.getElementById(draggedItemID);\n  if (this !== draggedItem.parentNode) {\n    this.appendChild(draggedItem);\n  }\n}\n\nfunction onDragOverDropZone(event) {\n  // The default browser behavior doesn't allow\n  // drops, so we prevent that behavior.\n  event.preventDefault();\n}"
            ]
        },
        "startingCode": {
            "javascript": "// Write your code here.\n"
        },
        "submissionStatistics": {
            "correctCount": 900,
            "failureCount": 286
        },
        "testHarness": {
            "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nconst {JSDOM} = require('jsdom');\nconst {readFileSync} = require('fs');\nconst {expect} = require('chai');\n\nconst html = readFileSync('data/index.html');\n\nlet items;\nlet dropZones;\n\nconst resetDom = () => {\n  const dom = new JSDOM(html, {\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n\n  delete require.cache[require.resolve('./program.js')];\n  require('./program.js');\n\n  items = document.querySelectorAll('.item');\n  dropZones = document.querySelectorAll('.drop-zone');\n};\n\nclass DataTransferStore {\n  constructor(\n    data = {},\n    dropEffect = 'none',\n    effectAllowed = 'none',\n    items = [],\n    files = [],\n    types = [],\n  ) {\n    this.data = data;\n    this.dropEffect = dropEffect;\n    this.effectAllowed = effectAllowed;\n    this.items = items;\n    this.files = files;\n    this.types = types;\n  }\n}\n\nclass DataTransfer {\n  constructor(store) {\n    this.store = store;\n  }\n\n  clearData(format) {\n    this.store.clearData(format);\n  }\n\n  getData(format) {\n    return this.store.data[format] ?? '';\n  }\n\n  setData(format, value) {\n    this.store.data[format] = value;\n  }\n}\n\nglobal.DataTransfer = DataTransfer;\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\nconst triggerDragEvents = (element, dropZone) => {\n  const dataTransferStore = new DataTransferStore();\n\n  const dragStart = new window.Event('dragstart', {bubbles: true});\n  dragStart.dataTransfer = new DataTransfer(dataTransferStore);\n\n  const drag = new window.Event('drag', {bubbles: true});\n  drag.dataTransfer = new DataTransfer(dataTransferStore);\n\n  const dragEnter = new window.Event('dragenter', {bubbles: true});\n  dragEnter.dataTransfer = new DataTransfer(dataTransferStore);\n\n  const dragOver = new window.Event('dragover', {\n    cancelable: true,\n    bubbles: true,\n  });\n  dragOver.dataTransfer = new DataTransfer(dataTransferStore);\n\n  const drop = new window.Event('drop', {bubbles: true});\n  drop.dataTransfer = new DataTransfer(dataTransferStore);\n\n  const dragEnd = new window.Event('dragend', {bubbles: true});\n  dragEnd.dataTransfer = new DataTransfer(dataTransferStore);\n\n  element.dispatchEvent(dragStart);\n  element.dispatchEvent(drag);\n  dropZone.dispatchEvent(dragEnter);\n\n  // Check that preventDefault was called on the drop-zone\n  let canDrop = false;\n  let actualDropZone = dropZone.classList.contains('drop-zone') ? dropZone : dropZone.parentNode;\n  actualDropZone.addEventListener('dragover', event => {\n    if (event.defaultPrevented) {\n      canDrop = true;\n    }\n  });\n\n  dropZone.addEventListener('dragover', event => {\n    if (event.defaultPrevented) {\n      canDrop = true;\n    }\n  });\n\n  actualDropZone.dispatchEvent(dragOver);\n  dropZone.dispatchEvent(dragOver);\n  canDrop && dropZone.dispatchEvent(drop);\n  element.dispatchEvent(dragEnd);\n};\n\ndescribe('tier list', () => {\n  beforeEach(() => {\n    resetDom();\n  });\n\n  describe('drag and drop', () => {\n    it('items can be dropped in a different zone', () => {\n      triggerDragEvents(items[0], dropZones[0]);\n\n      expect(dropZones[dropZones.length - 1].children.length).to.equal(items.length - 1);\n      expect(dropZones[0].children.length).to.equal(1);\n    });\n\n    it('items can move multiple times', () => {\n      triggerDragEvents(items[0], dropZones[0]);\n      triggerDragEvents(items[0], dropZones[1]);\n\n      expect(dropZones[dropZones.length - 1].children.length).to.equal(items.length - 1);\n      expect(dropZones[0].children.length).to.equal(0);\n      expect(dropZones[1].children.length).to.equal(1);\n    });\n  });\n\n  describe('double click', () => {\n    it('returns an item to the unranked zone', () => {\n      triggerDragEvents(items[0], dropZones[0]);\n      items[0].dispatchEvent(new window.MouseEvent('dblclick'));\n\n      expect(dropZones[dropZones.length - 1].children.length).to.equal(items.length);\n      expect(dropZones[0].children.length).to.equal(0);\n    });\n  });\n});\n",
            "unitTests": "/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nconst {JSDOM} = require('jsdom');\nconst {readFileSync} = require('fs');\nconst {expect} = require('chai');\n\nconst html = readFileSync('data/index.html');\n\nlet items;\nlet dropZones;\n\nconst resetDom = () => {\n  const dom = new JSDOM(html, {\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n\n  delete require.cache[require.resolve('./program.js')];\n  require('./program.js');\n\n  items = document.querySelectorAll('.item');\n  dropZones = document.querySelectorAll('.drop-zone');\n};\n\nclass DataTransferStore {\n  constructor(\n    data = {},\n    dropEffect = 'none',\n    effectAllowed = 'none',\n    items = [],\n    files = [],\n    types = [],\n  ) {\n    this.data = data;\n    this.dropEffect = dropEffect;\n    this.effectAllowed = effectAllowed;\n    this.items = items;\n    this.files = files;\n    this.types = types;\n  }\n}\n\nclass DataTransfer {\n  constructor(store) {\n    this.store = store;\n  }\n\n  clearData(format) {\n    this.store.clearData(format);\n  }\n\n  getData(format) {\n    return this.store.data[format] ?? '';\n  }\n\n  setData(format, value) {\n    this.store.data[format] = value;\n  }\n}\n\nglobal.DataTransfer = DataTransfer;\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\nconst triggerDragEvents = (element, dropZone) => {\n  const dataTransferStore = new DataTransferStore();\n\n  const dragStart = new window.Event('dragstart', {bubbles: true});\n  dragStart.dataTransfer = new DataTransfer(dataTransferStore);\n\n  const drag = new window.Event('drag', {bubbles: true});\n  drag.dataTransfer = new DataTransfer(dataTransferStore);\n\n  const dragEnter = new window.Event('dragenter', {bubbles: true});\n  dragEnter.dataTransfer = new DataTransfer(dataTransferStore);\n\n  const dragOver = new window.Event('dragover', {\n    cancelable: true,\n    bubbles: true,\n  });\n  dragOver.dataTransfer = new DataTransfer(dataTransferStore);\n\n  const drop = new window.Event('drop', {bubbles: true});\n  drop.dataTransfer = new DataTransfer(dataTransferStore);\n\n  const dragEnd = new window.Event('dragend', {bubbles: true});\n  dragEnd.dataTransfer = new DataTransfer(dataTransferStore);\n\n  element.dispatchEvent(dragStart);\n  element.dispatchEvent(drag);\n  dropZone.dispatchEvent(dragEnter);\n\n  // Check that preventDefault was called on the drop-zone\n  let canDrop = false;\n  let actualDropZone = dropZone.classList.contains('drop-zone') ? dropZone : dropZone.parentNode;\n  actualDropZone.addEventListener('dragover', event => {\n    if (event.defaultPrevented) {\n      canDrop = true;\n    }\n  });\n\n  dropZone.addEventListener('dragover', event => {\n    if (event.defaultPrevented) {\n      canDrop = true;\n    }\n  });\n\n  actualDropZone.dispatchEvent(dragOver);\n  dropZone.dispatchEvent(dragOver);\n  canDrop && dropZone.dispatchEvent(drop);\n  element.dispatchEvent(dragEnd);\n};\n\ndescribe('tier list', () => {\n  beforeEach(() => {\n    resetDom();\n  });\n\n  describe('drag and drop', () => {\n    it('items can be dropped in a different zone', () => {\n      triggerDragEvents(items[0], dropZones[0]);\n\n      expect(dropZones[dropZones.length - 1].children.length).to.equal(items.length - 1);\n      expect(dropZones[0].children.length).to.equal(1);\n    });\n\n    it('items can move multiple times', () => {\n      triggerDragEvents(items[0], dropZones[0]);\n      triggerDragEvents(items[0], dropZones[1]);\n\n      expect(dropZones[dropZones.length - 1].children.length).to.equal(items.length - 1);\n      expect(dropZones[0].children.length).to.equal(0);\n      expect(dropZones[1].children.length).to.equal(1);\n    });\n\n    it('multiple items can be moved', () => {\n      triggerDragEvents(items[0], dropZones[0]);\n      triggerDragEvents(items[1], dropZones[0]);\n\n      expect(dropZones[dropZones.length - 1].children.length).to.equal(items.length - 2);\n      expect(dropZones[0].children.length).to.equal(2);\n    });\n\n    it('multiple items can be moved multiple times', () => {\n      triggerDragEvents(items[0], dropZones[0]);\n      triggerDragEvents(items[1], dropZones[0]);\n      triggerDragEvents(items[2], dropZones[1]);\n      expect(items[0].parentNode).to.equal(dropZones[0]);\n      expect(items[1].parentNode).to.equal(dropZones[0]);\n      expect(items[2].parentNode).to.equal(dropZones[1]);\n\n      triggerDragEvents(items[1], dropZones[2]);\n      expect(items[0].parentNode).to.equal(dropZones[0]);\n      expect(items[1].parentNode).to.equal(dropZones[2]);\n      expect(items[2].parentNode).to.equal(dropZones[1]);\n\n      triggerDragEvents(items[0], dropZones[2]);\n      triggerDragEvents(items[1], dropZones[1]);\n      triggerDragEvents(items[2], dropZones[0]);\n      expect(items[0].parentNode).to.equal(dropZones[2]);\n      expect(items[1].parentNode).to.equal(dropZones[1]);\n      expect(items[2].parentNode).to.equal(dropZones[0]);\n    });\n\n    it('items are appended in the correct order', () => {\n      triggerDragEvents(items[0], dropZones[0]);\n      triggerDragEvents(items[1], dropZones[0]);\n      triggerDragEvents(items[2], dropZones[0]);\n      expect(Array.from(dropZones[0].children)).to.deep.equal([items[0], items[1], items[2]]);\n\n      triggerDragEvents(items[1], dropZones[1]);\n      triggerDragEvents(items[0], dropZones[1]);\n      triggerDragEvents(items[2], dropZones[1]);\n      expect(Array.from(dropZones[1].children)).to.deep.equal([items[1], items[0], items[2]]);\n    });\n\n    it('dropping items outside of drop zones has no effect', () => {\n      triggerDragEvents(items[0], document.body);\n      triggerDragEvents(items[1], document.querySelector('.tier-section h1'));\n\n      expect(dropZones[dropZones.length - 1].children.length).to.equal(items.length);\n    });\n\n    it('dropping items in their original drop zone has no effect', () => {\n      const originalOrder = [...dropZones[dropZones.length - 1].children];\n      triggerDragEvents(items[0], dropZones[dropZones.length - 1]);\n      triggerDragEvents(items[1], dropZones[dropZones.length - 1]);\n\n      expect([...dropZones[dropZones.length - 1].children]).to.deep.equal(originalOrder);\n    });\n\n    it('dropping items on other items leaves them in the drop zone', () => {\n      triggerDragEvents(items[0], dropZones[0]);\n      triggerDragEvents(items[1], items[0]);\n\n      expect(dropZones[dropZones.length - 1].children.length).to.equal(items.length - 2);\n      expect(dropZones[0].children.length).to.equal(2);\n    });\n  });\n\n  describe('double click', () => {\n    it('returns an item to the unranked zone', () => {\n      triggerDragEvents(items[0], dropZones[0]);\n      items[0].dispatchEvent(new window.MouseEvent('dblclick'));\n\n      expect(dropZones[dropZones.length - 1].children.length).to.equal(items.length);\n      expect(dropZones[0].children.length).to.equal(0);\n    });\n\n    it('can return multiple items to the unranked zone', () => {\n      triggerDragEvents(items[0], dropZones[0]);\n      triggerDragEvents(items[1], dropZones[0]);\n      triggerDragEvents(items[2], dropZones[1]);\n      items[0].dispatchEvent(new window.MouseEvent('dblclick'));\n      items[1].dispatchEvent(new window.MouseEvent('dblclick'));\n      items[2].dispatchEvent(new window.MouseEvent('dblclick'));\n\n      expect(dropZones[dropZones.length - 1].children.length).to.equal(items.length);\n      expect(dropZones[0].children.length).to.equal(0);\n      expect(dropZones[1].children.length).to.equal(0);\n    });\n\n    it('does not move other items', () => {\n      triggerDragEvents(items[0], dropZones[0]);\n      triggerDragEvents(items[1], dropZones[0]);\n      triggerDragEvents(items[2], dropZones[1]);\n      items[1].dispatchEvent(new window.MouseEvent('dblclick'));\n\n      expect(items[0].parentNode).to.equal(dropZones[0]);\n      expect(items[1].parentNode).to.equal(dropZones[dropZones.length - 1]);\n      expect(items[2].parentNode).to.equal(dropZones[1]);\n    });\n\n    it('has no effect on items already in the unranked zone', () => {\n      const originalOrder = [...dropZones[dropZones.length - 1].children];\n      items[1].dispatchEvent(new window.MouseEvent('dblclick'));\n      items[2].dispatchEvent(new window.MouseEvent('dblclick'));\n      items[0].dispatchEvent(new window.MouseEvent('dblclick'));\n      expect([...dropZones[dropZones.length - 1].children]).to.deep.equal(originalOrder);\n    });\n  });\n});\n"
        },
        "testStrategy": "MOCHA",
        "uid": "tier-list",
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 0,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "660763827"
        }
    },
    "difficulty": null,
    "instructor": "Conner Ardman",
    "name": "Tier List",
    "releaseDate": "2021-12-28T00:00:00Z",
    "type": "CODING_FRONTEND",
    "uid": "tier-list"
}