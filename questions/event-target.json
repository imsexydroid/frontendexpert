{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "JavaScript",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "assessmentSummary": null,
        "category": "JavaScript",
        "changelog": [],
        "customInputVars": [],
        "difficulty": 0,
        "hints": [
            "<p>\n  What information does the <span>dispatchEvent</span> method need to dispatch an event?\n  What would be the most appropriate data structure for this information?\n</p>\n",
            "\n<p>It can be helpful to keep a mapping from event names to the associated callback functions.</p>\n",
            "\n<p>\n  The <span>hasOwnProperty</span> method can be used to check if an object contains a property.\n  This is safer than the <span>in</span> keyword, because it won't accidently look at inherited properties.\n  For example, <span>obj.hasOwnProperty('foo')</span> would return <span>true</span> if <span>foo</span>\n  is a property of <span>obj</span>.\n</p>"
        ],
        "isLongOutput": false,
        "isSlowExecution": false,
        "jsonTests": [],
        "languagesSupported": [
            "javascript"
        ],
        "name": "Event Target",
        "notes": "",
        "prompt": "<div class=\"html\">\n  <p>\n    Implement an <span>EventTarget</span> class (similar to the\n    <a\n      class=\"Link Link--fe\"\n      href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\"\n      target=\"_blank\"\n      >EventTarget</a\n    >\n    interface of the DOM), which keeps track of event listeners and dispatches\n    events.\n  </p>\n  <p>\n    Your <span>EventTarget</span> class should have the following three methods:\n  </p>\n  <ol>\n    <li>\n      <p>\n        <span>addEventListener</span>\n      </p>\n      <p>\n        This function takes in two arguments: the name of an event as a string\n        and a callback function, to be called when the event is dispatched to\n        the target.\n      </p>\n      <p>\n        For example,\n        <span>target.addEventListener('click', onClick)</span> should make it\n        such that the <span>onClick</span> callback is called when the\n        <span>'click'</span> event is dispatched to the <span>target</span>.\n      </p>\n      <p style=\"margin: 0 0 10px 0\">\n        A target should be able to have multiple event listeners for the same\n        event (for example, <span>onClick1</span> and <span>onClick2</span>,\n        both attached to the <span>'click'</span> event). However, adding the\n        same exact event listener twice (with the same event and the same\n        callback) should have no effect.\n      </p>\n    </li>\n    <li>\n      <p>\n        <span>removeEventListener</span>\n      </p>\n      <p>\n        This function takes in the same arguments as\n        <span>addEventListener</span> and removes the relevant event listener.\n      </p>\n      <p>\n        For example,\n        <span>target.removeEventListener('click', onClick)</span> should undo\n        the effects of the <span>addEventListener</span> call in the bullet\n        point above.\n      </p>\n      <p style=\"margin: 0 0 10px 0\">\n        If there's no current event listener for the passed-in arguments,\n        <span>removeEventListener</span> should have no effect. Also, if two\n        different callbacks have been added for the same\n        <span>'click'</span> event (e.g., <span>onClick1</span> and\n        <span>onClick2</span>), removing one shouldn't remove the other.\n      </p>\n    </li>\n    <li>\n      <p>\n        <span>dispatchEvent</span>\n      </p>\n      <p>\n        This function takes in the name of an event as a string. If there are no\n        event listeners for that event, nothing should happen. Otherwise, event\n        listeners that do exist for that event should have their callback\n        functions invoked.\n      </p>\n      <p>\n        For example, given the event listener added in the first bullet point\n        and assuming it hadn't been removed,\n        <span>dispatchEvent('click')</span> would call <span>onClick</span>.\n      </p>\n      <p style=\"margin: 0 0 10px 0\">\n        Events can be dispatched multiple times, and each time, every associated\n        callback should be invoked.\n      </p>\n    </li>\n  </ol>\n  <p>\n    Note that different event targets should be completely isolated from one\n    another. In other words, if we had two event targets with the same event\n    listener, dispatching the appropriate event to one target shouldn't trigger\n    the other target.\n  </p>\n  <h3>Sample Usage</h3>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -10px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">const target = new EventTarget();\nconst logHello = () => console.log('hello');\nconst logWorld = () => console.log('world');\n\ntarget.addEventListener('hello', logHello);\ntarget.addEventListener('world', logWorld);\n\ntarget.dispatchEvent('hello');\ntarget.dispatchEvent('world');\n\ntarget.removeEventListener('hello', logHello);\n\ntarget.dispatchEvent('hello');\ntarget.dispatchEvent('world');</code></pre>\n</div>\n<div class=\"html\">\n  <h3>Sample Output</h3>\n  <pre>\n<span class=\"CodeEditor-promptComment\">// Console logs:</span>\nhello <span class=\"CodeEditor-promptComment\">// From the first 'hello' dispatch.</span>\nworld <span class=\"CodeEditor-promptComment\">// From the first 'world' dispatch.</span>\nworld <span class=\"CodeEditor-promptComment\">// From the second 'world' dispatch.</span>\n<span class=\"CodeEditor-promptComment\">// The second 'hello' dispatch does nothing,</span>\n<span class=\"CodeEditor-promptComment\">// because the event listener was removed</span>\n<span class=\"CodeEditor-promptComment\">// above it.</span>\n</pre>\n</div>",
        "releaseDate": "2021-05-24T00:00:00Z",
        "resources": {
            "javascript": {
                "language": "javascript",
                "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\nconst chai = require('chai');\nconst spies = require('chai-spies');\n\nchai.use(spies);\nconst spy = () => chai.spy(() => {});\nconst {expect} = chai;\n\nconst {EventTarget} = require('./program.js');\n\ndescribe('EventTarget', () => {\n  describe('single event target', () => {\n    describe('single event', () => {\n      describe('single event listener', () => {\n        it('dispatching once should work', () => {\n          const target = new EventTarget();\n          const callback = spy();\n          target.addEventListener('event', callback);\n\n          expect(callback).to.have.been.called.exactly(0);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(1);\n        });\n\n        it('dispatching multiple times should work', () => {\n          const target = new EventTarget();\n          const callback = spy();\n          target.addEventListener('event', callback);\n\n          expect(callback).to.have.been.called.exactly(0);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(1);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(2);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(3);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(4);\n        });\n\n        it('removing the event listener with the correct callback should work', () => {\n          const target = new EventTarget();\n          const callback = spy();\n          target.addEventListener('event', callback);\n\n          expect(callback).to.have.been.called.exactly(0);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(1);\n          target.removeEventListener('event', callback);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(1);\n        });\n\n        it(`removing the event listener with the incorrect callback shouldn't do anything`, () => {\n          const target = new EventTarget();\n          const callback1 = spy();\n          const callback2 = spy();\n          target.addEventListener('event', callback1);\n\n          expect(callback1).to.have.been.called.exactly(0);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(1);\n          target.removeEventListener('event', callback2);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(2);\n        });\n      });\n    });\n  });\n});\n",
                "solutions": [
                    "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nclass EventTarget {\n  constructor() {\n    this.listeners = {};\n  }\n\n  addEventListener(name, callback) {\n    if (!this.listeners.hasOwnProperty(name)) {\n      this.listeners[name] = new Set([callback]);\n    } else {\n      this.listeners[name].add(callback);\n    }\n  }\n\n  removeEventListener(name, callback) {\n    this.listeners[name]?.delete(callback);\n  }\n\n  dispatchEvent(name) {\n    this.listeners[name]?.forEach(callback => {\n      callback();\n    });\n  }\n}\n\nexports.EventTarget = EventTarget;\n"
                ],
                "solutionsDisabled": false,
                "startingCode": "class EventTarget {\n  // Write your code here.\n\n  addEventListener(name, callback) {\n    // Write your code here.\n  }\n\n  removeEventListener(name, callback) {\n    // Write your code here.\n  }\n\n  dispatchEvent(name) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.EventTarget = EventTarget;\n",
                "unitTests": "const chai = require('chai');\nconst spies = require('chai-spies');\n\nchai.use(spies);\nconst spy = () => chai.spy(() => {});\nconst {expect} = chai;\n\nconst {EventTarget} = require('./program.js');\n\ndescribe('EventTarget', () => {\n  describe('single event target', () => {\n    describe('single event', () => {\n      describe('no event listeners', () => {\n        it(`dispatching shouldn't do anything`, () => {\n          const target = new EventTarget();\n\n          expect(() => {\n            target.dispatchEvent('event');\n          }).not.to.throw();\n        });\n      });\n\n      describe('single event listener', () => {\n        it('dispatching once should work', () => {\n          const target = new EventTarget();\n          const callback = spy();\n          target.addEventListener('event', callback);\n\n          expect(callback).to.have.been.called.exactly(0);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(1);\n        });\n\n        it('dispatching multiple times should work', () => {\n          const target = new EventTarget();\n          const callback = spy();\n          target.addEventListener('event', callback);\n\n          expect(callback).to.have.been.called.exactly(0);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(1);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(2);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(3);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(4);\n        });\n\n        it('removing the event listener with the correct callback should work', () => {\n          const target = new EventTarget();\n          const callback = spy();\n          target.addEventListener('event', callback);\n\n          expect(callback).to.have.been.called.exactly(0);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(1);\n          target.removeEventListener('event', callback);\n          target.dispatchEvent('event');\n          expect(callback).to.have.been.called.exactly(1);\n        });\n\n        it(`removing the event listener with the incorrect callback shouldn't do anything`, () => {\n          const target = new EventTarget();\n          const callback1 = spy();\n          const callback2 = spy();\n          target.addEventListener('event', callback1);\n\n          expect(callback1).to.have.been.called.exactly(0);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(1);\n          target.removeEventListener('event', callback2);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(2);\n        });\n      });\n\n      describe('multiple event listeners', () => {\n        it('dispatching once should work', () => {\n          const target = new EventTarget();\n          const callback1 = spy();\n          const callback2 = spy();\n          target.addEventListener('event', callback1);\n          target.addEventListener('event', callback2);\n\n          expect(callback1).to.have.been.called.exactly(0);\n          expect(callback2).to.have.been.called.exactly(0);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(1);\n          expect(callback2).to.have.been.called.exactly(1);\n        });\n\n        it('dispatching multiple times should work', () => {\n          const target = new EventTarget();\n          const callback1 = spy();\n          const callback2 = spy();\n          target.addEventListener('event', callback1);\n          target.addEventListener('event', callback2);\n\n          expect(callback1).to.have.been.called.exactly(0);\n          expect(callback2).to.have.been.called.exactly(0);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(1);\n          expect(callback2).to.have.been.called.exactly(1);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(2);\n          expect(callback2).to.have.been.called.exactly(2);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(3);\n          expect(callback2).to.have.been.called.exactly(3);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(4);\n          expect(callback2).to.have.been.called.exactly(4);\n        });\n\n        it(`removing one event listener should work and shouldn't affect the other`, () => {\n          const target = new EventTarget();\n          const callback1 = spy();\n          const callback2 = spy();\n          target.addEventListener('event', callback1);\n          target.addEventListener('event', callback2);\n\n          expect(callback1).to.have.been.called.exactly(0);\n          expect(callback2).to.have.been.called.exactly(0);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(1);\n          expect(callback2).to.have.been.called.exactly(1);\n          target.removeEventListener('event', callback1);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(1);\n          expect(callback2).to.have.been.called.exactly(2);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(1);\n          expect(callback2).to.have.been.called.exactly(3);\n          target.dispatchEvent('event');\n          expect(callback1).to.have.been.called.exactly(1);\n          expect(callback2).to.have.been.called.exactly(4);\n        });\n      });\n    });\n\n    describe('multiple events', () => {\n      describe('with different callbacks', () => {\n        it(`dispatching one event shouldn't affect the other`, () => {\n          const target = new EventTarget();\n          const callback1 = spy();\n          const callback2 = spy();\n          target.addEventListener('event1', callback1);\n          target.addEventListener('event2', callback2);\n\n          expect(callback1).to.have.been.called.exactly(0);\n          expect(callback2).to.have.been.called.exactly(0);\n          target.dispatchEvent('event1');\n          expect(callback1).to.have.been.called.exactly(1);\n          expect(callback2).to.have.been.called.exactly(0);\n          target.dispatchEvent('event2');\n          expect(callback1).to.have.been.called.exactly(1);\n          expect(callback2).to.have.been.called.exactly(1);\n        });\n\n        it('dispatching multiple times should work', () => {\n          const target = new EventTarget();\n          const callback1 = spy();\n          const callback2 = spy();\n          target.addEventListener('event1', callback1);\n          target.addEventListener('event2', callback2);\n\n          for (let i = 0; i < 10; i++) {\n            expect(callback1).to.have.been.called.exactly(i);\n            expect(callback2).to.have.been.called.exactly(0);\n            target.dispatchEvent('event1');\n          }\n\n          for (let i = 0; i < 10; i++) {\n            expect(callback1).to.have.been.called.exactly(10);\n            expect(callback2).to.have.been.called.exactly(i);\n            target.dispatchEvent('event2');\n          }\n        });\n\n        it(`removing one event shouldn't affect the other`, () => {\n          const target = new EventTarget();\n          const callback1 = spy();\n          const callback2 = spy();\n          target.addEventListener('event1', callback1);\n          target.addEventListener('event2', callback2);\n          target.removeEventListener('event2', callback2);\n\n          target.dispatchEvent('event1');\n          expect(callback1).to.have.been.called.exactly(1);\n          expect(callback2).to.have.been.called.exactly(0);\n          target.dispatchEvent('event1');\n          expect(callback1).to.have.been.called.exactly(2);\n          expect(callback2).to.have.been.called.exactly(0);\n          target.dispatchEvent('event2');\n          expect(callback1).to.have.been.called.exactly(2);\n          expect(callback2).to.have.been.called.exactly(0);\n        });\n      });\n\n      describe('with the same callback', () => {\n        it('dispatching should work', () => {\n          const target = new EventTarget();\n          const callback = spy();\n          target.addEventListener('event1', callback);\n          target.addEventListener('event2', callback);\n\n          expect(callback).to.have.been.called.exactly(0);\n          target.dispatchEvent('event1');\n          expect(callback).to.have.been.called.exactly(1);\n          target.dispatchEvent('event2');\n          expect(callback).to.have.been.called.exactly(2);\n        });\n\n        it(`removing one event shouldn't affect the other`, () => {\n          const target = new EventTarget();\n          const callback = spy();\n          target.addEventListener('event1', callback);\n          target.addEventListener('event2', callback);\n          target.removeEventListener('event2', callback);\n\n          expect(callback).to.have.been.called.exactly(0);\n          target.dispatchEvent('event1');\n          expect(callback).to.have.been.called.exactly(1);\n          target.dispatchEvent('event2');\n          expect(callback).to.have.been.called.exactly(1);\n        });\n      });\n    });\n  });\n\n  describe('multiple event targets', () => {\n    it('dispatching a shared event to one target shouldn`t affect the other', () => {\n      const target1 = new EventTarget();\n      const target2 = new EventTarget();\n      const callback1 = spy();\n      const callback2 = spy();\n      target1.addEventListener('event', callback1);\n      target2.addEventListener('event', callback2);\n\n      expect(callback1).to.have.been.called.exactly(0);\n      expect(callback2).to.have.been.called.exactly(0);\n      target1.dispatchEvent('event');\n      expect(callback1).to.have.been.called.exactly(1);\n      expect(callback2).to.have.been.called.exactly(0);\n      target2.dispatchEvent('event');\n      expect(callback1).to.have.been.called.exactly(1);\n      expect(callback2).to.have.been.called.exactly(1);\n    });\n\n    it('removing a shared event listener from one target shouldn`t affect the other', () => {\n      const target1 = new EventTarget();\n      const target2 = new EventTarget();\n      const callback = spy();\n      target1.addEventListener('event', callback);\n      target2.addEventListener('event', callback);\n      target2.removeEventListener('event', callback);\n\n      expect(callback).to.have.been.called.exactly(0);\n      target1.dispatchEvent('event');\n      expect(callback).to.have.been.called.exactly(1);\n      target2.dispatchEvent('event');\n      expect(callback).to.have.been.called.exactly(1);\n    });\n  });\n});\n"
            }
        },
        "spaceTime": "",
        "submissionStatistics": {
            "correctCount": 2748,
            "failureCount": 512
        },
        "testStrategy": "SANDBOX_ONLY",
        "tests": [],
        "uid": "event-target",
        "version": 0,
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 10,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "646299861"
        },
        "visualization": {
            "inputType": null,
            "outputType": null
        }
    },
    "difficulty": 0,
    "instructor": "Conner Ardman",
    "name": "Event Target",
    "releaseDate": "2021-05-24T00:00:00Z",
    "type": "CODING_STANDARD",
    "uid": "event-target"
}