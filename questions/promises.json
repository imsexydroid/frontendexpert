{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "JavaScript",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "assessmentSummary": null,
        "category": "JavaScript",
        "changelog": [],
        "customInputVars": [],
        "difficulty": 0,
        "hints": [
            "<p>\n  You can use the <span>queueMicrotask(callback)</span> function to run a\n  callback function asynchronously after all other code completes running.\n</p>\n",
            "\n<p>\n  Try using an instance variable of an array to keep track of any callbacks\n  passed to <span>then</span> or <span>catch</span> that need to be run in the\n  future.\n</p>"
        ],
        "isLongOutput": false,
        "isSlowExecution": false,
        "jsonTests": [],
        "languagesSupported": [
            "javascript"
        ],
        "name": "Promises",
        "notes": "",
        "prompt": "<div class=\"html\">\n  <p>\n    Write a <span>MyPromise</span> class based on the native\n    <a\n      class=\"Link Link--fe\"\n      href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"\n      target=\"_blank\"\n      >Promise</a\n    >\n    built-in class.\n  </p>\n\n  <p>\n    An instance of the <span>MyPromise</span> class will always have one of\n    three states: <span>'pending'</span>, <span>'fulfilled'</span>, or\n    <span>'rejected'</span>. This state should be accessible through the\n    <span>state</span> getter method.\n  </p>\n\n  <p>\n    When a <span>MyPromise</span> is in the fulfilled or rejected state, it will\n    have a value which should be accessible through the\n    <span>value</span> getter method. A pending promise should always have the\n    value of <span>null</span>.\n  </p>\n\n  <p>\n    The <span>MyPromise</span> constructor takes in an executor function, which\n    takes two callbacks: <span>resolve</span> and <span>reject</span>. This\n    executor function should run immediately. Both of the callbacks passed to\n    the executor function take in a value, which when called will set the value\n    of the <span>MyPromise</span> as well as update the state based on which\n    callback was called (<span>resolve</span> sets it to fulfilled, while\n    <span>reject</span> sets it to rejected). If the executor function throws an\n    error, the <span>MyPromise</span> should be rejected with the error value.\n    For simplicity, you can assume only one of these callbacks will ever be\n    called, and it will never be called more than once.\n  </p>\n\n  <p>\n    An instance of the <span>MyPromise</span> class should have two public\n    methods: <span>then</span> and <span>catch</span> with the following\n    functionality:\n  </p>\n\n  <ul>\n    <li>\n      <span>then(onFulfilled, onRejected)</span>: Runs one of the callbacks\n      after the <span>MyPromise</span> has settled. If the\n      <span>MyPromise</span> is fulfilled, the value should be passed to the\n      <span>onFulfilled</span> callback. If the <span>MyPromise</span> is\n      rejected, the value should be passed to the\n      <span>onRejected</span> callback. The <span>then</span> method should\n      return a new <span>MyPromise</span> that resolves to the value as returned\n      by either <span>onFulfilled</span> or <span>onRejected</span>. If either\n      <span>onFulfilled</span> or <span>onRejected</span> throws an error, the\n      returned <span>MyPromise</span> should be rejected with that error value.\n    </li>\n    <li>\n      <span>catch(onRejected)</span>: Runs the <span>onRejected</span> callback\n      after the <span>MyPromise</span> has been rejected. The value should be\n      passed to the <span>onRejected</span> callback. The\n      <span>catch</span> method should return a new <span>MyPromise</span> that\n      resolves to the value returned by <span>onRejected</span>. If\n      <span>onRejected</span> throws an error, the returned\n      <span>MyPromise</span> should be rejected with that error value.\n    </li>\n  </ul>\n\n  <p>\n    Both <span>then</span> and <span>catch</span> return new\n    <span>MyPromise</span>\n    objects, meaning these methods should be chainable with the next call in the\n    chain not running until the previous call completes. None of these callbacks\n    should run until all other code in the call stack completes (i.e. they\n    should be treated as microtasks by the event loop).\n  </p>\n\n  <p>\n    If multiple calls to <span>then</span> and/or <span>catch</span> are made on\n    the same <span>MyPromise</span>, their callback functions should be invoked\n    in the order that <span>then</span> and <span>catch</span> were called (see\n    sample usage #2).\n  </p>\n\n  <p>\n    All of the callback functions to <span>then</span> and\n    <span>catch</span> are optional. If the required callback is not passed, a\n    new <span>MyPromise</span>\n    should be returned with the previous value and state.\n  </p>\n\n  <p>\n    Your code should not use the native <span>Promise</span> object in any way.\n  </p>\n\n  <h3>Sample Usage #1</h3>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -10px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">const promise = new MyPromise((res, rej) => {\n  res(10);\n});\npromise.then(val => {\n  console.log(val);\n  return val + 10;\n}).then(val => {\n  console.log(val);\n  throw val + 10;\n}).then(val => {\n  console.log(val);\n  return val + 10;\n}, val => {\n  console.log('error: ' + val);\n  return val + 20;\n}).then(val => {\n  console.log(val);\n  throw val + 10;\n}).catch(val => {\n  console.log('error: ' + val);\n  return val + 10;\n}).then(val => {\n  console.log(val);\n});\nconsole.log('end'); // this line runs before the then/catch chain.</code></pre>\n</div>\n<div class=\"html\">\n  <h3>Sample Output #1</h3>\n  <pre>\n<span class=\"CodeEditor-promptComment\">// Console logs:</span>\nend\n10\n20\nerror: 30\n50\nerror: 60\n70\n</pre>\n\n  <h3>Sample Usage #2</h3>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -10px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">const promise = new MyPromise((res, rej) => {\n  res(10);\n});\n\npromise.then(val => {\n  console.log(val + 10);\n  return val + 10;\n});\n\npromise.then(val => {\n  console.log(val + 5);\n  return val + 5;\n});\n\nconsole.log('end'); // this line runs before the then/catch chain.</code></pre>\n</div>\n<div class=\"html\">\n  <h3>Sample Output #2</h3>\n  <pre>\n<span class=\"CodeEditor-promptComment\">// Console logs:</span>\nend\n20\n15\n</pre>\n</div>",
        "releaseDate": "2022-07-01T00:00:00Z",
        "resources": {
            "javascript": {
                "language": "javascript",
                "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\nconst chai = require('chai');\nconst {expect} = chai;\n\nconst {MyPromise} = require('./program.js');\n\nconst triggerAsyncBehavior = async () => {\n  await new Promise(setImmediate);\n};\n\ndescribe('promises', () => {\n  it('is initially pending', () => {\n    const promise = new MyPromise((res, rej) => {});\n    expect(promise.state).to.equal('pending');\n  });\n\n  it('can be resolved to a value', () => {\n    const promise = new MyPromise((res, rej) => {\n      res(10);\n    });\n    expect(promise.state).to.equal('fulfilled');\n    expect(promise.value).to.equal(10);\n  });\n\n  it('then is called after resolving', async () => {\n    let resolvedVal;\n    const promise = new MyPromise((res, rej) => {\n      res(10);\n    }).then(val => {\n      resolvedVal = val;\n    });\n    await triggerAsyncBehavior();\n    expect(resolvedVal).to.equal(10);\n  });\n});\n",
                "solutions": [
                    "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nconst STATE = {\n  PENDING: 'pending',\n  FULFILLED: 'fulfilled',\n  REJECTED: 'rejected',\n};\n\nclass MyPromise {\n  #state = STATE.PENDING;\n  #value = null;\n  #fulfilledCallbacks = [];\n  #rejectedCallbacks = [];\n\n  constructor(executorFunc) {\n    try {\n      executorFunc(\n        value => this.#resolve(value),\n        value => this.#reject(value),\n      );\n    } catch (error) {\n      this.#reject(error);\n    }\n  }\n\n  then(onFulfilled, onRejected) {\n    return new MyPromise((resolve, reject) => {\n      const fulfilledCallback = () => {\n        if (!onFulfilled) return resolve(this.#value);\n\n        queueMicrotask(() => {\n          try {\n            const value = onFulfilled(this.#value);\n            resolve(value);\n          } catch (error) {\n            reject(error);\n          }\n        });\n      };\n\n      const rejectedCallback = () => {\n        if (!onRejected) return reject(this.#value);\n\n        queueMicrotask(() => {\n          try {\n            const value = onRejected(this.#value);\n            resolve(value);\n          } catch (error) {\n            reject(error);\n          }\n        });\n      };\n\n      switch (this.#state) {\n        case STATE.PENDING:\n          this.#fulfilledCallbacks.push(fulfilledCallback);\n          this.#rejectedCallbacks.push(rejectedCallback);\n          break;\n        case STATE.FULFILLED:\n          fulfilledCallback();\n          break;\n        case STATE.REJECTED:\n          rejectedCallback();\n          break;\n        default:\n          throw new Error('Unexpected promise state');\n      }\n    });\n  }\n\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n\n  get state() {\n    return this.#state;\n  }\n\n  get value() {\n    return this.#value;\n  }\n\n  #resolve(value) {\n    this.#value = value;\n    this.#state = STATE.FULFILLED;\n    this.#fulfilledCallbacks.forEach(callback => callback());\n  }\n\n  #reject(value) {\n    this.#value = value;\n    this.#state = STATE.REJECTED;\n    this.#rejectedCallbacks.forEach(callback => callback());\n  }\n}\n\n// Do not edit the line below.\nexports.MyPromise = MyPromise;\n"
                ],
                "solutionsDisabled": false,
                "startingCode": "class MyPromise {\n  // Write your code here.\n\n  constructor(executorFunc) {\n    // Write your code here.\n  }\n\n  then(onFulfilled, onRejected) {\n    // Write your code here.\n  }\n\n  catch(onRejected) {\n    // Write your code here.\n  }\n\n  get state() {\n    // Write your code here.\n  }\n\n  get value() {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.MyPromise = MyPromise;\n",
                "unitTests": "const chai = require('chai');\nconst spies = require('chai-spies');\nconst {MyPromise} = require('./program.js');\nconst {expect} = chai;\n\nconst triggerAsyncBehavior = async () => {\n  await new Promise(setImmediate);\n};\n\ndescribe('promises', () => {\n  it('is initially pending', () => {\n    const promise = new MyPromise((res, rej) => {});\n    expect(promise.state).to.equal('pending');\n  });\n\n  it('can be resolved to a value', () => {\n    const promise = new MyPromise((res, rej) => {\n      res(10);\n    });\n    expect(promise.state).to.equal('fulfilled');\n    expect(promise.value).to.equal(10);\n  });\n\n  it('can be rejected to a value', () => {\n    const promise = new MyPromise((res, rej) => {\n      rej(10);\n    });\n    expect(promise.state).to.equal('rejected');\n    expect(promise.value).to.equal(10);\n  });\n\n  it('throwing an error in executor rejects the promise with thrown value', () => {\n    const promise = new MyPromise((res, rej) => {\n      throw 'my error';\n    });\n    expect(promise.state).to.equal('rejected');\n    expect(promise.value).to.equal('my error');\n  });\n\n  it('then is called after resolving', async () => {\n    let resolvedVal;\n    const promise = new MyPromise((res, rej) => {\n      res(10);\n    }).then(val => {\n      resolvedVal = val;\n    });\n    await triggerAsyncBehavior();\n    expect(resolvedVal).to.equal(10);\n  });\n\n  it('then is called after rejecting', async () => {\n    let resolvedVal;\n    let rejectedVal;\n    const promise = new MyPromise((res, rej) => {\n      rej(10);\n    }).then(\n      val => {\n        resolvedVal = val;\n      },\n      val => {\n        rejectedVal = val;\n      },\n    );\n    await triggerAsyncBehavior();\n    expect(resolvedVal).to.be.undefined;\n    expect(rejectedVal).to.equal(10);\n  });\n\n  it('then is called asynchronously', async () => {\n    let resolvedVal;\n    const promise = new MyPromise((res, rej) => {\n      res(10);\n    }).then(val => {\n      resolvedVal = val;\n    });\n    expect(resolvedVal).to.be.undefined;\n    await triggerAsyncBehavior();\n    expect(resolvedVal).to.equal(10);\n  });\n\n  it('catch is called after rejecting', async () => {\n    let resolvedVal;\n    let rejectedVal;\n    const promise = new MyPromise((res, rej) => {\n      rej(10);\n    })\n      .then(val => {\n        resolvedVal = val;\n      })\n      .catch(val => {\n        rejectedVal = val;\n      });\n    await triggerAsyncBehavior();\n    expect(resolvedVal).to.be.undefined;\n    expect(rejectedVal).to.equal(10);\n  });\n\n  it('catch is called asynchronously', async () => {\n    let rejectedVal;\n    const promise = new MyPromise((res, rej) => {\n      rej(10);\n    }).catch(val => {\n      rejectedVal = val;\n    });\n    expect(rejectedVal).to.be.undefined;\n    await triggerAsyncBehavior();\n    expect(rejectedVal).to.equal(10);\n  });\n\n  it('then can be chained', async () => {\n    let resolvedVals = [];\n    const promise = new MyPromise((res, rej) => {\n      res(10);\n    })\n      .then(val => {\n        resolvedVals.push(val);\n        return 15;\n      })\n      .then(val => {\n        resolvedVals.push(val);\n        return 20;\n      })\n      .then(val => {\n        resolvedVals.push(val);\n      });\n\n    await triggerAsyncBehavior();\n    expect(resolvedVals).to.deep.equal([10, 15, 20]);\n  });\n\n  it('then and catch can be chained together', async () => {\n    let resolvedVals = [];\n    let rejectedVals = [];\n    const promise = new MyPromise((res, rej) => {\n      res(10);\n    })\n      .then(val => {\n        resolvedVals.push(val);\n        return 15;\n      })\n      .then(val => {\n        resolvedVals.push(val);\n        throw 20;\n      })\n      .catch(val => {\n        rejectedVals.push(val);\n        return 25;\n      })\n      .then(\n        val => {\n          resolvedVals.push(val);\n        },\n        val => {\n          rejectedVals.push(val);\n        },\n      );\n\n    await triggerAsyncBehavior();\n    expect(resolvedVals).to.deep.equal([10, 15, 25]);\n    expect(rejectedVals).to.deep.equal([20]);\n  });\n\n  it('throwing an error in a then callback rejects the promise', async () => {\n    let rejectedVal;\n    const promise = new MyPromise((res, rej) => {\n      res(10);\n    })\n      .then(val => {\n        throw val * 2;\n      })\n      .catch(val => {\n        rejectedVal = val;\n      });\n\n    await triggerAsyncBehavior();\n    expect(rejectedVal).to.equal(20);\n  });\n\n  it('throwing an error in a catch callback rejects the promise', async () => {\n    let rejectedVal;\n    const promise = new MyPromise((res, rej) => {\n      rej(10);\n    })\n      .catch(val => {\n        throw val * 2;\n      })\n      .catch(val => {\n        rejectedVal = val;\n      });\n\n    await triggerAsyncBehavior();\n    expect(rejectedVal).to.equal(20);\n  });\n\n  it('then without callbacks can be passed through', async () => {\n    let resolvedVal;\n    const promise = new MyPromise((res, rej) => {\n      res(10);\n    })\n      .then()\n      .then(val => {\n        resolvedVal = val;\n      });\n\n    await triggerAsyncBehavior();\n    expect(resolvedVal).to.equal(10);\n  });\n\n  it('then can be called multiple times on the same promise', async () => {\n    let resolvedVals = [];\n    const promise = new MyPromise((res, rej) => {\n      res(10);\n    });\n\n    promise.then(val => {\n      resolvedVals.push(val);\n    });\n    promise.then(val => {\n      resolvedVals.push(val * 2);\n    });\n\n    await triggerAsyncBehavior();\n    expect(resolvedVals).to.deep.equal([10, 20]);\n  });\n\n  it('catch without callbacks can be passed through', async () => {\n    let rejectedVal;\n    const promise = new MyPromise((res, rej) => {\n      rej(10);\n    })\n      .catch()\n      .catch(val => {\n        rejectedVal = val;\n      });\n\n    await triggerAsyncBehavior();\n    expect(rejectedVal).to.equal(10);\n  });\n\n  it('chained callbacks are not called until previous one returns', async () => {\n    let resolve;\n    let resolvedVal;\n    const promise = new MyPromise((res, rej) => {\n      resolve = res;\n    }).then(val => {\n      resolvedVal = val;\n    });\n    await triggerAsyncBehavior();\n    expect(resolvedVal).to.equal(undefined);\n    resolve(5);\n    await triggerAsyncBehavior();\n    expect(resolvedVal).to.equal(5);\n  });\n\n  it('does not use native Promise object', () => {\n    function throwAttemptedToUsePromise() {\n      throw new Error('Attempted to use native Promise');\n    }\n\n    Promise = throwAttemptedToUsePromise;\n    Promise.resolve = throwAttemptedToUsePromise;\n    Promise.reject = throwAttemptedToUsePromise;\n    const promise = new MyPromise((res, rej) => {\n      res(10);\n    })\n      .then(val => val * 2)\n      .then(val => {\n        throw val;\n      })\n      .catch(val => {});\n  });\n});\n"
            }
        },
        "spaceTime": "",
        "submissionStatistics": {
            "correctCount": 746,
            "failureCount": 416
        },
        "testStrategy": "SANDBOX_ONLY",
        "tests": [],
        "uid": "promises",
        "version": 0,
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 0,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "725812184"
        },
        "visualization": {
            "inputType": null,
            "outputType": null
        }
    },
    "difficulty": 0,
    "instructor": "Conner Ardman",
    "name": "Promises",
    "releaseDate": "2022-07-01T00:00:00Z",
    "type": "CODING_STANDARD",
    "uid": "promises"
}