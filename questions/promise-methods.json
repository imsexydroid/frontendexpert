{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "JavaScript",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "assessmentSummary": null,
        "category": "JavaScript",
        "changelog": [],
        "customInputVars": [],
        "difficulty": 0,
        "hints": [
            "<p>\n  Each of these methods should return a new Promise, so the bulk of your code\n  should be written inside of executor functions for those Promises.\n</p>\n",
            "\n<p>\n  A Promise can be created with the Promise constructor, which takes in an\n  executor function (which itself takes in resolve and reject functions). For\n  example <span>new Promise((resolve, reject) => { resolve(5); })</span>\n</p>\n",
            "\n<p>\n  You can add <span>then</span> and <span>catch</span> chains to the Promises\n  to run code after they settle.\n</p>"
        ],
        "isLongOutput": false,
        "isSlowExecution": false,
        "jsonTests": [],
        "languagesSupported": [
            "javascript"
        ],
        "name": "Promise Methods",
        "notes": "",
        "prompt": "<div class=\"html\">\n  <p>\n    Without calling <span>Promise.race()</span>,\n    <span>Promise.any()</span>,\n    <span>Promise.all()</span>,\n    <span>Promise.allSettled()</span>, implement the following four\n    similar functions on the native <span>Promise</span> object:\n  </p>\n  <ol>\n    <li>\n      <span>myRace(promises)</span>: Takes in an array of Promises and returns\n      a new Promise. This new Promise should resolve or reject as soon as any\n      Promise in the array resolves or rejects, with the value from that settled\n      Promise.\n    </li>\n    <li>\n      <span>myAny(promises)</span>: Takes in an array of Promises and returns\n      a new Promise. This new Promise should resolve as soon as any\n      Promise in the array resolves, with the value from that resolved\n      Promise. If every Promise in the array rejects, the new Promise should\n      reject with the string \"all promises rejected\".\n    </li>\n    <li>\n      <span>myAll(promises)</span>: Takes in an array of Promises and returns\n      a new Promise. This new Promise should resolve as soon as every\n      Promise in the array resolves, with an array of the values from those\n      resolved Promises. This array should be in the same order as they were\n      passed to <span>myAll</span> (not in the order they resolved). If any\n      Promise in the array rejects, the new Promise should immediately be rejected\n      with that value.\n    </li>\n    <li>\n      <span>myAllSettled(promises)</span>: Takes in an array of Promises and returns\n      a new Promise. This new Promise should resolve as soon as every Promise in\n      the array settles, with an array of objects detailing the results of each\n      Promise. Each of these objects should have a \"status\" key set to either\n      \"fulfilled\" or \"rejected\", based on the state of the Promise. If the Promise\n      was fulfilled, there should also be a \"value\" key set to the value from that\n      resolved Promise. If the Promise was rejected, there should be an \"error\"\n      key set to the error the Promise was rejected with. This array should be\n      in the same order as they were passed to <span>myAllSettled</span> (not\n      in the order they resolved).\n    </li>\n  </ol>\n  <p>\n    For simplicity, you can assume the arrays of Promises passed to these functions\n    will never be empty.\n  </p>\n  <h3>Sample Usage</h3>\n</div>\n<div class=\"code-wrapper prism\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">Promise.myRace([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.resolve(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log).catch((error) => console.log('error: ' + error));\n\nPromise.myRace([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.reject(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log).catch((error) => console.log('error: ' + error));\n\nPromise.myAny([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.resolve(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log);\n\nPromise.myAny([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.reject(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log).catch((error) => console.log('error: ' + error));\n\nPromise.myAll([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.resolve(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log);\n\nPromise.myAll([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.reject(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log).catch((error) => console.log('error: ' + error));\n\nPromise.myAllSettled([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.resolve(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log);\n\nPromise.myAllSettled([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.reject(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log).catch((error) => console.log('error: ' + error));</code></pre>\n</div>\n<div class=\"html\">\n  <h3>Sample Output</h3>\n  <pre>\n<span class=\"CodeEditor-promptComment\">// Console logs:</span>\n5 <span class=\"CodeEditor-promptComment\">// From myRace.</span>\nerror: 5 <span class=\"CodeEditor-promptComment\">// From myRace.</span>\n5 <span class=\"CodeEditor-promptComment\">// From myAny.</span>\n0 <span class=\"CodeEditor-promptComment\">// From myAny.</span>\n[0, 5, 10] <span class=\"CodeEditor-promptComment\">// From myAll after 1 second.</span>\nerror: 5 <span class=\"CodeEditor-promptComment\">// From myAll.</span>\n[\n  {status: 'fulfilled', value: 0},\n  {status: 'fulfilled', value: 5},\n  {status: 'fulfilled', value: 10,\n] <span class=\"CodeEditor-promptComment\">// From myAllSettled after 1 second.</span>\n[\n  {status: 'fulfilled', value: 0},\n  {status: 'rejected', error: 5}, \n  {status: 'fulfilled', value: 10,\n] <span class=\"CodeEditor-promptComment\">// From myAllSettled after 1 second.</span>\n</pre>\n</div>",
        "releaseDate": "2022-07-01T00:00:00Z",
        "resources": {
            "javascript": {
                "language": "javascript",
                "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\nconst chai = require('chai');\nconst spies = require('chai-spies');\n\nchai.use(spies);\nconst spy = func => chai.spy(func ? func : () => {});\nconst {expect} = chai;\n\nrequire('./program.js');\n\ndescribe('promise methods', () => {\n  describe('myRace', () => {\n    it('resolves to first resolved value', async () => {\n      const val = await Promise.myRace([\n        new Promise(() => {}),\n        new Promise(res => setTimeout(() => res(0), 1000)),\n        new Promise((res, rej) => setTimeout(() => rej(5), 500)),\n        Promise.resolve(10),\n      ]);\n      expect(val).to.equal(10);\n    });\n\n    it(`doesn't call the native race method`, async () => {\n      chai.spy.on(Promise, 'race');\n      const val = await Promise.myRace([\n        Promise.resolve(0),\n        Promise.resolve(5),\n        Promise.resolve(10),\n      ]);\n      expect(Promise.race).to.have.been.called.exactly(0);\n      chai.spy.restore();\n    });\n  });\n\n  describe('myAny', () => {\n    it('resolves to first resolved value', async () => {\n      const val = await Promise.myAny([\n        new Promise(() => {}),\n        new Promise(res => setTimeout(() => res(0), 1000)),\n        new Promise((res, rej) => setTimeout(() => rej(5), 500)),\n        Promise.resolve(10),\n      ]);\n      expect(val).to.equal(10);\n    });\n\n    it(`doesn't call the native any method`, async () => {\n      chai.spy.on(Promise, 'any');\n      const val = await Promise.myAny([\n        Promise.resolve(0),\n        Promise.resolve(5),\n        Promise.resolve(10),\n      ]);\n      expect(Promise.any).to.have.been.called.exactly(0);\n      chai.spy.restore();\n    });\n  });\n\n  describe('myAll', () => {\n    it('resolves to array of values', async () => {\n      const val = await Promise.myAll([\n        Promise.resolve(0),\n        Promise.resolve(5),\n        Promise.resolve(10),\n      ]);\n      expect(val).to.deep.equal([0, 5, 10]);\n    });\n\n    it(`doesn't call the native all method`, async () => {\n      chai.spy.on(Promise, 'all');\n      const val = await Promise.myAll([\n        Promise.resolve(0),\n        Promise.resolve(5),\n        Promise.resolve(10),\n      ]);\n      expect(Promise.all).to.have.been.called.exactly(0);\n      chai.spy.restore();\n    });\n  });\n\n  describe('myAllSettled', () => {\n    it('resolves to array of objects', async () => {\n      const val = await Promise.myAllSettled([\n        Promise.resolve(0),\n        Promise.resolve(5),\n        Promise.resolve(10),\n      ]);\n      expect(val).to.deep.equal([\n        {status: 'fulfilled', value: 0},\n        {status: 'fulfilled', value: 5},\n        {status: 'fulfilled', value: 10},\n      ]);\n    });\n\n    it(`doesn't call the native allSettled method`, async () => {\n      chai.spy.on(Promise, 'allSettled');\n      const val = await Promise.myAllSettled([\n        Promise.resolve(0),\n        Promise.resolve(5),\n        Promise.resolve(10),\n      ]);\n      expect(Promise.allSettled).to.have.been.called.exactly(0);\n      chai.spy.restore();\n    });\n  });\n});\n",
                "solutions": [
                    "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nPromise.myRace = function (promises) {\n  return new Promise((resolve, reject) => {\n    promises.forEach(promise => {\n      promise.then(resolve).catch(reject);\n    });\n  });\n};\n\nPromise.myAny = function (promises) {\n  return new Promise((resolve, reject) => {\n    let rejectedCount = 0;\n\n    promises.forEach(promise => {\n      promise.then(resolve).catch(_ => {\n        rejectedCount++;\n        if (rejectedCount === promises.length) {\n          reject('all promises rejected');\n        }\n      });\n    });\n  });\n};\n\nPromise.myAll = function (promises) {\n  return new Promise((resolve, reject) => {\n    const results = [];\n    let resolvedCount = 0;\n\n    promises.forEach((promise, i) => {\n      promise\n        .then(value => {\n          results[i] = value;\n          resolvedCount++;\n          if (resolvedCount === promises.length) {\n            resolve(results);\n          }\n        })\n        .catch(reject);\n    });\n  });\n};\n\nPromise.myAllSettled = function (promises) {\n  return new Promise(resolve => {\n    const results = [];\n    let settledCount = 0;\n\n    promises.forEach((promise, i) => {\n      promise\n        .then(value => {\n          results[i] = {status: 'fulfilled', value};\n        })\n        .catch(error => {\n          results[i] = {status: 'rejected', error};\n        })\n        .finally(() => {\n          settledCount++;\n          if (settledCount === promises.length) {\n            resolve(results);\n          }\n        });\n    });\n  });\n};\n"
                ],
                "solutionsDisabled": false,
                "startingCode": "Promise.myRace = function (promises) {\n  // Write your code here.\n};\n\nPromise.myAny = function (promises) {\n  // Write your code here.\n};\n\nPromise.myAll = function (promises) {\n  // Write your code here.\n};\n\nPromise.myAllSettled = function (promises) {\n  // Write your code here.\n};\n",
                "unitTests": "const chai = require('chai');\nconst spies = require('chai-spies');\n\nchai.use(spies);\nconst spy = func => chai.spy(func ? func : () => {});\nconst {expect} = chai;\n\nrequire('./program.js');\n\ndescribe('promise methods', () => {\n  describe('myRace', () => {\n    it('resolves to first resolved value', async () => {\n      const val = await Promise.myRace([\n        new Promise(() => {}),\n        new Promise(res => setTimeout(() => res(0), 1000)),\n        new Promise((res, rej) => setTimeout(() => rej(5), 500)),\n        Promise.resolve(10),\n      ]);\n      expect(val).to.equal(10);\n    });\n\n    it('resolves to first rejected value', async () => {\n      try {\n        const val = await Promise.myRace([\n          new Promise(() => {}),\n          new Promise(res => setTimeout(() => res(0), 1000)),\n          new Promise((res, rej) => setTimeout(() => rej(5), 500)),\n          Promise.reject(10),\n        ]);\n        expect('This code should be unreachable').to.be.true;\n      } catch (error) {\n        expect(error).to.equal(10);\n      }\n    });\n\n    it(`doesn't resolve if all promises are left pending`, async () => {\n      let returnedVal;\n      const promise = Promise.myRace([\n        new Promise(() => {}),\n        new Promise(() => {}),\n        new Promise(() => {}),\n      ]);\n      promise.then(val => {\n        returnedVal = val;\n      });\n      await new Promise(setImmediate);\n      expect(returnedVal).to.equal(undefined);\n    });\n\n    it(`doesn't call the native race method`, async () => {\n      chai.spy.on(Promise, 'race');\n      const val = await Promise.myRace([\n        Promise.resolve(0),\n        Promise.resolve(5),\n        Promise.resolve(10),\n      ]);\n      expect(Promise.race).to.have.been.called.exactly(0);\n      chai.spy.restore();\n    });\n  });\n\n  describe('myAny', () => {\n    it('resolves to first resolved value', async () => {\n      const val = await Promise.myAny([\n        new Promise(() => {}),\n        new Promise(res => setTimeout(() => res(0), 1000)),\n        new Promise((res, rej) => setTimeout(() => rej(5), 500)),\n        Promise.resolve(10),\n      ]);\n      expect(val).to.equal(10);\n    });\n\n    it('ignores first rejected promise', async () => {\n      const val = await Promise.myAny([Promise.reject(10), Promise.resolve(20)]);\n      expect(val).to.equal(20);\n    });\n\n    it('rejects if all promises reject', async () => {\n      try {\n        const val = await Promise.myAny([\n          Promise.reject(0),\n          Promise.reject(10),\n          Promise.reject(20),\n        ]);\n        expect('This code should be unreachable').to.be.true;\n      } catch (error) {\n        expect(error).to.equal('all promises rejected');\n      }\n    });\n\n    it(`doesn't resolve if all promises are left pending`, async () => {\n      let returnedVal;\n      const promise = Promise.myAny([\n        new Promise(() => {}),\n        new Promise(() => {}),\n        new Promise(() => {}),\n      ]);\n      promise.then(val => {\n        returnedVal = val;\n      });\n      await new Promise(setImmediate);\n      expect(returnedVal).to.equal(undefined);\n    });\n\n    it(`doesn't call the native any method`, async () => {\n      chai.spy.on(Promise, 'any');\n      const val = await Promise.myAny([\n        Promise.resolve(0),\n        Promise.resolve(5),\n        Promise.resolve(10),\n      ]);\n      expect(Promise.any).to.have.been.called.exactly(0);\n      chai.spy.restore();\n    });\n  });\n\n  describe('myAll', () => {\n    it('resolves to array of values', async () => {\n      const val = await Promise.myAll([\n        Promise.resolve(0),\n        Promise.resolve(5),\n        Promise.resolve(10),\n      ]);\n      expect(val).to.deep.equal([0, 5, 10]);\n    });\n\n    it('maintains correct order in output array', async () => {\n      const val = await Promise.myAll([\n        Promise.resolve(0),\n        new Promise(res => setTimeout(() => res(5), 0)),\n        Promise.resolve(10),\n      ]);\n      expect(val).to.deep.equal([0, 5, 10]);\n    });\n\n    it('rejects if any promises reject', async () => {\n      try {\n        const val = await Promise.myAll([\n          new Promise(() => {}),\n          Promise.resolve(0),\n          Promise.reject(10),\n          Promise.resolve(20),\n          Promise.reject(30),\n        ]);\n        expect('This code should be unreachable').to.be.true;\n      } catch (error) {\n        expect(error).to.equal(10);\n      }\n    });\n\n    it(`doesn't resolve if a promise is left pending`, async () => {\n      let returnedVal;\n      const promise = Promise.myAll([\n        Promise.resolve(0),\n        new Promise(() => {}),\n        Promise.resolve(10),\n      ]);\n      promise.then(val => {\n        returnedVal = val;\n      });\n      await new Promise(setImmediate);\n      expect(returnedVal).to.equal(undefined);\n    });\n\n    it(`doesn't call the native all method`, async () => {\n      chai.spy.on(Promise, 'all');\n      const val = await Promise.myAll([\n        Promise.resolve(0),\n        Promise.resolve(5),\n        Promise.resolve(10),\n      ]);\n      expect(Promise.all).to.have.been.called.exactly(0);\n      chai.spy.restore();\n    });\n  });\n\n  describe('myAllSettled', () => {\n    it('resolves to array of objects', async () => {\n      const val = await Promise.myAllSettled([\n        Promise.resolve(0),\n        Promise.resolve(5),\n        Promise.resolve(10),\n      ]);\n      expect(val).to.deep.equal([\n        {status: 'fulfilled', value: 0},\n        {status: 'fulfilled', value: 5},\n        {status: 'fulfilled', value: 10},\n      ]);\n    });\n\n    it('maintains correct order in output array', async () => {\n      const val = await Promise.myAllSettled([\n        Promise.resolve(0),\n        new Promise(res => setTimeout(() => res(5), 0)),\n        Promise.resolve(10),\n      ]);\n      expect(val).to.deep.equal([\n        {status: 'fulfilled', value: 0},\n        {status: 'fulfilled', value: 5},\n        {status: 'fulfilled', value: 10},\n      ]);\n    });\n\n    it('resolves even if the promises reject', async () => {\n      const val = await Promise.myAllSettled([\n        Promise.resolve(0),\n        Promise.reject(10),\n        Promise.resolve(20),\n        Promise.reject(30),\n      ]);\n      expect(val).to.deep.equal([\n        {status: 'fulfilled', value: 0},\n        {status: 'rejected', error: 10},\n        {status: 'fulfilled', value: 20},\n        {status: 'rejected', error: 30},\n      ]);\n    });\n\n    it(`doesn't resolve if a promise is left pending`, async () => {\n      let returnedVal;\n      const promise = Promise.myAllSettled([\n        Promise.resolve(0),\n        new Promise(() => {}),\n        Promise.resolve(10),\n      ]);\n      promise.then(val => {\n        returnedVal = val;\n      });\n      await new Promise(setImmediate);\n      expect(returnedVal).to.equal(undefined);\n    });\n\n    it(`doesn't call the native allSettled method`, async () => {\n      chai.spy.on(Promise, 'allSettled');\n      const val = await Promise.myAllSettled([\n        Promise.resolve(0),\n        Promise.resolve(5),\n        Promise.resolve(10),\n      ]);\n      expect(Promise.allSettled).to.have.been.called.exactly(0);\n      chai.spy.restore();\n    });\n  });\n});\n"
            }
        },
        "spaceTime": "",
        "submissionStatistics": {
            "correctCount": 1337,
            "failureCount": 400
        },
        "testStrategy": "SANDBOX_ONLY",
        "tests": [],
        "uid": "promise-methods",
        "version": 0,
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 0,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "721594956"
        },
        "visualization": {
            "inputType": null,
            "outputType": null
        }
    },
    "difficulty": 0,
    "instructor": "Conner Ardman",
    "name": "Promise Methods",
    "releaseDate": "2022-07-01T00:00:00Z",
    "type": "CODING_STANDARD",
    "uid": "promise-methods"
}