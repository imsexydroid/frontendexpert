{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "JavaScript",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "assessmentSummary": null,
        "category": "JavaScript",
        "changelog": [],
        "customInputVars": [],
        "difficulty": 0,
        "hints": [
            "<p>\n  To get started, try taking this problem in small steps. How would you write a\n  function that returns a new function that calls <span>callback</span> parameter?\n  Then how can you delay execution of that <span>callback</span>?\n</p>\n",
            "\n<p>\n  <span>setTimeout</span> can be used to delay execution of the <span>callback</span> function.\n  For example, <span>setTimeout(callback, 1000)</span> would call the <span>callback</span>\n  after one second.\n</p>\n",
            "\n<p>\n  <span>setTimeout</span> returns an ID that can be passed to the <span>clearTimeout</span>\n  function to stop the callback from running. This can be combined with another call to\n  <span>setTimeout</span> to reset a timeout.\n</p>\n",
            "\n<p>\n  <span>setTimeout</span> executes code in a different context, and thus it loses\n  the reference to <span>this</span> by default. How can you ensure the <span>callback</span> is\n  executed with the expected <span>this</span> context?\n</p>\n",
            "\n<p>\n  The <span>call</span> or <span>apply</span> method can be used to call a function\n  with a specific <span>this</span> context. For example,\n  <span>func.apply(obj, args)</span> would call <span>func</span> with <span>obj</span>\n  bound to <span>this</span> and the <span>args</span> array passed as arguments.\n</p>"
        ],
        "isLongOutput": false,
        "isSlowExecution": false,
        "jsonTests": [],
        "languagesSupported": [
            "javascript"
        ],
        "name": "Debounce",
        "notes": "",
        "prompt": "<div class=\"html\">\n  <p>\n    Write a <span>debounce</span> function that takes in a required\n    <span>callback</span> function, a required <span>delay</span> in\n    milliseconds, and an optional <span>immediate</span> boolean, which defaults\n    to <span>false</span>.\n  </p>\n  <p>\n    Calling <span>debounce(callback, delay)</span> should return a new\n    \"debounced\" version of the callback function, which takes in the same\n    parameters as the callback, and which, when executed, should call the\n    callback after <span>delay</span> milliseconds have passed since the last\n    call to this debounced function.\n  </p>\n  <p>\n    For example, repeatedly calling a debounced function which had a delay of\n    3000ms every second would never call the underlying callback function,\n    because the delay of 3000ms would never elapse since the last call.\n  </p>\n  <p>\n    If the <span>immediate</span> argument is <span>true</span>, then the first\n    call to the debounced function should immediately execute the underlying\n    callback function. However, the callback function shouldn't be able to\n    execute again until <span>delay</span> milliseconds have passed since the\n    last call to the debounced function.\n  </p>\n  <p>\n    In this case, repeatedly calling a debounced function which had a delay of\n    3000ms every second would call the underlying callback function once\n    immediately after the first call, and then never again, because the delay of\n    3000ms would never elapse since the last call.\n  </p>\n  <p>\n    Note that the underlying callback functions should have the\n    <span>this</span> context of the debounced-function callers. For example, in\n    the following code snippet, the underlying callback should be called with\n    the <span>this</span> context of the <span>object</span>:\n  </p>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -15px\">\n  <pre class=\"line-numbers\"><code class=\"language-javascript\">const object = {};\nobject.debounced = debounce(someCallback, 1000);\nobject.debounced();</code></pre>\n</div>\n<div class=\"html\">\n  <p>\n    You can assume that the JavaScript timing functions are accurate enough for\n    this question (no need to worry about timeouts not firing at exact times).\n  </p>\n  <h3>Sample Usage #1</h3>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -10px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">const debounced = debounce(console.log, 3000);\ndocument.addEventListener('keypress', () => debounced(currentTime));\n\n// currentTime = 0ms - user starts typing.\n// currentTime = 1000ms - user stops typing.\n// currentTime = 4000ms - 3000ms have elapsed since last keypress.\n// Callback function fires: logs the currentTime, which was 1000ms.\n// currentTime = 7000ms - user starts typing.\n// currentTime = 9000ms - user stops typing.\n// currentTime = 12000ms - 3000ms have elapsed since last keypress.\n// Callback function fires: logs the currentTime, which was 9000ms.</code></pre>\n</div>\n<div class=\"html\">\n  <h3>Sample Usage #2</h3>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -10px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">const debounced = debounce(console.log, 3000, true);\ndocument.addEventListener('keypress', () => debounced(currentTime));\n\n// currentTime = 0ms - user starts typing.\n// Callback function fires immediately: logs the currentTime, which is 0ms.\n// currentTime = 3000ms - user stops typing.\n// currentTime = 5000ms - user starts typing; 3000ms haven't elapsed since last keypress.\n// currentTime = 6000ms - user stops typing.\n// currentTime = 9000ms - user starts typing; 3000ms have elapsed since last keypress.\n// Callback function fires immediately: logs the currentTime, which is 9000ms.\n// currentTime = 12000ms - user stops typing.</code></pre>\n</div>",
        "releaseDate": "2021-05-24T00:00:00Z",
        "resources": {
            "javascript": {
                "language": "javascript",
                "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\nconst chai = require('chai');\nconst spies = require('chai-spies');\nconst FakeTimers = require('@sinonjs/fake-timers');\n\nconst clock = FakeTimers.install({\n  now: Date.now(),\n});\n\nchai.use(spies);\nconst spy = () => chai.spy(() => {});\nconst {expect} = chai;\n\nconst {debounce} = require('./program.js');\n\ndescribe('debounce', () => {\n  beforeEach(() => {\n    clock.reset();\n  });\n\n  describe('when immediate is false', () => {\n    describe('calling a debounced function once', () => {\n      describe('before the delay has elapsed', () => {\n        it(`shouldn't call the passed callback`, () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000);\n\n          debounced();\n          expect(callback).to.have.been.called.exactly(0);\n          clock.tick(999);\n          expect(callback).to.have.been.called.exactly(0);\n        });\n      });\n\n      describe('after the delay has elapsed', () => {\n        it('should call the passed callback', () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000);\n\n          debounced();\n          clock.tick(1000);\n          expect(callback).to.have.been.called.exactly(1);\n        });\n\n        it(`should call the passed callback with the call's arguments`, () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000);\n\n          debounced('foo', 'bar');\n          clock.tick(1000);\n          expect(callback).to.have.been.called.with('foo', 'bar');\n        });\n      });\n    });\n  });\n});\n",
                "solutions": [
                    "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nfunction debounce(callback, delay, immediate = false) {\n  let timerID;\n\n  return function (...args) {\n    clearTimeout(timerID);\n\n    const shouldCallImmediately = timerID == null && immediate;\n    if (shouldCallImmediately) {\n      callback.apply(this, args);\n    }\n\n    timerID = setTimeout(() => {\n      if (!immediate) {\n        callback.apply(this, args);\n      }\n      timerID = null;\n    }, delay);\n  };\n}\n\n// Do not edit the line below.\nexports.debounce = debounce;\n"
                ],
                "solutionsDisabled": false,
                "startingCode": "function debounce(callback, delay, immediate = false) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.debounce = debounce;\n",
                "unitTests": "const chai = require('chai');\nconst spies = require('chai-spies');\nconst FakeTimers = require('@sinonjs/fake-timers');\n\nconst clock = FakeTimers.install({\n  now: Date.now(),\n});\n\nchai.use(spies);\nconst spy = () => chai.spy(() => {});\nconst {expect} = chai;\n\nconst {debounce} = require('./program.js');\n\ndescribe('debounce', () => {\n  beforeEach(() => {\n    clock.reset();\n  });\n\n  describe('when immediate is false', () => {\n    describe('calling a debounced function once', () => {\n      describe('before the delay has elapsed', () => {\n        it(`shouldn't call the passed callback`, () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000);\n\n          debounced();\n          expect(callback).to.have.been.called.exactly(0);\n          clock.tick(999);\n          expect(callback).to.have.been.called.exactly(0);\n        });\n      });\n\n      describe('after the delay has elapsed', () => {\n        it('should call the passed callback', () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000);\n\n          debounced();\n          clock.tick(1000);\n          expect(callback).to.have.been.called.exactly(1);\n        });\n\n        it(`should call the passed callback with the call's arguments`, () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000);\n\n          debounced('foo', 'bar');\n          clock.tick(1000);\n          expect(callback).to.have.been.called.with('foo', 'bar');\n        });\n      });\n    });\n\n    describe('calling a debounced function multiple times', () => {\n      describe('before the delay has elapsed since the last call', () => {\n        it(`shouldn't call the passed callback`, () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000);\n\n          debounced();\n          clock.tick(500);\n          debounced();\n          clock.tick(500);\n          expect(callback).to.have.been.called.exactly(0);\n          debounced();\n          clock.tick(500);\n          expect(callback).to.have.been.called.exactly(0);\n          debounced();\n          clock.tick(500);\n          expect(callback).to.have.been.called.exactly(0);\n        });\n      });\n\n      describe('after the delay has elapsed since the last call', () => {\n        it('should call the passed callback', () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000);\n\n          debounced();\n          clock.tick(500);\n          debounced();\n          clock.tick(500);\n          debounced();\n          clock.tick(500);\n          debounced();\n          clock.tick(500);\n          expect(callback).to.have.been.called.exactly(0);\n          clock.tick(500);\n          expect(callback).to.have.been.called.exactly(1);\n        });\n\n        it(`should call the passed callback with the last call's arguments`, () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000);\n\n          debounced('foo');\n          clock.tick(500);\n          debounced('bar');\n          clock.tick(500);\n          debounced('baz');\n          clock.tick(500);\n          debounced('last call');\n          clock.tick(500);\n          clock.tick(500);\n          expect(callback).to.have.been.called.with('last call');\n        });\n      });\n    });\n  });\n\n  describe('when immediate is true', () => {\n    describe('calling a debounced function once', () => {\n      describe('before the delay has elapsed', () => {\n        it('should call the passed callback immediately', () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000, true);\n\n          debounced();\n          expect(callback).to.have.been.called.exactly(1);\n        });\n\n        it(`should call the passed callback with the call's arguments`, () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000, true);\n\n          debounced('foo', 'bar');\n          expect(callback).to.have.been.called.with('foo', 'bar');\n        });\n      });\n\n      describe('after the delay has elapsed', () => {\n        it(`shouldn't call the passed callback again`, () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000, true);\n\n          debounced();\n          debounced();\n          clock.tick(1000);\n          expect(callback).to.have.been.called.exactly(1);\n          clock.tick(1000);\n          expect(callback).to.have.been.called.exactly(1);\n        });\n      });\n    });\n\n    describe('calling a debounced function multiple times', () => {\n      describe('before the delay has elapsed since the last call', () => {\n        it('should call the passed callback once immediately', () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000, true);\n\n          debounced();\n          expect(callback).to.have.been.called.exactly(1);\n          clock.tick(500);\n          debounced();\n          clock.tick(500);\n          expect(callback).to.have.been.called.exactly(1);\n          debounced();\n          clock.tick(500);\n          expect(callback).to.have.been.called.exactly(1);\n        });\n\n        it(`should call the passed callback with the first call's arguments`, () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000, true);\n\n          debounced('first call');\n          clock.tick(500);\n          debounced('foo');\n          clock.tick(500);\n          debounced('bar');\n          clock.tick(500);\n          debounced('baz');\n          clock.tick(500);\n          clock.tick(500);\n          expect(callback).to.have.been.called.with('first call');\n        });\n      });\n\n      describe('after the delay has elapsed since the last call', () => {\n        it('should call the passed callback again immediately', () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000, true);\n\n          debounced();\n          clock.tick(500);\n          debounced();\n          clock.tick(500);\n          debounced();\n          clock.tick(500);\n          debounced();\n          clock.tick(500);\n          clock.tick(500);\n          expect(callback).to.have.been.called.exactly(1);\n          debounced();\n          expect(callback).to.have.been.called.exactly(2);\n        });\n\n        it(`should call the passed callback again with the last call's arguments`, () => {\n          const callback = spy();\n          const debounced = debounce(callback, 1000, true);\n\n          debounced('first call');\n          clock.tick(500);\n          debounced('foo');\n          clock.tick(500);\n          debounced('bar');\n          clock.tick(500);\n          debounced('baz');\n          clock.tick(500);\n          clock.tick(500);\n          expect(callback).to.have.been.called.with('first call');\n          debounced('last call');\n          expect(callback).to.have.been.called.with('last call');\n        });\n      });\n    });\n  });\n\n  describe('regardless of immediate', () => {\n    it('callbacks should have the `this` context of the debounced function caller', () => {\n      const object = {spy: spy()};\n      function callback() {\n        this.spy();\n      }\n      object.debounced = debounce(callback, 1000);\n      object.immediateDebounced = debounce(callback, 1000, true);\n\n      object.debounced();\n      clock.tick(1000);\n      expect(object.spy).to.have.been.called.exactly(1);\n      object.immediateDebounced();\n      expect(object.spy).to.have.been.called.exactly(2);\n    });\n  });\n});\n"
            }
        },
        "spaceTime": "",
        "submissionStatistics": {
            "correctCount": 2471,
            "failureCount": 942
        },
        "testStrategy": "SANDBOX_ONLY",
        "tests": [],
        "uid": "debounce",
        "version": 0,
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 11,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "647569569"
        },
        "visualization": {
            "inputType": null,
            "outputType": null
        }
    },
    "difficulty": 0,
    "instructor": "Conner Ardman",
    "name": "Debounce",
    "releaseDate": "2021-05-24T00:00:00Z",
    "type": "CODING_STANDARD",
    "uid": "debounce"
}