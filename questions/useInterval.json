{
    "acl": {
        "isAvailable": true,
        "isFree": false,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "React Hooks",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": false,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "assessmentSummary": null,
        "category": "React Hooks",
        "changelog": [],
        "customInputVars": [],
        "difficulty": 0,
        "hints": [
            "<p>\n  In order to reset the interval whenever the delay changes, try using a\n  <span>useEffect</span> to clear the previous interval and create a new one.\n</p>\n",
            "\n<p>\n  The <span>useEffect</span> hook callback function can return another function,\n  which is used as a cleanup function. This function should clear any intervals\n  to make sure they do not continue running if the component unmounts.\n</p>"
        ],
        "isLongOutput": false,
        "isSlowExecution": false,
        "jsonTests": [],
        "languagesSupported": [
            "jsx"
        ],
        "name": "useInterval",
        "notes": "",
        "prompt": "<div class=\"html\">\n  <p>\n    Write a <span>useInterval</span> custom hook that takes in a required\n    <span>callback</span> function, and an optional <span>delay</span> as a\n    number in milliseconds.\n  </p>\n\n  <p>\n    Calling <span>useInterval</span> with a <span>callback</span> and a\n    <span>delay</span> should create an interval on mount, calling the callback\n    function every <span>delay</span> milliseconds.\n  </p>\n\n  <p>\n    If the component unmounts, the interval should be cancelled. If the\n    <span>delay</span> changes, the interval should reset, not executing the\n    function until the new delay completes.\n  </p>\n\n  <p>\n    If the <span>delay</span> is ever set to <span>null</span> or\n    <span>undefined</span>, the interval should be cancelled.\n  </p>\n\n  <p>\n    If the <span>callback</span> function changes, the interval should be\n    updated to call the most recent version of the function. However,\n    this should not reset the interval.\n  </p>\n\n  <h3>Sample Usage</h3>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -10px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">const [func, setFunc] = useState(() => {\n  return () => console.log('First');\n});\nconst [delay, setDelay] = useState(2000);\nuseInterval(func, delay);\n\n// After 2 seconds: First is logged\n\n// After 1 more second:\nsetDelay(3000);\n\n// After 3 more seconds, First is logged\n\n// After 1 more second:\nsetFunc(() => {\n  return () => console.log('Second');\n});\n\n// After 2 more seconds, Second is logged\n</code></pre>\n</div>",
        "releaseDate": "2022-05-24T00:00:00Z",
        "resources": {
            "jsx": {
                "language": "jsx",
                "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nimport React, {useState} from 'react';\nimport ReactDOM from 'react-dom';\nimport {act} from 'react-dom/test-utils';\nconst {JSDOM} = require('jsdom');\nimport {useInterval} from './program';\nconst chai = require('chai');\nconst spies = require('chai-spies');\nchai.use(spies);\nconst {expect} = chai;\nconst FakeTimers = require('@sinonjs/fake-timers');\n\nlet rootContainer;\nlet nextValue;\n\nconst spy = () => chai.spy(() => {});\n\nconst clock = FakeTimers.install({\n  now: Date.now(),\n});\n\nconst resetDom = () => {\n  const dom = new JSDOM({\n    url: 'http://localhost:3000',\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n\n  for (const [key, value] of Object.entries(React)) {\n    global[key] = value;\n  }\n\n  delete require.cache[require.resolve('./program.js')];\n  require('./program.js');\n\n  rootContainer = document.createElement('div');\n  document.body.appendChild(rootContainer);\n  nextValue = undefined;\n};\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\nfunction TestComponent({callback}) {\n  const [delay, setDelay] = useState(1000);\n  useInterval(callback, delay);\n\n  return (\n    <button id=\"set-delay\" onClick={() => setDelay(nextValue)}>\n      Set Delay\n    </button>\n  );\n}\n\ndescribe('useInterval', () => {\n  beforeEach(() => {\n    resetDom();\n  });\n\n  it('callback does not run on initial mount before delay', () => {\n    const callback = spy();\n    act(() => {\n      ReactDOM.render(<TestComponent callback={callback} />, rootContainer);\n    });\n    expect(callback).to.have.been.called.exactly(0);\n    clock.tick(0);\n  });\n\n  it('runs callback on mount after initial delay', () => {\n    const callback = spy();\n    act(() => {\n      ReactDOM.render(<TestComponent callback={callback} />, rootContainer);\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n  });\n\n  it('runs callback after each delay period', () => {\n    const callback = spy();\n    act(() => {\n      ReactDOM.render(<TestComponent callback={callback} />, rootContainer);\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n    clock.tick(999);\n    expect(callback).to.have.been.called.exactly(1);\n    clock.tick(1);\n    expect(callback).to.have.been.called.exactly(2);\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(3);\n  });\n\n  it('delay can be changed', () => {\n    const callback = spy();\n    act(() => {\n      ReactDOM.render(<TestComponent callback={callback} />, rootContainer);\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n\n    nextValue = 2000;\n    act(() => {\n      document.getElementById('set-delay').click();\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(2);\n    clock.tick(2000);\n    expect(callback).to.have.been.called.exactly(3);\n    clock.tick(0);\n  });\n});\n",
                "solutions": [
                    "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nimport {useRef, useEffect} from 'react';\n\nfunction useInterval(callback, delay) {\n  const callbackRef = useRef();\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    if (delay == null) return;\n\n    const intervalID = setInterval(() => callbackRef.current(), delay);\n    return () => clearInterval(intervalID);\n  }, [delay]);\n}\n\n// Do not edit the line below.\nexports.useInterval = useInterval;\n"
                ],
                "solutionsDisabled": false,
                "startingCode": "import React from 'react';\n\nfunction useInterval(callback, delay) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.useInterval = useInterval;\n",
                "unitTests": "/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nimport React, {useState} from 'react';\nimport ReactDOM from 'react-dom';\nimport {act} from 'react-dom/test-utils';\nconst {JSDOM} = require('jsdom');\nimport {useInterval} from './program';\nconst chai = require('chai');\nconst spies = require('chai-spies');\nchai.use(spies);\nconst {expect} = chai;\nconst FakeTimers = require('@sinonjs/fake-timers');\n\nlet rootContainer;\nlet nextValue;\n\nconst spy = () => chai.spy(() => {});\n\nconst clock = FakeTimers.install({\n  now: Date.now(),\n});\n\nconst resetDom = () => {\n  const dom = new JSDOM({\n    url: 'http://localhost:3000',\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n\n  for (const [key, value] of Object.entries(React)) {\n    global[key] = value;\n  }\n\n  delete require.cache[require.resolve('./program.js')];\n  require('./program.js');\n\n  rootContainer = document.createElement('div');\n  document.body.appendChild(rootContainer);\n  nextValue = undefined;\n};\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\nfunction TestComponent({callback}) {\n  const [delay, setDelay] = useState(1000);\n  useInterval(callback, delay);\n\n  return (\n    <button id=\"set-delay\" onClick={() => setDelay(nextValue)}>\n      Set Delay\n    </button>\n  );\n}\n\ndescribe('useInterval', () => {\n  beforeEach(() => {\n    resetDom();\n  });\n\n  it('callback does not run on initial mount before delay', () => {\n    const callback = spy();\n    act(() => {\n      ReactDOM.render(<TestComponent callback={callback} />, rootContainer);\n    });\n    expect(callback).to.have.been.called.exactly(0);\n  });\n\n  it('runs callback on mount after initial delay', () => {\n    const callback = spy();\n    act(() => {\n      ReactDOM.render(<TestComponent callback={callback} />, rootContainer);\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n  });\n\n  it('runs callback after each delay period', () => {\n    const callback = spy();\n    act(() => {\n      ReactDOM.render(<TestComponent callback={callback} />, rootContainer);\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n    clock.tick(999);\n    expect(callback).to.have.been.called.exactly(1);\n    clock.tick(1);\n    expect(callback).to.have.been.called.exactly(2);\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(3);\n  });\n\n  it('delay can be changed', () => {\n    const callback = spy();\n    act(() => {\n      ReactDOM.render(<TestComponent callback={callback} />, rootContainer);\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n\n    nextValue = 2000;\n    act(() => {\n      document.getElementById('set-delay').click();\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(2);\n    clock.tick(2000);\n    expect(callback).to.have.been.called.exactly(3);\n  });\n\n  it('delay resets on change', () => {\n    const callback = spy();\n    act(() => {\n      ReactDOM.render(<TestComponent callback={callback} />, rootContainer);\n    });\n    clock.tick(500);\n    expect(callback).to.have.been.called.exactly(0);\n    nextValue = 2000;\n    act(() => {\n      document.getElementById('set-delay').click();\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(0);\n    clock.tick(500);\n    expect(callback).to.have.been.called.exactly(0);\n    clock.tick(500);\n    expect(callback).to.have.been.called.exactly(1);\n    clock.tick(2000);\n    expect(callback).to.have.been.called.exactly(2);\n  });\n\n  it('null and undefined delays cancel the interval', () => {\n    const callback = spy();\n    act(() => {\n      ReactDOM.render(<TestComponent callback={callback} />, rootContainer);\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n    act(() => {\n      document.getElementById('set-delay').click();\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n\n    nextValue = 1000;\n    act(() => {\n      document.getElementById('set-delay').click();\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(2);\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(3);\n\n    nextValue = null;\n    act(() => {\n      document.getElementById('set-delay').click();\n    });\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(3);\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(3);\n  });\n\n  it('callback function can change', () => {\n    const callback = spy();\n    const callback2 = spy();\n\n    function Wrapper() {\n      const [isCallback2, setIsCallback2] = useState(false);\n      const changeCallback = () => setIsCallback2(!isCallback2);\n      return (\n        <>\n          <button id=\"change-callback\" onClick={changeCallback}>\n            Change Callback\n          </button>\n          <TestComponent callback={isCallback2 ? callback2 : callback} />\n        </>\n      );\n    }\n\n    act(() => {\n      ReactDOM.render(<Wrapper />, rootContainer);\n    });\n\n    clock.tick(500);\n    expect(callback).to.have.been.called.exactly(0);\n    expect(callback2).to.have.been.called.exactly(0);\n\n    clock.tick(500);\n    expect(callback).to.have.been.called.exactly(1);\n    expect(callback2).to.have.been.called.exactly(0);\n\n    act(() => {\n      document.getElementById('change-callback').click();\n    });\n    expect(callback).to.have.been.called.exactly(1);\n    expect(callback2).to.have.been.called.exactly(0);\n\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n    expect(callback2).to.have.been.called.exactly(1);\n\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n    expect(callback2).to.have.been.called.exactly(2);\n\n    clock.tick(500);\n    act(() => {\n      document.getElementById('change-callback').click();\n    });\n    expect(callback).to.have.been.called.exactly(1);\n    expect(callback2).to.have.been.called.exactly(2);\n\n    clock.tick(500);\n    expect(callback).to.have.been.called.exactly(2);\n    expect(callback2).to.have.been.called.exactly(2);\n\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(3);\n    expect(callback2).to.have.been.called.exactly(2);\n  });\n\n  it('unmounting component cancels interval', () => {\n    const callback = spy();\n\n    function Wrapper() {\n      const [isVisible, setIsVisible] = useState(true);\n      const toggle = () => setIsVisible(!isVisible);\n      return (\n        <>\n          <button id=\"toggle-visible\" onClick={toggle}>\n            Toggle Visible\n          </button>\n          {isVisible && <TestComponent callback={callback} />}\n        </>\n      );\n    }\n\n    act(() => {\n      ReactDOM.render(<Wrapper />, rootContainer);\n    });\n\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n\n    act(() => {\n      document.getElementById('toggle-visible').click();\n    });\n    expect(callback).to.have.been.called.exactly(1);\n\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(1);\n    clock.tick(2500);\n    expect(callback).to.have.been.called.exactly(1);\n\n    act(() => {\n      document.getElementById('toggle-visible').click();\n    });\n    clock.tick(500);\n    expect(callback).to.have.been.called.exactly(1);\n\n    clock.tick(500);\n    expect(callback).to.have.been.called.exactly(2);\n\n    clock.tick(1000);\n    expect(callback).to.have.been.called.exactly(3);\n  });\n});\n"
            }
        },
        "spaceTime": "",
        "submissionStatistics": {
            "correctCount": 1120,
            "failureCount": 215
        },
        "testStrategy": "SANDBOX_ONLY",
        "tests": [],
        "uid": "useInterval",
        "version": 0,
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 0,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "706737551"
        },
        "visualization": {
            "inputType": null,
            "outputType": null
        }
    },
    "difficulty": 0,
    "instructor": "Conner Ardman",
    "name": "useInterval",
    "releaseDate": "2022-05-24T00:00:00Z",
    "type": "CODING_STANDARD",
    "uid": "useInterval"
}