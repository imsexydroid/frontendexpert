{
    "acl": {
        "isAvailable": true,
        "isFree": true,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "DOM Manipulation",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": true,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "category": "DOM Manipulation",
        "hints": [
            "<p>The <span>URL</span> class along with its <span>.searchParams.set</span> method can be helpful to easily create a properly formatted API URL.</p>",
            "<p>\n  The <span>scrollHeight</span>, <span>scrollTop</span> and <span>clientHeight</span>\n  properties might be helpful to determine if you are scrolled to the bottom of the container.\n</p>",
            "<p>\n  <span>scrollHeight</span> is the entire height of an element, including what is not\n  visible due to scrolling. <span>scrollTop</span> gets the number of pixels that have been\n  scrolled down, and <span>clientHeight</span> gets the inner height of the element.\n  These can be combined to determine if the user is scrolled to the bottom of the container\n  by checking if <span>scrollHeight - scrollTop - clientHeight <= 0</span>.\n</p>",
            "<p>After each request, make sure to save the last returned ID to use as the <span>after</span> parameter in future requests.</p>"
        ],
        "languageToWrite": "javascript",
        "name": "Infinite Scroll",
        "notes": "<div class=\"html\">\n  <p>\n    There's another common implementation of infinite scrolling that uses the\n    browser\n    <a\n      class=\"Link Link--fe\"\n      href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\"\n      target=\"_blank\"\n      >Intersection Observer API</a\n    >\n    (our solutions don't use this API because it isn't supported in our testing\n    environment).\n  </p>\n  <p>\n    This API allows for observing the intersection of two DOM elements, referred\n    to as the <span>target</span> and <span>root</span> elements. Using this\n    API, a callback function can be executed when the target is scrolled into\n    view, without needing a <span>\"scroll\"</span> event listener.\n  </p>\n  <p>\n    The primary benefit of this approach is performance, because scroll events,\n    which continually fire as the user scrolls, can take a performance toll on\n    the browser. Using the <span>IntersectionObserver</span>, the relevant\n    callback function will only be executed once, when the element is scrolled\n    into view.\n  </p>\n  <p>\n    For example, the following code would observe when the last testimonal is\n    scrolled into view and would call the\n    <span>fetchAndAppendTestimonials</span> function:\n  </p>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -15px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">const intersectionObserver = new IntersectionObserver(handleIntersection, {\n  root: testimonialContainer,\n  threshold: 1, // Only trigger when the entire target element is intersecting the root.\n});\n\nfunction handleIntersection(entries) {\n  entries.forEach(entry => { // In our case, there will always only be one entry.\n    if (entry.isIntersecting) {\n      fetchAndAppendTestimonials();\n    }\n  });\n}\n\n// After appending the initial testimonials:\nlastTestimonial = document.querySelector('.testimonial:last-child');\nintersectionObserver.observe(lastTestimonial);\n</code></pre>\n</div>\n<div class=\"html\">\n  <p>\n    After appending new testimonials to the page, this solution would then need\n    to update the <span>target</span> by calling <span>unobserve</span> on the\n    old target and <span>observe</span> on the new last testimonial. For\n    example:\n  </p>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -15px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-javascript\">intersectionObserver.unobserve(lastTestimonial);\nif (hasNext) {\n  lastTestimonial = document.querySelector('.testimonial:last-child');\n  intersectionObserver.observe(lastTestimonial);\n}\n</code></pre>\n</div>",
        "prompt": "<div class=\"html\">\n  <p>\n    You're given an API endpoint that returns a list of AlgoExpert testimonials\n    (yes, our real testimonials!), and you have to fetch and display these\n    testimonials on the page.\n  </p>\n  <p>The API expects GET requests at this URL:</p>\n  <pre><span class=\"CodeEditor-promptString CodeEditor-selectable\">https://api.frontendexpert.io/api/fe/testimonials</span></pre>\n  <p>\n    Since there might be a lot of testimonials, you'll have to use the API\n    endpoint's pagination functionality to repeatedly fetch a limited number of\n    testimonials at a time. Specifically, the API accepts the following two\n    query parameters:\n  </p>\n  <ul>\n    <li>\n      <span>limit</span> (required): the maximum number of testimonials to\n      request.\n    </li>\n    <li>\n      <span>after</span> (optional): a string ID used as a cursor for\n      pagination. For instance, if the last testimonial you fetched had an ID of\n      <span>\"55\"</span>, adding <span>after=55</span> to the URL would fetch\n      testimonials starting after the testimonial with ID <span>\"55\"</span>.\n    </li>\n  </ul>\n  <p>For example, this would be a valid URL to request:</p>\n  <pre><span class=\"CodeEditor-promptString CodeEditor-selectable\">https://api.frontendexpert.io/api/fe/testimonials?limit=2&after=55</span></pre>\n  <p>\n    The API responds with a JSON object containing two keys: a\n    <span>\"hasNext\"</span> boolean, which will be <span>false</span> if the\n    response includes the last testimonial in the database, and a\n    <span>\"testimonials\"</span> array, which contains testimonial objects, each\n    with a string <span>\"message\"</span> and a unique string <span>\"id\"</span>,\n    to be used as the <span>after</span> query parameter.\n  </p>\n  <p>For example, the URL above might respond with:</p>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -15px\">\n  <pre class=\"line-numbers\"><code class=\"language-json\">{\n  \"hasNext\": true,\n  \"testimonials\": [\n    {\n      \"message\": \"Excellent product!\",\n      \"id\": \"42\"\n    },\n    {\n      \"message\": \"Love it, 5/5 stars!\",\n      \"id\": \"55\"\n    }\n  ]\n}</code></pre>\n</div>\n<div class=\"html\">\n  <p>\n    This response would indicate that there are more testimonials to be fetched\n    after the testimonial with ID <span>\"55\"</span>, since\n    <span>\"hasNext\"</span> is <span>true</span>.\n  </p>\n  <p>\n    You've been given HTML and CSS files to help you display these testimonials\n    on the page. Specifically, the HTML file contains an empty\n    <span>#testimonial-container</span> div, to which you should append the\n    testimonials. Each testimonial should be placed inside a paragraph element\n    with the <span>testimonial</span> class, which is defined in the CSS file.\n    Once testimonials have been displayed on the page, the HTML should look like\n    this:\n  </p>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -15px\">\n  <pre\n    class=\"line-numbers\"\n  ><code class=\"language-markup\">&lt;div id=\"testimonial-container\"&gt;\n  &lt;p class=\"testimonial\"&gt;{message1}&lt;/p&gt;\n  &lt;p class=\"testimonial\"&gt;{message2}&lt;/p&gt;\n  &lt;p class=\"testimonial\"&gt;{message3}&lt;/p&gt;\n&lt;/div&gt;</code></pre>\n</div>\n<div class=\"html\">\n  <p>\n    Regarding exact functionality, you should fetch 5 testimonials and append\n    them to the testimonial container as soon as the page loads. Then, whenever\n    the user scrolls to the bottom of the testimonial container, you should\n    fetch another 5 testimonials and append them.\n  </p>\n  <p>Note that:</p>\n  <ul>\n    <li>\n      Only one API call should be issued at a time; when one call is pending, no\n      other calls should be issued, even if the user is scrolling down.\n    </li>\n    <li>\n      Once all testimonials have been fetched, you should no longer makes calls\n      to the API.\n    </li>\n    <li>\n      You should use the global <span>fetch()</span> method to make requests to\n      the API (call <span>fetch()</span> directly; don't call\n      <span>window.fetch()</span>).\n    </li>\n    <li>\n      You should listen to <span>\"scroll\"</span> events (don't use\n      <span>IntersectionObserver</span>, because it isn't supported in our\n      testing environment).\n    </li>\n  </ul>\n  <p>\n    Your JavaScript code has already been linked to the pre-written HTML code\n    via a deferred script tag.\n  </p>\n</div>",
        "promptCode": {
            "css": "body {\n  background-color: grey;\n  color: white;\n}\n\nh1 {\n  text-align: center;\n}\n\n#testimonial-container {\n  width: 75ch;\n  height: 75vh;\n  overflow-y: scroll;\n  margin: auto;\n  padding: 10px;\n  border-radius: 12px;\n  background-color: #001119;\n}\n\n.testimonial {\n  font-size: 18px;\n  margin: 16px;\n  padding: 10px;\n  border-top: 4px solid #11967e;\n  border-radius: 8px;\n  background-color: #00557f;\n}\n",
            "html": "<h1>Testimonials</h1>\n<div id=\"testimonial-container\"></div>\n"
        },
        "reactConfig": null,
        "solutions": {
            "javascript": [
                "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nconst API_BASE_URL = 'https://api.frontendexpert.io/api/fe/testimonials';\nconst PAGE_SIZE = 5;\n\nlet canFetchTestimonials = true;\nlet afterID = null;\n\nconst testimonialContainer = document.getElementById('testimonial-container');\n\ntestimonialContainer.addEventListener('scroll', handleScroll);\n\nfetchAndAppendTestimonials();\n\nfunction handleScroll() {\n  if (!canFetchTestimonials) return;\n  const bottomSpaceLeftToScroll = this.scrollHeight - this.scrollTop - this.clientHeight;\n  if (bottomSpaceLeftToScroll > 0) return;\n  fetchAndAppendTestimonials();\n}\n\nfunction fetchAndAppendTestimonials() {\n  canFetchTestimonials = false;\n  const url = createTestimonialsUrl();\n  fetch(url)\n    .then(res => res.json())\n    .then(({testimonials, hasNext}) => {\n      const fragment = document.createDocumentFragment();\n      testimonials.forEach(({message}) => {\n        fragment.appendChild(createTestimonialElement(message));\n      });\n      testimonialContainer.appendChild(fragment);\n\n      if (hasNext) {\n        afterID = testimonials[testimonials.length - 1].id;\n      } else {\n        testimonialContainer.removeEventListener('scroll', handleScroll);\n      }\n\n      canFetchTestimonials = true;\n    });\n}\n\nfunction createTestimonialElement(message) {\n  const testimonialElement = document.createElement('p');\n  testimonialElement.classList.add('testimonial');\n  testimonialElement.textContent = message;\n  return testimonialElement;\n}\n\nfunction createTestimonialsUrl() {\n  const url = new URL(API_BASE_URL);\n  url.searchParams.set('limit', PAGE_SIZE);\n\n  if (afterID != null) {\n    url.searchParams.set('after', afterID);\n  }\n\n  return url;\n}",
                "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nconst API_BASE_URL = 'https://api.frontendexpert.io/api/fe/testimonials';\nconst PAGE_SIZE = 5;\n\nlet canFetchTestimonials = true;\nlet afterID = null;\n\nconst testimonialContainer = document.getElementById('testimonial-container');\n\ntestimonialContainer.addEventListener('scroll', handleScroll);\n\nfetchAndAppendTestimonials();\n\nfunction handleScroll() {\n  if (!canFetchTestimonials) return;\n  const bottomSpaceLeftToScroll = this.scrollHeight - this.scrollTop - this.clientHeight;\n  if (bottomSpaceLeftToScroll > 0) return;\n  fetchAndAppendTestimonials();\n}\n\nasync function fetchAndAppendTestimonials() {\n  canFetchTestimonials = false;\n  const url = createTestimonialsUrl();\n  const response = await fetch(url);\n  const {testimonials, hasNext} = await response.json();\n\n  const fragment = document.createDocumentFragment();\n  testimonials.forEach(({message}) => {\n    fragment.appendChild(createTestimonialElement(message));\n  });\n  testimonialContainer.appendChild(fragment);\n\n  if (hasNext) {\n    afterID = testimonials[testimonials.length - 1].id;\n  } else {\n    testimonialContainer.removeEventListener('scroll', handleScroll);\n  }\n\n  canFetchTestimonials = true;\n}\n\nfunction createTestimonialElement(message) {\n  const testimonialElement = document.createElement('p');\n  testimonialElement.classList.add('testimonial');\n  testimonialElement.textContent = message;\n  return testimonialElement;\n}\n\nfunction createTestimonialsUrl() {\n  const url = new URL(API_BASE_URL);\n  url.searchParams.set('limit', PAGE_SIZE);\n\n  if (afterID != null) {\n    url.searchParams.set('after', afterID);\n  }\n\n  return url;\n}"
            ]
        },
        "startingCode": {
            "javascript": "const API_BASE_URL = 'https://api.frontendexpert.io/api/fe/testimonials';\n\n// Write your code here.\n"
        },
        "submissionStatistics": {
            "correctCount": 1786,
            "failureCount": 1804
        },
        "testHarness": {
            "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nconst {JSDOM} = require('jsdom');\nconst {readFileSync} = require('fs');\nconst chai = require('chai');\nconst spies = require('chai-spies');\nchai.use(spies);\nconst {expect, spy} = chai;\nconst {getTestimonials} = require('./data/api');\n\nconst html = readFileSync('data/index.html');\n\nlet testimonialContainer;\n\nconst resetSpies = () => {\n  spy.restore();\n  spy.on(global, 'fetch');\n};\n\nconst resetDom = () => {\n  const dom = new JSDOM(html, {\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  const convertStringToUrlObj = url => {\n    const [base, params] = url.split('?');\n    const paramPairs = params?.split('&');\n    const urlObj = new URL(base);\n    paramPairs?.forEach(paramStr => {\n      const [key, value] = paramStr.split('=');\n      urlObj.searchParams.set(key, value);\n    });\n    return urlObj;\n  };\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n  global.fetch = url => {\n    const urlObj = typeof url === 'object' ? url : convertStringToUrlObj(url);\n    const acceptedUrls = [\n      'https://www.algoexpert.io/api/testimonials', // old API endpoint\n      'https://api.frontendexpert.io/api/fe/testimonials',\n    ];\n    if (!acceptedUrls.includes(urlObj.origin + urlObj.pathname)) {\n      const response = {\n        status: 404,\n        ok: false,\n        statusText: 'Not Found',\n        type: 'cors',\n        url: urlObj.toString(),\n        redirected: false,\n      };\n      return Promise.resolve(response);\n    }\n    const limit = urlObj.searchParams.get('limit');\n    const after = urlObj.searchParams.get('after');\n    const testims = getTestimonials(limit, after);\n    const response = {\n      status: 200,\n      ok: true,\n      statusText: 'OK',\n      type: 'cors',\n      url: urlObj.toString(),\n      redirected: false,\n      json: async () => testims,\n      text: async () => JSON.stringify(testims),\n    };\n    return Promise.resolve(response);\n  };\n\n  Object.defineProperty(window.HTMLElement.prototype, 'scrollHeight', {\n    configurable: true,\n    get() {\n      return this._scrollHeight || 0;\n    },\n    set(val) {\n      this._scrollHeight = val;\n    },\n  });\n\n  Object.defineProperty(window.HTMLElement.prototype, 'scrollTop', {\n    configurable: true,\n    get() {\n      return this._scrollTop || 0;\n    },\n    set(val) {\n      this._scrollTop = val;\n    },\n  });\n\n  Object.defineProperty(window.HTMLElement.prototype, 'clientHeight', {\n    configurable: true,\n    get() {\n      return this._clientHeight || 0;\n    },\n    set(val) {\n      this._clientHeight = val;\n    },\n  });\n\n  Object.defineProperty(window.HTMLElement.prototype, 'offsetHeight', {\n    configurable: true,\n    get() {\n      return this._offsetHeight || 0;\n    },\n    set(val) {\n      this._offsetHeight = val;\n    },\n  });\n\n  Object.defineProperty(window.HTMLElement.prototype, 'innerText', {\n    configurable: true,\n    get() {\n      return this.textContent;\n    },\n    set(val) {\n      this.textContent = val;\n    },\n  });\n\n  // Reset spies before importing the JS.\n  resetSpies();\n\n  delete require.cache[require.resolve('./program.js')];\n  require('./program.js');\n\n  testimonialContainer = document.getElementById('testimonial-container');\n};\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\nconst TOTAL_TESTIMONIAL_COUNT = getTestimonials(10000).testimonials.length;\nconst PAGE_SIZE = 5;\nconst TOTAL_TESTIMONIAL_PAGES = Math.ceil(TOTAL_TESTIMONIAL_COUNT / PAGE_SIZE);\n\n// Default values mimic scrolling to the bottom of the testimonial container.\nconst triggerScroll = async (scrollHeight = 100, scrollTop = 50, clientHeight = 50) => {\n  testimonialContainer.scrollHeight = scrollHeight;\n  testimonialContainer.scrollTop = scrollTop;\n  testimonialContainer.clientHeight = clientHeight;\n  testimonialContainer.offsetHeight = clientHeight;\n\n  testimonialContainer.dispatchEvent(new window.Event('scroll'));\n  // Flush async browser behavior.\n  await new Promise(setImmediate);\n};\n\nconst assertNumberOfTestimonialElements = n => {\n  const testimonialElements = document.querySelectorAll('.testimonial');\n  expect(testimonialElements.length).to.be.equal(n);\n};\n\ndescribe('infinite scroll', () => {\n  beforeEach(() => {\n    resetDom();\n  });\n\n  describe('before scrolling', () => {\n    it('a page of testimonial elements should be added to the DOM', () => {\n      assertNumberOfTestimonialElements(PAGE_SIZE);\n    });\n\n    it('testimonial elements should have the correct text', () => {\n      const {testimonials} = getTestimonials(PAGE_SIZE);\n      const testimonialElements = document.querySelectorAll('.testimonial');\n      testimonialElements.forEach((testimonialElement, i) => {\n        expect(testimonialElement.textContent).to.be.equal(testimonials[i].message);\n      });\n    });\n  });\n\n  describe('when scrolling', () => {\n    it('scrolling once should add another page of testimonials elements to the DOM', async () => {\n      await triggerScroll();\n      assertNumberOfTestimonialElements(PAGE_SIZE * 2);\n    });\n\n    it(`scrolling past the max amount of testimonials shouldn't add more testimonial elements to the DOM`, async () => {\n      // Mimic reaching the cap of our API.\n      for (i = 1; i < TOTAL_TESTIMONIAL_PAGES; i++) {\n        await triggerScroll();\n      }\n      assertNumberOfTestimonialElements(TOTAL_TESTIMONIAL_COUNT);\n      await triggerScroll();\n      await triggerScroll();\n      await triggerScroll();\n      await triggerScroll();\n      assertNumberOfTestimonialElements(TOTAL_TESTIMONIAL_COUNT);\n    });\n\n    it(`scrolling past the max amount of testimonials shouldn't make calls to the API`, async () => {\n      // Mimic reaching the cap of our API.\n      for (i = 1; i < TOTAL_TESTIMONIAL_PAGES; i++) {\n        await triggerScroll();\n      }\n      // Trigger extra scrolls.\n      await triggerScroll(); // This shouldn't call the API.\n      await triggerScroll(); // This shouldn't call the API.\n      expect(global.fetch).to.have.been.called.exactly(TOTAL_TESTIMONIAL_PAGES); // Last 2 scrolls didn't call API.\n    });\n  });\n});\n",
            "unitTests": "/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nconst {JSDOM} = require('jsdom');\nconst {readFileSync} = require('fs');\nconst chai = require('chai');\nconst spies = require('chai-spies');\nchai.use(spies);\nconst {expect, spy} = chai;\nconst {getTestimonials} = require('./data/api');\n\nconst html = readFileSync('data/index.html');\n\nlet testimonialContainer;\n\nconst resetSpies = () => {\n  spy.restore();\n  spy.on(global, 'fetch');\n};\n\nconst resetDom = () => {\n  const dom = new JSDOM(html, {\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  const convertStringToUrlObj = url => {\n    const [base, params] = url.split('?');\n    const paramPairs = params?.split('&');\n    const urlObj = new URL(base);\n    paramPairs?.forEach(paramStr => {\n      const [key, value] = paramStr.split('=');\n      urlObj.searchParams.set(key, value);\n    });\n    return urlObj;\n  };\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n  global.fetch = url => {\n    const urlObj = typeof url === 'object' ? url : convertStringToUrlObj(url);\n    const acceptedUrls = [\n      'https://www.algoexpert.io/api/testimonials', // old API endpoint\n      'https://api.frontendexpert.io/api/fe/testimonials',\n    ];\n    if (!acceptedUrls.includes(urlObj.origin + urlObj.pathname)) {\n      const response = {\n        status: 404,\n        ok: false,\n        statusText: 'Not Found',\n        type: 'cors',\n        url: urlObj.toString(),\n        redirected: false,\n      };\n      return Promise.resolve(response);\n    }\n    const limit = urlObj.searchParams.get('limit');\n    const after = urlObj.searchParams.get('after');\n    const testims = getTestimonials(limit, after);\n    const response = {\n      status: 200,\n      ok: true,\n      statusText: 'OK',\n      type: 'cors',\n      url: urlObj.toString(),\n      redirected: false,\n      json: async () => testims,\n      text: async () => JSON.stringify(testims),\n    };\n    return Promise.resolve(response);\n  };\n\n  Object.defineProperty(window.HTMLElement.prototype, 'scrollHeight', {\n    configurable: true,\n    get() {\n      return this._scrollHeight || 0;\n    },\n    set(val) {\n      this._scrollHeight = val;\n    },\n  });\n\n  Object.defineProperty(window.HTMLElement.prototype, 'scrollTop', {\n    configurable: true,\n    get() {\n      return this._scrollTop || 0;\n    },\n    set(val) {\n      this._scrollTop = val;\n    },\n  });\n\n  Object.defineProperty(window.HTMLElement.prototype, 'clientHeight', {\n    configurable: true,\n    get() {\n      return this._clientHeight || 0;\n    },\n    set(val) {\n      this._clientHeight = val;\n    },\n  });\n\n  Object.defineProperty(window.HTMLElement.prototype, 'offsetHeight', {\n    configurable: true,\n    get() {\n      return this._offsetHeight || 0;\n    },\n    set(val) {\n      this._offsetHeight = val;\n    },\n  });\n\n  Object.defineProperty(window.HTMLElement.prototype, 'innerText', {\n    configurable: true,\n    get() {\n      return this.textContent;\n    },\n    set(val) {\n      this.textContent = val;\n    },\n  });\n\n  // Reset spies before importing the JS.\n  resetSpies();\n\n  delete require.cache[require.resolve('./program.js')];\n  require('./program.js');\n\n  testimonialContainer = document.getElementById('testimonial-container');\n};\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\nconst TOTAL_TESTIMONIAL_COUNT = getTestimonials(10000).testimonials.length;\nconst PAGE_SIZE = 5;\nconst TOTAL_TESTIMONIAL_PAGES = Math.ceil(TOTAL_TESTIMONIAL_COUNT / PAGE_SIZE);\n\n// Default values mimic scrolling to the bottom of the testimonial container.\nconst triggerScroll = async (scrollHeight = 100, scrollTop = 50, clientHeight = 50) => {\n  testimonialContainer.scrollHeight = scrollHeight;\n  testimonialContainer.scrollTop = scrollTop;\n  testimonialContainer.clientHeight = clientHeight;\n  testimonialContainer.offsetHeight = clientHeight;\n\n  testimonialContainer.dispatchEvent(new window.Event('scroll'));\n  // Flush async browser behavior.\n  await new Promise(setImmediate);\n};\n\nconst assertNumberOfTestimonialElements = n => {\n  const testimonialElements = document.querySelectorAll('.testimonial');\n  expect(testimonialElements.length).to.be.equal(n);\n};\n\ndescribe('infinite scroll', () => {\n  beforeEach(() => {\n    resetDom();\n  });\n\n  describe('before scrolling', () => {\n    it('a page of testimonial elements should be added to the DOM', () => {\n      assertNumberOfTestimonialElements(PAGE_SIZE);\n    });\n\n    it('testimonial elements should have the correct text', () => {\n      const {testimonials} = getTestimonials(PAGE_SIZE);\n      const testimonialElements = document.querySelectorAll('.testimonial');\n      testimonialElements.forEach((testimonialElement, i) => {\n        expect(testimonialElement.textContent).to.be.equal(testimonials[i].message);\n      });\n    });\n  });\n\n  describe('when scrolling', () => {\n    it(`scrolling without getting to the bottom shouldn't append new testimonials`, async () => {\n      await triggerScroll(100, 10, 50);\n      assertNumberOfTestimonialElements(PAGE_SIZE);\n      expect(global.fetch).to.have.been.called.exactly(1);\n    });\n\n    it('scrolling once should add another page of testimonials elements to the DOM', async () => {\n      await triggerScroll();\n      assertNumberOfTestimonialElements(PAGE_SIZE * 2);\n    });\n\n    it('scrolling multiple times should keep adding pages of testimonials elements to the DOM', async () => {\n      await triggerScroll();\n      await triggerScroll();\n      await triggerScroll();\n      assertNumberOfTestimonialElements(PAGE_SIZE * 4);\n    });\n\n    it(`scrolling past the max amount of testimonials shouldn't add more testimonial elements to the DOM`, async () => {\n      // Mimic reaching the cap of our API.\n      for (i = 1; i < TOTAL_TESTIMONIAL_PAGES; i++) {\n        await triggerScroll();\n      }\n      assertNumberOfTestimonialElements(TOTAL_TESTIMONIAL_COUNT);\n      await triggerScroll();\n      await triggerScroll();\n      await triggerScroll();\n      await triggerScroll();\n      assertNumberOfTestimonialElements(TOTAL_TESTIMONIAL_COUNT);\n    });\n\n    it(`scrolling past the max amount of testimonials shouldn't make calls to the API`, async () => {\n      // Mimic reaching the cap of our API.\n      for (i = 1; i < TOTAL_TESTIMONIAL_PAGES; i++) {\n        await triggerScroll();\n      }\n      // Trigger extra scrolls.\n      await triggerScroll(); // This shouldn't call the API.\n      await triggerScroll(); // This shouldn't call the API.\n      expect(global.fetch).to.have.been.called.exactly(TOTAL_TESTIMONIAL_PAGES); // Last 2 scrolls didn't call API.\n    });\n\n    it('testimonial elements should have the correct text', async () => {\n      const {testimonials} = getTestimonials(TOTAL_TESTIMONIAL_COUNT);\n      // Mimic reaching the cap of our API.\n      for (i = 1; i <= TOTAL_TESTIMONIAL_PAGES; i++) {\n        await triggerScroll();\n      }\n      const testimonialElements = document.querySelectorAll('.testimonial');\n      testimonialElements.forEach((testimonialElement, i) => {\n        expect(testimonialElement.textContent).to.be.equal(testimonials[i].message);\n      });\n    });\n\n    it('only one API call should be made at a time', async () => {\n      triggerScroll();\n      triggerScroll(); // This shouldn't call the API.\n      triggerScroll(); // This shouldn't call the API.\n      await triggerScroll(); // This shouldn't call the API.\n      expect(global.fetch).to.have.been.called.exactly(2); // Only 2 calls instead of 5.\n    });\n\n    it('only one set of testimonial elements should be added to the DOM at a time', async () => {\n      triggerScroll();\n      triggerScroll(); // This shouldn't add testimonial elements.\n      triggerScroll(); // This shouldn't add testimonial elements.\n      await triggerScroll(); // This shouldn't add testimonial elements.\n      assertNumberOfTestimonialElements(PAGE_SIZE * 2); // Only 2 pages instead of 5.\n    });\n  });\n});\n"
        },
        "testStrategy": "MOCHA",
        "uid": "infinite-scroll",
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 24,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "646764073"
        }
    },
    "difficulty": null,
    "instructor": "Conner Ardman",
    "name": "Infinite Scroll",
    "releaseDate": "2021-05-24T00:00:00Z",
    "type": "CODING_FRONTEND",
    "uid": "infinite-scroll"
}