{
    "acl": {
        "isAvailable": true,
        "isFree": true,
        "isFreeForStudents": false,
        "productRequired": [
            "frontendexpert"
        ]
    },
    "category": "React Components",
    "contents": {
        "acl": {
            "isAvailable": true,
            "isFree": true,
            "isFreeForStudents": false,
            "productRequired": [
                "frontendexpert"
            ]
        },
        "category": "React Components",
        "hints": [
            "<p>\n  When handling keypresses, you can detect backspaces with the\n  <span>event.key</span> of \"Backspace\", and enter will have the\n  <span>event.key</span> of \"Enter\".\n</p>",
            "<p>\n  Consider keeping three pieces of state: the solution, the current guess, and\n  an array of finalized guesses.\n</p>"
        ],
        "languageToWrite": "jsx",
        "name": "Wordle",
        "notes": "<div class=\"html\">\n  <p>\n    There is a second solution to this problem not covered in the video, which\n    converts the <span>guesses</span> and <span>currentGuess</span> state from\n    using <span>useState</span> to <span>useReducer</span>. The benefit of this\n    change is that it allows for the logic around updating this state to live\n    inside a pure function, rather than to live within the\n    <span>useEffect</span>. This can increase the readability of the code, as\n    well as create a minor performance improvement, since the\n    <span>useEffect</span> no longer needs the <span>guesses</span> array as a\n    dependency.\n  </p>\n</div>",
        "prompt": "<div class=\"html\">\n  <p>\n    You're given a CSS file for a clone of the popular game\n    <a\n     class=\"Link Link--fe\"\n     href=\"https://www.nytimes.com/games/wordle/index.html\"\n     target=\"_blank\"\n     >Wordle</a>, and you need to implement the component using React.\n  </p>\n\n  <p>\n    The rules of Wordle are fairly simple. A 5 letter word will be chosen at\n    random, and the player has 6 guesses to guess the word. After each guess,\n    the player is told which letters are correct as well as which letters are\n    correct but in the wrong position.\n  </p>\n\n  <p>\n    When the component initially mounts, it should make an API request to the\n    word list API at:\n  </p>\n  <pre><span class=\"CodeEditor-promptString CodeEditor-selectable\">https://api.frontendexpert.io/api/fe/wordle-words</span></pre>\n\n  <p>\n    This API expects GET requests with no query parameters. The API returns a\n    JSON formatted array of 5 letter words in all capital letters. You should\n    choose one word randomly from this word list to act as the \"solution\". For\n    example, the API might return this array:\n  </p>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -15px\">\n  <pre class=\"line-numbers\"><code class=\"language-json\">[\n  \"HELLO\",\n  \"WORLD\",\n  \"FRONT\"\n]</code></pre>\n</div>\n\n<div class=\"html\">\n  <p>\n    Once the request to the API returns, a wordle board should be generated.\n    This board contains 6 lines, one for each potential guess. Each line\n    contains 5 tiles, one for each character in the guess. The board should be a\n    div with the class \"board\", each line should be a div with the class\n    \"line\", and each tile should be a div with the class \"tile\".\n    Initially, this HTML should follow this format:\n  </p>\n  </div>\n  <div class=\"code-wrapper prism\" style=\"margin-top: -15px\">\n    <pre class=\"line-numbers\"><code class=\"language-markup\">&lt;div class=\"board\"&gt;\n  &lt;div class=\"line\"&gt;\n    &lt;div class=\"tile\"&gt;&lt;/div&gt;\n    ... &lt;!-- 5 total tiles --&gt;\n    &lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  ... &lt;!-- 6 total lines --&gt;\n  &lt;div class=\"line\"&gt;\n    &lt;div class=\"tile\"&gt;&lt;/div&gt;\n    ... &lt;!-- 5 total tiles --&gt;\n    &lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre>\n  </div>\n\n<div class=\"html\">\n  <p>\n    After this initial board is generated, whenever the user types, the characters\n    typed should be added to the wordle board in the line for the current guess.\n    Typing a letter beyond 5 letters should have no effect. If the user presses\n    \"Backspace\", a single letter should be removed from the current guess\n    if there is one to be removed. If the user presses \"Enter\", the current\n    guess should be \"finalized\" if it has 5 letters in it (otherwise Enter should\n    have no effect).\n  </p>\n\n  <p>\n    When a guess is finalized, pressing backspace should no longer delete characters\n    from that guess. Additionally, each tile should be given one of three classes:\n  </p>\n\n  <ul>\n    <li>\n      <span>correct</span>: If the letter is the same as the letter in the\n      solution at the same index.\n    </li>\n    <li>\n      <span>close</span>: If the letter is in the solution but not at this\n      location.\n    </li>\n    <li>\n      <span>incorrect</span>: If the letter is not in the solution.\n    </li>\n  </ul>\n\n  <p>\n    If the finalized guess was correct (i.e. the same as the solution), the game\n    should be ended. When the game is ended, the board should be left in the same\n    finalized state, and typing should no longer have any effect. Additionally,\n    if the last guess is finalized, the game should be ended, regardless of if\n    the guess was correct.\n  </p>\n\n  <p>\n    For simplicity, you can assume the user will only ever type lowercase letters,\n    backspace, or enter. Additionally, you do not need to check if guesses are\n    in the word list (i.e. users can guess any combination of 5 letters).\n  </p>\n\n  <p>\n    The complete HTML output of a completed game might look like this\n    after first guessing \"hello\" then guessing the correct answer \"world\":\n  </p>\n</div>\n<div class=\"code-wrapper prism\" style=\"margin-top: -15px\">\n  <pre class=\"line-numbers\"><code class=\"language-markup\">&lt;div class=\"board\"&gt;\n  &lt;div class=\"line\"&gt;\n    &lt;div class=\"tile incorrect\"&gt;h&lt;/div&gt;&lt;div class=\"tile incorrect\"&gt;e&lt;/div&gt;&lt;div class=\"tile close\"&gt;l&lt;/div&gt;&lt;div class=\"tile correct\"&gt;l&lt;/div&gt;&lt;div class=\"tile close\"&gt;o&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"line\"&gt;\n    &lt;div class=\"tile correct\"&gt;w&lt;/div&gt;&lt;div class=\"tile correct\"&gt;o&lt;/div&gt;&lt;div class=\"tile correct\"&gt;r&lt;/div&gt;&lt;div class=\"tile correct\"&gt;l&lt;/div&gt;&lt;div class=\"tile correct\"&gt;d&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"line\"&gt;\n    &lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"line\"&gt;\n    &lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"line\"&gt;\n    &lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"line\"&gt;\n    &lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;&lt;div class=\"tile\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre>\n</div>\n<div class=\"html\">\n  <p>\n    Your component has already been rendered to the DOM inside of a\n    <span>#root</span> div directly in the body with the CSS imported.\n  </p>\n</div>",
        "promptCode": {
            "css": "body {\n  background-color: white;\n}\n\n.board {\n  display: flex;\n  flex-direction: column;\n  gap: 10px;\n  padding: 10px;\n}\n\n.line {\n  display: flex;\n  gap: 10px;\n  margin: auto;\n}\n\n.tile {\n  width: 40px;\n  height: 40px;\n  border: 1px solid black;\n  font-size: 30px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  text-transform: capitalize;\n}\n\n.correct {\n  background-color: lightgreen;\n}\n\n.close {\n  background-color: yellow;\n}\n\n.incorrect {\n  background-color: lightgrey;\n}"
        },
        "reactConfig": {
            "componentName": "Wordle"
        },
        "solutions": {
            "jsx": [
                "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nimport React, { useState, useEffect } from 'react';\n\nconst WORD_LIST_API_URL = 'https://api.frontendexpert.io/api/fe/wordle-words';\nconst WORD_LENGTH = 5;\nconst NUM_GUESSES = 6;\n\nexport default function Wordle() {\n  const [guesses, setGuesses] = useState(Array(NUM_GUESSES).fill(null));\n  const [currentGuess, setCurrentGuess] = useState('');\n  const [solution, setSolution] = useState(null);\n\n  useEffect(() => {\n    const fetchSolution = async () => {\n      const response = await fetch(WORD_LIST_API_URL);\n      const words = await response.json();\n      setSolution(words[Math.floor(Math.random() * words.length)].toLowerCase());\n    };\n\n    fetchSolution();\n  }, []);\n\n  useEffect(() => {\n    if (solution == null) return;\n\n    const onPressKey = event => {\n      if (guesses[NUM_GUESSES - 1] != null || guesses.includes(solution)) {\n        return;\n      }\n\n      const charCode = event.key.toLowerCase().charCodeAt(0);\n      const isLetter =\n        event.key.length === 1 &&\n        charCode >= 'a'.charCodeAt(0) &&\n        charCode <= 'z'.charCodeAt(0);\n\n      setCurrentGuess(prevGuess => {\n        if (event.key === 'Backspace') {\n          return prevGuess.slice(0, -1);\n        } else if (event.key === 'Enter' && prevGuess.length === WORD_LENGTH) {\n          const currentGuessIndex = guesses.findIndex(guess => guess == null);\n          const guessesClone = [...guesses];\n          guessesClone[currentGuessIndex] = prevGuess;\n          setGuesses(guessesClone);\n          return '';\n        } else if (prevGuess.length < WORD_LENGTH && isLetter) {\n          return prevGuess + event.key.toLowerCase();\n        }\n        return prevGuess;\n      });\n    };\n\n    window.addEventListener('keydown', onPressKey);\n\n    return () => window.removeEventListener('keydown', onPressKey);\n  }, [guesses, solution]);\n\n  const currentGuessIndex = guesses.findIndex(guess => guess == null);\n\n  if (solution == null) return null;\n\n  return (\n    <div className=\"board\">\n      {\n        guesses.map((guess, i) => {\n          return (\n            <GuessLine\n              key={i}\n              guess={(i === currentGuessIndex ? currentGuess : guess ?? '').padEnd(WORD_LENGTH)}\n              solution={solution}\n              isFinal={currentGuessIndex > i || currentGuessIndex === -1}\n            />\n          );\n        })\n      }\n    </div>\n  );\n}\n\nfunction GuessLine({ guess, solution, isFinal }) {\n  return (\n    <div className=\"line\">\n      {\n        guess.split('').map((char, i) => {\n          let className = 'tile';\n\n          if (isFinal) {\n            if (char === solution[i]) {\n              className += ' correct';\n            } else if (solution.includes(char)) {\n              className += ' close';\n            } else {\n              className += ' incorrect';\n            }\n          }\n\n          return <div key={i} className={className}>{char}</div>;\n        })\n      }\n    </div>\n  );\n}",
                "// Copyright \u00a9 2023 AlgoExpert LLC. All rights reserved.\n\nimport React, { useState, useReducer, useEffect } from 'react';\n\nconst WORD_LIST_API_URL = 'https://api.frontendexpert.io/api/fe/wordle-words';\nconst WORD_LENGTH = 5;\nconst NUM_GUESSES = 6;\n\nfunction reducer(state, {key, solution}) {\n  const {guesses, currentGuess} = state;\n  if (guesses[NUM_GUESSES - 1] != null || guesses.includes(solution)) {\n    return state;\n  }\n\n  switch (key) {\n    case 'Backspace':\n      return {guesses, currentGuess: currentGuess.slice(0, -1)};\n    case 'Enter':\n      if (currentGuess.length !== WORD_LENGTH) return state;\n      const currentGuessIndex = guesses.findIndex(guess => guess == null);\n      const guessesClone = [...guesses];\n      guessesClone[currentGuessIndex] = currentGuess;\n      return {guesses: guessesClone, currentGuess: ''};\n    default:\n      const charCode = key.toLowerCase().charCodeAt(0);\n      const isLetter =\n        key.length === 1 &&\n        charCode >= 'a'.charCodeAt(0) &&\n        charCode <= 'z'.charCodeAt(0);\n\n      if (currentGuess.length < WORD_LENGTH && isLetter) {\n        return {guesses, currentGuess: currentGuess + key.toLowerCase()};\n      }\n    return state;\n  }\n}\n\nexport default function Wordle() {\n  const [{guesses, currentGuess}, dispatch] = useReducer(reducer, {\n    guesses: Array(NUM_GUESSES).fill(null),\n    currentGuess: '',\n  });\n  const [solution, setSolution] = useState(null);\n\n  useEffect(() => {\n    const fetchSolution = async () => {\n      const response = await fetch(WORD_LIST_API_URL);\n      const words = await response.json();\n      setSolution(words[Math.floor(Math.random() * words.length)].toLowerCase());\n    };\n\n    fetchSolution();\n  }, []);\n\n  useEffect(() => {\n    if (solution == null) return;\n\n    const onPressKey = event => {\n      dispatch({key: event.key, solution});\n    };\n\n    window.addEventListener('keydown', onPressKey);\n\n    return () => window.removeEventListener('keydown', onPressKey);\n  }, [solution]);\n\n  const currentGuessIndex = guesses.findIndex(guess => guess == null);\n\n  if (solution == null) return null;\n\n  return (\n    <div className=\"board\">\n      {\n        guesses.map((guess, i) => {\n          return (\n            <GuessLine\n              key={i}\n              guess={(i === currentGuessIndex ? currentGuess : guess ?? '').padEnd(WORD_LENGTH)}\n              solution={solution}\n              isFinal={currentGuessIndex > i || currentGuessIndex === -1}\n            />\n          );\n        })\n      }\n    </div>\n  );\n}\n\nfunction GuessLine({ guess, solution, isFinal }) {\n  return (\n    <div className=\"line\">\n      {\n        guess.split('').map((char, i) => {\n          let className = 'tile';\n\n          if (isFinal) {\n            if (char === solution[i]) {\n              className += ' correct';\n            } else if (solution.includes(char)) {\n              className += ' close';\n            } else {\n              className += ' incorrect';\n            }\n          }\n\n          return <div key={i} className={className}>{char}</div>;\n        })\n      }\n    </div>\n  );\n}"
            ]
        },
        "startingCode": {
            "jsx": "import React from 'react';\n\nconst WORD_LIST_API_URL = 'https://api.frontendexpert.io/api/fe/wordle-words';\n\nexport default function Wordle() {\n  // Write your code here.\n\n  return (\n    <div className=\"board\">\n      {/* Write your code here. */}\n    </div>\n  );\n}"
        },
        "submissionStatistics": {
            "correctCount": 707,
            "failureCount": 1047
        },
        "testHarness": {
            "sandboxCode": "// This file is initialized with a few test cases.\n// Feel free to add, edit, or remove test cases in\n// this file as you see fit!\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Wordle from './program';\nimport {act} from 'react-dom/test-utils';\nconst {JSDOM} = require('jsdom');\nconst {getWords} = require('./data/api');\nconst chai = require('chai');\nconst {expect} = chai;\n\nlet rootContainer;\nlet board;\nlet expectedWord;\n\nconst resetDom = () => {\n  const dom = new JSDOM({\n    url: 'http://localhost:3000',\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n\n  for (const [key, value] of Object.entries(React)) {\n    global[key] = value;\n  }\n\n  const convertStringToUrlObj = url => {\n    const [base, params] = url.split('?');\n    const paramPairs = params?.split('&');\n    const urlObj = new URL(base);\n    paramPairs?.forEach(paramStr => {\n      const [key, value] = paramStr.split('=');\n      urlObj.searchParams.set(key, value);\n    });\n    return urlObj;\n  };\n\n  global.fetch = url => {\n    const urlObj = typeof url === 'object' ? url : convertStringToUrlObj(url);\n    if (urlObj.origin + urlObj.pathname === 'https://api.frontendexpert.io/api/fe/wordle-words') {\n      const words = getWords(expectedWord);\n      const response = {\n        status: 200,\n        ok: true,\n        statusText: 'OK',\n        type: 'cors',\n        url: urlObj.toString(),\n        redirected: false,\n        json: async () => words,\n        text: async () => JSON.stringify(words),\n      };\n      return Promise.resolve(response);\n    }\n\n    const response = {\n      status: 404,\n      ok: false,\n      statusText: 'Not Found',\n      type: 'cors',\n      url: urlObj.toString(),\n      redirected: false,\n    };\n    return Promise.resolve(response);\n  };\n\n  rootContainer = document.createElement('div');\n  rootContainer.id = 'root';\n  document.body.appendChild(rootContainer);\n\n  act(() => {\n    ReactDOM.render(<Wordle />, rootContainer);\n  });\n};\n\nfunction waitForRender() {\n  return new Promise(function (resolve) {\n    setImmediate(resolve);\n  });\n}\n\nconst typeLetter = async letter => {\n  const char = letter.toLowerCase();\n  const options = {\n    key: char,\n    charCode: 0, // Only set on keypress\n\n    // keycode and which are set to uppercase for keydown/keyup events\n    keyCode: char.toUpperCase().charCodeAt(0),\n    which: char.toUpperCase().charCodeAt(0),\n    code: `Key${char.toUpperCase()}`,\n  };\n\n  const keyDown = new window.KeyboardEvent('keydown', options);\n  window.dispatchEvent(keyDown);\n  const keyPress = new window.KeyboardEvent('keypress', {\n    ...options,\n    charCode: char.charCodeAt(0),\n    keyCode: char.charCodeAt(0),\n    which: char.charCodeAt(0),\n  });\n  window.dispatchEvent(keyPress);\n  const keyUp = new window.KeyboardEvent('keyup', options);\n  window.dispatchEvent(keyUp);\n  await waitForRender();\n};\n\nconst typeEnter = async char => {\n  const options = {\n    key: 'Enter',\n    charCode: 0,\n    keyCode: 13,\n    which: 13,\n    code: 'Enter',\n  };\n\n  const keyDown = new window.KeyboardEvent('keydown', options);\n  window.dispatchEvent(keyDown);\n  const keyPress = new window.KeyboardEvent('keypress', options);\n  window.dispatchEvent(keyPress);\n  const keyUp = new window.KeyboardEvent('keyup', options);\n  window.dispatchEvent(keyUp);\n  await waitForRender();\n};\n\nconst typeBackspace = async char => {\n  const options = {\n    key: 'Backspace',\n    charCode: 0,\n    keyCode: 8,\n    which: 8,\n    code: 'Backspace',\n  };\n\n  const keyDown = new window.KeyboardEvent('keydown', options);\n  window.dispatchEvent(keyDown);\n  const keyPress = new window.KeyboardEvent('keypress', options);\n  window.dispatchEvent(keyPress);\n  const keyUp = new window.KeyboardEvent('keyup', options);\n  window.dispatchEvent(keyUp);\n  await waitForRender();\n};\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\ndescribe('wordle', () => {\n  beforeEach(async () => {\n    resetDom();\n    await waitForRender();\n    board = document.querySelector('.board');\n  });\n\n  afterEach(() => {\n    ReactDOM.unmountComponentAtNode(rootContainer);\n    rootContainer.remove();\n    rootContainer = null;\n  });\n\n  describe('initial state', () => {\n    it('generates correct board HTML', () => {\n      expect(board.children.length).to.equal(6);\n      expect(board.tagName).to.equal('DIV');\n      Array.from(board.children).forEach(line => {\n        expect(line.tagName).to.equal('DIV');\n        expect(line.className).to.equal('line');\n        expect(line.children.length).to.equal(5);\n        Array.from(line.children).forEach(tile => {\n          expect(tile.tagName).to.equal('DIV');\n          expect(tile.className).to.equal('tile');\n          expect(tile.children.length).to.equal(0);\n          expect(tile.textContent.trim().length).to.equal(0);\n        });\n      });\n    });\n\n    it('typing fills in first guess', async () => {\n      await typeLetter('a');\n      await waitForRender();\n      let tiles = document.querySelectorAll('.tile');\n      expect(tiles[0].textContent).to.equal('a');\n      tiles.forEach((tile, i) => {\n        if (i === 0) return;\n        expect(tile.textContent.trim()).to.equal('');\n      });\n      await typeLetter('b');\n      await typeLetter('c');\n      await typeLetter('d');\n      await typeLetter('e');\n      await waitForRender();\n\n      tiles = document.querySelectorAll('.tile');\n      const expected = 'abcde';\n      tiles.forEach((tile, i) => {\n        expect(tile.textContent.trim()).to.equal(expected[i] ?? '');\n      });\n    });\n  });\n\n  describe('finalizing words', () => {\n    before(() => {\n      // Make the solution a known but random word\n      // Making letters unique for easy testing\n      const usedLetters = [];\n      expectedWord = Array(5)\n        .fill(0)\n        .map(x => {\n          let letter;\n          do {\n            letter = String.fromCharCode('A'.charCodeAt(0) + Math.floor(Math.random() * 26));\n          } while (usedLetters.includes(letter));\n          usedLetters.push(letter);\n          return letter;\n        })\n        .join('');\n    });\n\n    it('finalized words get the correct tile classes', async () => {\n      let unusedLetter = 'A';\n      while (expectedWord.includes(unusedLetter)) {\n        unusedLetter = String.fromCharCode(unusedLetter.charCodeAt(0) + 1);\n      }\n      await typeLetter(expectedWord[0]);\n      await typeLetter(expectedWord[2]);\n      await typeLetter(unusedLetter);\n      await typeLetter(unusedLetter);\n      await typeLetter(expectedWord[4]);\n      await waitForRender();\n\n      let tiles = document.querySelectorAll('.tile');\n      tiles.forEach((tile, i) => {\n        expect(tile.className.trim()).to.equal('tile');\n      });\n\n      await typeEnter();\n      tiles = document.querySelectorAll('.tile');\n      const expected = ['correct', 'close', 'incorrect', 'incorrect', 'correct'];\n      tiles.forEach((tile, i) => {\n        if (i < expected.length) {\n          expect(tile.classList.contains(expected[i])).to.be.true;\n        } else {\n          expect(tile.className.trim()).to.equal('tile');\n        }\n      });\n    });\n  });\n});\n",
            "unitTests": "/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Wordle from './program';\nimport {act} from 'react-dom/test-utils';\nconst {JSDOM} = require('jsdom');\nconst {getWords} = require('./data/api');\nconst chai = require('chai');\nconst {expect} = chai;\n\nlet rootContainer;\nlet board;\nlet expectedWord;\n\nconst resetDom = () => {\n  const dom = new JSDOM({\n    url: 'http://localhost:3000',\n    resources: 'usable',\n    pretendToBeVisual: true,\n  });\n\n  global.document = dom.window.document;\n  global.window = dom.window;\n\n  for (const [key, value] of Object.entries(React)) {\n    global[key] = value;\n  }\n\n  const convertStringToUrlObj = url => {\n    const [base, params] = url.split('?');\n    const paramPairs = params?.split('&');\n    const urlObj = new URL(base);\n    paramPairs?.forEach(paramStr => {\n      const [key, value] = paramStr.split('=');\n      urlObj.searchParams.set(key, value);\n    });\n    return urlObj;\n  };\n\n  global.fetch = url => {\n    const urlObj = typeof url === 'object' ? url : convertStringToUrlObj(url);\n    if (urlObj.origin + urlObj.pathname === 'https://api.frontendexpert.io/api/fe/wordle-words') {\n      const words = getWords(expectedWord);\n      const response = {\n        status: 200,\n        ok: true,\n        statusText: 'OK',\n        type: 'cors',\n        url: urlObj.toString(),\n        redirected: false,\n        json: async () => words,\n        text: async () => JSON.stringify(words),\n      };\n      return Promise.resolve(response);\n    }\n\n    const response = {\n      status: 404,\n      ok: false,\n      statusText: 'Not Found',\n      type: 'cors',\n      url: urlObj.toString(),\n      redirected: false,\n    };\n    return Promise.resolve(response);\n  };\n\n  rootContainer = document.createElement('div');\n  rootContainer.id = 'root';\n  document.body.appendChild(rootContainer);\n\n  act(() => {\n    ReactDOM.render(<Wordle />, rootContainer);\n  });\n};\n\nfunction waitForRender() {\n  return new Promise(function (resolve) {\n    setImmediate(resolve);\n  });\n}\n\nconst typeLetter = async letter => {\n  const char = letter.toLowerCase();\n  const options = {\n    key: char,\n    charCode: 0, // Only set on keypress\n\n    // keycode and which are set to uppercase for keydown/keyup events\n    keyCode: char.toUpperCase().charCodeAt(0),\n    which: char.toUpperCase().charCodeAt(0),\n    code: `Key${char.toUpperCase()}`,\n  };\n\n  const keyDown = new window.KeyboardEvent('keydown', options);\n  window.dispatchEvent(keyDown);\n  const keyPress = new window.KeyboardEvent('keypress', {\n    ...options,\n    charCode: char.charCodeAt(0),\n    keyCode: char.charCodeAt(0),\n    which: char.charCodeAt(0),\n  });\n  window.dispatchEvent(keyPress);\n  const keyUp = new window.KeyboardEvent('keyup', options);\n  window.dispatchEvent(keyUp);\n  await waitForRender();\n};\n\nconst typeEnter = async char => {\n  const options = {\n    key: 'Enter',\n    charCode: 0,\n    keyCode: 13,\n    which: 13,\n    code: 'Enter',\n  };\n\n  const keyDown = new window.KeyboardEvent('keydown', options);\n  window.dispatchEvent(keyDown);\n  const keyPress = new window.KeyboardEvent('keypress', options);\n  window.dispatchEvent(keyPress);\n  const keyUp = new window.KeyboardEvent('keyup', options);\n  window.dispatchEvent(keyUp);\n  await waitForRender();\n};\n\nconst typeBackspace = async char => {\n  const options = {\n    key: 'Backspace',\n    charCode: 0,\n    keyCode: 8,\n    which: 8,\n    code: 'Backspace',\n  };\n\n  const keyDown = new window.KeyboardEvent('keydown', options);\n  window.dispatchEvent(keyDown);\n  const keyPress = new window.KeyboardEvent('keypress', options);\n  window.dispatchEvent(keyPress);\n  const keyUp = new window.KeyboardEvent('keyup', options);\n  window.dispatchEvent(keyUp);\n  await waitForRender();\n};\n\n/* ---------------------------------- *\n * ----- BROWSER TESTING SET-UP ----- *\n * ---------------------------------- */\n\ndescribe('wordle', () => {\n  beforeEach(async () => {\n    resetDom();\n    await waitForRender();\n    board = document.querySelector('.board');\n  });\n\n  afterEach(() => {\n    ReactDOM.unmountComponentAtNode(rootContainer);\n    rootContainer.remove();\n    rootContainer = null;\n  });\n\n  describe('initial state', () => {\n    it('generates correct board HTML', () => {\n      expect(board.children.length).to.equal(6);\n      expect(board.tagName).to.equal('DIV');\n      Array.from(board.children).forEach(line => {\n        expect(line.tagName).to.equal('DIV');\n        expect(line.className).to.equal('line');\n        expect(line.children.length).to.equal(5);\n        Array.from(line.children).forEach(tile => {\n          expect(tile.tagName).to.equal('DIV');\n          expect(tile.className).to.equal('tile');\n          expect(tile.children.length).to.equal(0);\n          expect(tile.textContent.trim().length).to.equal(0);\n        });\n      });\n    });\n\n    it('typing fills in first guess', async () => {\n      await typeLetter('a');\n      await waitForRender();\n      let tiles = document.querySelectorAll('.tile');\n      expect(tiles[0].textContent).to.equal('a');\n      tiles.forEach((tile, i) => {\n        if (i === 0) return;\n        expect(tile.textContent.trim()).to.equal('');\n      });\n      await typeLetter('b');\n      await typeLetter('c');\n      await typeLetter('d');\n      await typeLetter('e');\n      await waitForRender();\n\n      tiles = document.querySelectorAll('.tile');\n      const expected = 'abcde';\n      tiles.forEach((tile, i) => {\n        expect(tile.textContent.trim()).to.equal(expected[i] ?? '');\n      });\n    });\n\n    it('typing more than 5 letters has no effect', async () => {\n      await typeLetter('a');\n      await typeLetter('b');\n      await typeLetter('c');\n      await typeLetter('d');\n      await typeLetter('e');\n      await typeLetter('f');\n      await typeLetter('g');\n      await waitForRender();\n\n      const tiles = document.querySelectorAll('.tile');\n      const expected = 'abcde';\n      tiles.forEach((tile, i) => {\n        expect(tile.textContent.trim()).to.equal(expected[i] ?? '');\n      });\n    });\n\n    it('typing backspace removes a character', async () => {\n      await typeLetter('a');\n      await typeLetter('b');\n      await typeLetter('c');\n      await typeBackspace();\n      await waitForRender();\n\n      let tiles = document.querySelectorAll('.tile');\n      let expected = 'ab';\n      tiles.forEach((tile, i) => {\n        expect(tile.textContent.trim()).to.equal(expected[i] ?? '');\n      });\n\n      await typeBackspace();\n      await typeLetter('d');\n      await waitForRender();\n      tiles = document.querySelectorAll('.tile');\n      expected = 'ad';\n      tiles.forEach((tile, i) => {\n        expect(tile.textContent.trim()).to.equal(expected[i] ?? '');\n      });\n    });\n\n    it('typing backspace with no current guess has no effect', async () => {\n      await typeBackspace();\n      await waitForRender();\n      let tiles = document.querySelectorAll('.tile');\n      tiles.forEach((tile, i) => {\n        expect(tile.textContent.trim()).to.equal('');\n      });\n\n      await typeLetter('a');\n      await typeLetter('b');\n      await typeLetter('c');\n      await typeBackspace();\n      await typeBackspace();\n      await typeBackspace();\n      await typeBackspace();\n      await waitForRender();\n      tiles = document.querySelectorAll('.tile');\n      tiles.forEach((tile, i) => {\n        expect(tile.textContent.trim()).to.equal('');\n      });\n\n      await typeLetter('a');\n      await typeLetter('b');\n      await typeLetter('c');\n      await waitForRender();\n      tiles = document.querySelectorAll('.tile');\n      expected = 'abc';\n      tiles.forEach((tile, i) => {\n        expect(tile.textContent.trim()).to.equal(expected[i] ?? '');\n      });\n    });\n\n    it('typing backspace after finalizing a guess has no effect', async () => {\n      await typeLetter('a');\n      await typeLetter('b');\n      await typeLetter('c');\n      await typeLetter('d');\n      await typeLetter('e');\n      await typeEnter();\n      await typeBackspace();\n      await typeBackspace();\n      await waitForRender();\n\n      let tiles = document.querySelectorAll('.tile');\n      let expected = 'abcde';\n      tiles.forEach((tile, i) => {\n        expect(tile.textContent.trim()).to.equal(expected[i] ?? '');\n      });\n    });\n\n    it('typing after completing a guess moves on to the next line', async () => {\n      await typeLetter('a');\n      await typeLetter('b');\n      await typeLetter('c');\n      await typeLetter('d');\n      await typeLetter('e');\n      await typeEnter();\n      await waitForRender();\n      await typeLetter('f');\n      await typeLetter('g');\n      await waitForRender();\n\n      let tiles = document.querySelectorAll('.tile');\n      let expected = 'abcdefg';\n      tiles.forEach((tile, i) => {\n        expect(tile.textContent.trim()).to.equal(expected[i] ?? '');\n      });\n    });\n\n    it('typing enter before all 5 letters has no effect', async () => {\n      await typeEnter();\n      await waitForRender();\n      await typeLetter('a');\n      await typeLetter('b');\n      await typeLetter('c');\n      await waitForRender();\n\n      let tiles = document.querySelectorAll('.tile');\n      let expected = 'abc';\n      tiles.forEach((tile, i) => {\n        expect(tile.textContent.trim()).to.equal(expected[i] ?? '');\n      });\n\n      await typeEnter();\n      await waitForRender();\n      await typeLetter('d');\n      await typeLetter('e');\n      await waitForRender();\n\n      tiles = document.querySelectorAll('.tile');\n      expected = 'abcde';\n      tiles.forEach((tile, i) => {\n        expect(tile.textContent.trim()).to.equal(expected[i] ?? '');\n      });\n    });\n  });\n\n  describe('finalizing words', () => {\n    before(() => {\n      // Make the solution a known but random word\n      // Making letters unique for easy testing\n      const usedLetters = [];\n      expectedWord = Array(5)\n        .fill(0)\n        .map(x => {\n          let letter;\n          do {\n            letter = String.fromCharCode('A'.charCodeAt(0) + Math.floor(Math.random() * 26));\n          } while (usedLetters.includes(letter));\n          usedLetters.push(letter);\n          return letter;\n        })\n        .join('');\n    });\n\n    it('finalized words get the correct tile classes', async () => {\n      let unusedLetter = 'A';\n      while (expectedWord.includes(unusedLetter)) {\n        unusedLetter = String.fromCharCode(unusedLetter.charCodeAt(0) + 1);\n      }\n      await typeLetter(expectedWord[0]);\n      await typeLetter(expectedWord[2]);\n      await typeLetter(unusedLetter);\n      await typeLetter(unusedLetter);\n      await typeLetter(expectedWord[4]);\n      await waitForRender();\n\n      let tiles = document.querySelectorAll('.tile');\n      tiles.forEach((tile, i) => {\n        expect(tile.className.trim()).to.equal('tile');\n      });\n\n      await typeEnter();\n      tiles = document.querySelectorAll('.tile');\n      const expected = ['correct', 'close', 'incorrect', 'incorrect', 'correct'];\n      tiles.forEach((tile, i) => {\n        if (i < expected.length) {\n          expect(tile.classList.contains(expected[i])).to.be.true;\n        } else {\n          expect(tile.className.trim()).to.equal('tile');\n        }\n      });\n    });\n\n    it('multiple guesses can be finalized', async () => {\n      let unusedLetter = 'A';\n      while (expectedWord.includes(unusedLetter)) {\n        unusedLetter = String.fromCharCode(unusedLetter.charCodeAt(0) + 1);\n      }\n      await typeLetter(expectedWord[0]);\n      await typeLetter(expectedWord[2]);\n      await typeLetter(unusedLetter);\n      await typeLetter(unusedLetter);\n      await typeLetter(expectedWord[4]);\n      await typeEnter();\n      await waitForRender();\n      await typeLetter(expectedWord[0]);\n      await typeLetter(unusedLetter);\n      await typeLetter(unusedLetter);\n      await typeLetter(expectedWord[3]);\n      await typeLetter(expectedWord[4]);\n      await typeEnter();\n      await waitForRender();\n\n      const tiles = document.querySelectorAll('.tile');\n      const expected = [\n        'correct', 'close', 'incorrect', 'incorrect', 'correct',\n        'correct', 'incorrect', 'incorrect', 'correct', 'correct',\n      ];\n      tiles.forEach((tile, i) => {\n        if (i < expected.length) {\n          expect(tile.classList.contains(expected[i])).to.be.true;\n        } else {\n          expect(tile.className.trim()).to.equal('tile');\n        }\n      });\n    });\n\n    it('typing has no effect after a correct guess', async () => {\n      let unusedLetter = 'A';\n      while (expectedWord.includes(unusedLetter)) {\n        unusedLetter = String.fromCharCode(unusedLetter.charCodeAt(0) + 1);\n      }\n      await typeLetter(expectedWord[0]);\n      await typeLetter(expectedWord[2]);\n      await typeLetter(unusedLetter);\n      await typeLetter(unusedLetter);\n      await typeLetter(expectedWord[4]);\n      await typeEnter();\n      await waitForRender();\n      await typeLetter(expectedWord[0]);\n      await typeLetter(expectedWord[1]);\n      await typeLetter(expectedWord[2]);\n      await typeLetter(expectedWord[3]);\n      await typeLetter(expectedWord[4]);\n      await typeEnter();\n      await waitForRender();\n      await typeBackspace();\n      await typeLetter('a');\n      await typeLetter('b');\n      await typeBackspace();\n      await typeLetter('b');\n      await typeLetter('c');\n      await waitForRender();\n\n      const tiles = document.querySelectorAll('.tile');\n      const expected = [\n        'correct', 'close', 'incorrect', 'incorrect', 'correct',\n        'correct', 'correct', 'correct', 'correct', 'correct',\n      ];\n      tiles.forEach((tile, i) => {\n        if (i < expected.length) {\n          expect(tile.classList.contains(expected[i])).to.be.true;\n        } else {\n          expect(tile.className.trim()).to.equal('tile');\n        }\n      });\n    });\n\n    it('typing has no effect after attempting 6 guesses', async () => {\n      let unusedLetter = 'A';\n      while (expectedWord.includes(unusedLetter)) {\n        unusedLetter = String.fromCharCode(unusedLetter.charCodeAt(0) + 1);\n      }\n      for (let i = 0; i < 6; i++) {\n        await typeLetter(expectedWord[0]);\n        await typeLetter(unusedLetter);\n        await typeLetter(unusedLetter);\n        await typeLetter(unusedLetter);\n        await typeLetter(expectedWord[4]);\n        await typeEnter();\n        await waitForRender();\n      }\n\n      let tiles = document.querySelectorAll('.tile');\n      const expected = [\n        'correct', 'incorrect', 'incorrect', 'incorrect', 'correct',\n        'correct', 'incorrect', 'incorrect', 'incorrect', 'correct',\n        'correct', 'incorrect', 'incorrect', 'incorrect', 'correct',\n        'correct', 'incorrect', 'incorrect', 'incorrect', 'correct',\n        'correct', 'incorrect', 'incorrect', 'incorrect', 'correct',\n        'correct', 'incorrect', 'incorrect', 'incorrect', 'correct',\n      ];\n      tiles.forEach((tile, i) => {\n        expect(tile.classList.contains(expected[i])).to.be.true;\n      });\n\n      await typeLetter('a');\n      await typeLetter('b');\n      await typeLetter('c');\n      await typeLetter('d');\n      await typeLetter('e');\n      await typeEnter();\n      await waitForRender();\n      tiles = document.querySelectorAll('.tile');\n      expect(tiles.length).to.equal(30);\n      tiles.forEach((tile, i) => {\n        expect(tile.classList.contains(expected[i])).to.be.true;\n      });\n    });\n  });\n});\n"
        },
        "testStrategy": "REACT_MOCHA",
        "uid": "wordle",
        "video": {
            "annotations": [],
            "codeWalkthroughTime": null,
            "duration": 0,
            "instructor": "Conner Ardman",
            "overviewTime": null,
            "vimeoId": "724695687"
        }
    },
    "difficulty": null,
    "instructor": "Conner Ardman",
    "name": "Wordle",
    "releaseDate": "2022-07-01T00:00:00Z",
    "type": "CODING_FRONTEND",
    "uid": "wordle"
}